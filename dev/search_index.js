var documenterSearchIndex = {"docs":
[{"location":"status/","page":"Status","title":"Status","text":"High-level nets are not completely implemented. This statement will remain true as incremental progress is slowly made. It is safe to state this will be one of the last feature to near completion.\n\n(as of November 2022). Supporting continuous/hybrid high-level nets may not be possible. We currently do not try. Note this is a extension to what the specifiction covers: natural numbers.","category":"section"},{"location":"status/#Roadmap","page":"Status","title":"Roadmap","text":"https://www.pnml.org/tools.php lists two expected features of a \"PNML supporting tool\":\n\ncreate PNML files conforming to a PNTD meta-model\nload PNML files and use PNTD meta-models to \"make\" a Petri Net\n\nwith the presumption that one does something useful.\n\nHave not considered any part of creating or writing out a Petri Net model. This package, PNML.jl, aims to provide infrastructure to interact with other Julia packages, including graphs, category theory, SciML, agents. All focus has been on the \"load\" part of the expected behavior. The meta-models are encoded in the structure of PNML.jl, notably in the type system. Doing \"something useful\" is mostly aspriational until adequate function is present.\n\nThe first useful things will be trivial and obvious:\n\ndisplay the PNML Model\nanalyze the PNML Model\nconstruct a Petri.jl Model to solve an ODE.  # maybe not trivial or obvious :)\n\nNext will be to interface with graph-theoretical packages. Enhancing the display and analysis features.\n\nEditing petri net models is not planned, so writing the model is trivial\n\nCheckpointing and writing in some \"non-PNML\" format is another anticipated feature.\n\nFeatures mentioned in ISO/IEC 15909-3:2021 Part 3: Extensions and Structuring Mechanisms\n\nspecial arcs: inhibitor, read, reset\ncapacity place: maximum multiset of tokens a place can hold\nFIFO queue place (queues in general)\nsort generator: sorts and operators from signatures","category":"section"},{"location":"structure/labels/#","page":"Labels","title":"","text":"","category":"section"},{"location":"structure/labels/#Labels","page":"Labels","title":"Labels","text":"","category":"section"},{"location":"structure/labels/#Diagrams","page":"Labels","title":"Diagrams","text":"(Image: skinparam componentStyle rectangle\nscale max 1024*1024\n\ntitle Input\n\ncloud \"pnml.com\" {\n    database \"RelaxNG Schema\" $schema\n    file PNTD\n}\n\nfile \"Input.pnml\"\n\ncomponent Parser #Yellow {\n    [EzXML]\n    [XMLDict]\n}\n\ncomponent Core {\n    [Sort]\n    [Term]\n    [Declaration]\n    [Lable]\n    [Node]\n    [Expression]\n}\ncomponent Storage {\n    component [DeclDict] {\n        component variabledecls\n        component namedsorts\n        component arbitrarysorts\n        component partitionsorts\n        component namedoperators\n        component arbitraryoperators\n        component partitionops\n        component feconstants\n        component usersorts\n        component useroperators\n    }\n    component [NetKeys] {\n        component page_set\n        component place_set\n        component transition_set\n        component arc_set\n        component reftransition_set\n        component refplace_set\n    }\n    component [NetData] {\n        component place_dict\n        component transition_dict\n        component arc_dict\n        component refplace_dict\n        component reftransition_dict\n    }\n}\n\ncomponent PetriNet {\n    [PnmlNet]\n}\n\"Input.pnml\" -- PNTD : uri\n\"RelaxNG Schema\" -- PNTD\n\nInput.pnml -- Parser : xml\nParser -- Core\nCore -- Storage\nPetriNet -- Storage\nPetriNet -- Core)","category":"section"},{"location":"structure/labels/#PNTD-Maps","page":"Labels","title":"PNTD Maps","text":"Defaut PNTD to Symbol map (URI string to pntd symbol):\n\nusing PNML; foreach(println, sort(collect(pairs(PNML.PnmlTypes.pntd_map)))) #hide\n\nPnmlType map (pntd symbol to singleton):\n\nusing PNML; foreach(println, pairs(PNML.PnmlTypes.pnmltype_map)) #hide","category":"section"},{"location":"structure/labels/#Handling-Labels","page":"Labels","title":"Handling Labels","text":"The implementation of Labels supports annotation and attribute format labels.","category":"section"},{"location":"structure/labels/#Annotation-Labels","page":"Labels","title":"Annotation Labels","text":"annotation format labels are expected to have either a <text> element, a <structure> element or both. Often the <text> is a human-readable representation of of the <structure> element. Graphics and ToolInfo elements may be present.\n\nFor PTNet (and pnmlcore) only the Name label with a <text> element (and no <structure> element) is defined by the standard.\n\nLabels defined in High-Level pntds, specifically 'Symmetric Nets', \"require\" all meaning to reside in the <structure>.","category":"section"},{"location":"structure/labels/#Attribute-Labels","page":"Labels","title":"Attribute Labels","text":"attribute format labels are present in the UML model of pnml. They differ from annotation by omitting the Graphics element, but retain the ToolInfo element. Unless an optimization is identified, both attribute and annotation will share the same implementation.\n\nA standard-conforming pnml model would not have any Graphics element so that field would be nothing.","category":"section"},{"location":"structure/labels/#PNML.PnmlTypes.pntd_map-structure-labels","page":"Labels","title":"PNML.PnmlTypes.pntd_map","text":"Map from Petri Net Type Definition (pntd) URI to Symbol. Allows multiple strings to map to the same pntd.\n\nThere is a companion map pnmltype_map that takes the symbol to a type object.\n\nThe URI is a string and may be the full URL of a pntd schema, just the schema file name, or a placeholder for a future schema.\n\nFor readability, the 'pntd symbol' should match the name used in the URI with inconvinient characters removed or replaced. For example, '-' is replaced by '_'.\n\n\n\n\n\n","category":"constant"},{"location":"structure/labels/#PNML.PnmlTypes.pnmltype_map-structure-labels","page":"Labels","title":"PNML.PnmlTypes.pnmltype_map","text":"The key Symbols are the supported kinds of Petri Nets. Maps to singletons.\n\n\n\n\n\n","category":"constant"},{"location":"structure/defaults/#Default-Values","page":"Default Values","title":"Default Values","text":"Varies by PNTD. Possibilitie include:\n\nmarkings: return zero(Int), zero(Float64), or empty multiset of same sort as adjacent place's sorttype.\ninscription: return one(Int), one(Float64), or singleton multiset of same sort as adjacent place's sorttype with value of first(elements(sort)).\ncondition: return true, or BooleanConstant(true)\n\nThe ISO/IEC 15909-2 standard and the RelaxNG Schemas state 'natural numbers' and 'non-zero natural numbers'. I choose to also allow continuous values to support nonstandard continuous and hybrid valued Petri Nets. Makes generating default values more interesting.\n\nDetermine type of Number to parse with number_value by using value_type.\n\nThere are many items in the XML that are permitted to be missing and a defaut value is assumed. Examples are place initial marking, arc inscription, transition condition, graphics data.\n\nplace initial marking is assumed to be empty, i. e. 0.\narc inscription is assumed to be 1.\ntransition condition is assumed to be true\ngraphics data, e.g. token position, line width, are TBD\n\nThere are multiple kinds of nets supported by PNML.jl differing by (among other properties) the kind on number they use:\n\ndiscrete,\ncontinuous,\nand multi-sorted algebra\n\nSee PnmlType - Petri Net Type Definition for the full hierarchy.\n\nThis means there are at least 3 sets of default value types. We use the pntd PnmlType as a trait to determine the default types/values.\n\nA consequence is that the default value's type ripples through the type system.","category":"section"},{"location":"structure/defaults/#Methods","page":"Default Values","title":"Methods","text":"PNML.Labels.default\n\nmethods(PNML.Labels.default) # hide","category":"section"},{"location":"structure/defaults/#Examples","page":"Default Values","title":"Examples","text":"julia> c = default(Condition, PnmlCoreNet(), net)\nCondition(\"\", BooleanEx(BooleanConstant(true)))\n\njulia> c()\ntrue\n\njulia> c = default(Condition, PnmlCoreNet(), net)\nCondition(\"\", BooleanEx(BooleanConstant(true)))\n\njulia> c = default(Condition, PnmlCoreNet(), net)\nCondition(\"\", BooleanEx(BooleanConstant(true)))","category":"section"},{"location":"structure/mathematics/#Mathematical-Semantics","page":"Math","title":"Mathematical Semantics","text":"ISO 15909 High-level Petri nets Standard  parts 1 and 3 describe the sematics using math notation and part 2 provides the syntax using XML, UML2 and RelaxNG Schema.\n\nHere we pick out bits for exposition.  Recommend using the standard for completeness.","category":"section"},{"location":"structure/mathematics/#Color-Functions","page":"Math","title":"Color Functions","text":"In symmetric nets, arcs are labelled by color functions which select tokens in adjacent places depending on the instantiation performed for the firing.","category":"section"},{"location":"structure/mathematics/#Basic-Color-Functions","page":"Math","title":"Basic Color Functions","text":"In Part 1 refer to Concept 15 (symmetric finite cartesian net) and Concept 16 (basic color functions)\n\nLet C be a non-empty finite set.  A non-empty finite color class C_i defines a type over C. Part 2 calls this a Sort.\n\nA color domain is a finite cartesian product of color classes: D = prod_i=1^n C_i.  Part 2 calls this a ProductSort.\n\nLet C_i be a color class and D = C_1^e_1 times  times C_k^e_k a color domain.\n\nGeneral color function: C(transition) -> Bag(C(place)), where C is a mapping (not a finite set as before).\n\nColor functions from D to  Bag(C_i) for multiset c = langle c_1^1   c_1^e_1  c_k^1  c_k^e_k rangle:\n\nprojections that select one component of a color\n\nX_C_i^j(c) = c_i^j forall j  1 leq j leq e_j\n\nsuccessor functions that select the successor of a component of a color\n\nX_C_i^j(c)++ the successor of c_i^j in C_i forall j  1 leq j leq e_j\n\n\"global\" selections that map any color to the \"sum\" of colors\n\nC_iall(c) = sum_c in C_ix and C_iqall(c) = sum_c in C_ix\n\nsumx in Part 1 is A.5.3.3 Notation 5 (bag notation, equivalence with the supporting set).\n\nC_iq seems to refer to what Part 2 calls a Partition. Where C_i = uplus_q=1s_i C_iq is a color class that is partitioned into s_i static subclasses.\n\nConcept 17 (class color functions)\n\nf_C_i = sum_k=1e_i alpha_ik cdot langle X_C_i^k rangle +\nsum_q=1s_i beta_iq cdot langle C_iqall rangle +\nsum_k=1e_i gamma_ik cdot langle X_i^k++ rangle\n\nsuch that forall d in D forall c in C_i f_C_i(d)(c) geq 0, where constraints on alpha_ik beta_iq gamma_ik are defined to ensure f_C_i(d)(c)  0  forall c in C_i","category":"section"},{"location":"structure/enabling_firing/#Enabling-and-Firing","page":"Enabling & Firing Rules","title":"Enabling and Firing","text":"See discussions on PnmlTuple, ProductSorts and variables.\n\nThis is a discussion of ENABLING rule\n\nc::Condition is attached to  t::Transition.\n\npreset(net, pid(t)) ∪ postset(net, pid(t)) are the attached arcs.\n\narc inscription expressions have variable arguments as do conditions.\n\nvars are ordered collections in standard! It uses Abstract Math and UML2 to say so. As they are the arguments to operators (expressions with variables), they need to be consistent.\n\n0-ary operators are constants and literals (as ground terms without variables). Rewriting may? optimize/minimize these terms.\n\nThere will be inscriptions in preset(t) that are ground terms (constant or literal). Use in postset is the obvious case: generate token. A preset ground term inscription will not have a variable and use a multiplicity = 1. Value will be of the marking basis sort (like all inscriptions). The inscription is enabled if multiset[value] > 0, and value is removed on firing. This is the same behavior as for PTNets that use integer-valued markings and inscriptions.","category":"section"},{"location":"structure/enabling_firing/#binding-value-set","page":"Enabling & Firing Rules","title":"binding value set","text":"Collection of subsitution dictionaries created from binding value sets of all incriptions by selecting one from each set. length(1st set) * length(2nd set) * ... length(nth set)\n\nCondition     Each dictionary is one substitution for every variable     Dict(REFID => value in bindingvalueset(REFID))\n\nsub = Dict{REFID,Ref{SORT}}()\n\nRef{SORT}(multiset element) || Ref{SORT}(multiset element, tuple index)\n    REFID may be repeated\n        multiple of same var in an inscrition <= multplicity of a value in marking multiset\n    &/or\n        same var in multiple inscriptions all with same value\n\nfor each substituion tuple element\n    sub(varid) maps the variable to a value\n    Used in evaluating (c::Condition)() to filter the substituion collection\n\nfor each preset(t) inscription\n    bindings to marking values that satisfy the inscription.\n    Only continue if all constraints are met, else return `false`.\n    if var already has a binding only consider those values\n        remove values from binding that do not satisfy this inscription\n        value must be present in each marking of sufficent multiplicity\n    #todo recursivly re-evaluate after each add?\n\nPnmlTuple that are ProductSort elements and julia Tuple are not the same. ^ The vars tuple may contain elements of a PnmlTuple. Use marking basis to decide.\n\nvariables are how an element of marking multiset is identified/assessed.  for each preset(t)\n\neach element of each marking multiset is bound to the variable or variables  -> tuple of bindings\nenabling rule returning true for a tuple of bindings adds tuple to enabled transition modes.\n\nGenerate JIT compiled code that uses REFID to update the VariableDeclaration  with arg reference information then applies/evaluates expression using the value.\n\n? Each arg in iteratable ordered collection args is bound as the value of a ? pnml variable that appears within the expression tree rooted at term?\n\nVarible in tree is a REFID to a VariableDeclaration that has the name and sort.  args are pairs of name (or REFID) and reference to marking value.\n\nReference to marking value is only read here as part of enabling function.\n\nMake a copy of expression? Just during bring-up to verify same behavior & debug.  Simplify the expression by rewriting once (not each use).  The optimized expression still has variables at this point that are REFIDs.\n\npreset variables are a superset of postset variables.  Every postset variable is also a preset variable.\n\nVariable v is bound to preset marking value (element of a multiset)\n\nas tuple of place REFID index into marking_vector, and a mutiset element.\nbv_sets is a vector of variable binding value sets, one for each variable\nuse multipicity(multiset, element) >= length(v in variables(inscription(arc))) to test enabled state of binding to an element\nbuild a binding value set (bvs) of those element bindings that are enabled\neach arc shares a bvs in bv_sets for each variable in variables(inscription(arc))\ntrvars records variables in transaction. There is a bvsets for each REFID in tv_vars\none or more of the bvs members is selected for a firing\n\n\nUse variable to remove element (decrease multiplicity) from preset, add element to postset.\n\nforeach preset(t) arc inscription vars tuple    enabling rule iterates matches for variable sort in marking multiset    testing each binding combination in condition functor.\n\nWill iterate over each preset(t) marking's multiset elements.  There will be (must be) a variable for each sort in the multiset basis.  PnmlTuples are unpacked into multiple variables.\n\nVariables that appear in more than one preset(t) marking basis  must have the same value in each marking to be enabled","category":"section"},{"location":"library/#PNML","page":"Docstrings","title":"PNML","text":"","category":"section"},{"location":"library/#PNML.PnmlTypes","page":"Docstrings","title":"PNML.PnmlTypes","text":"","category":"section"},{"location":"library/#PNML.IDRegistrys","page":"Docstrings","title":"PNML.IDRegistrys","text":"","category":"section"},{"location":"library/#PNML.Sorts","page":"Docstrings","title":"PNML.Sorts","text":"","category":"section"},{"location":"library/#PNML.Declarations","page":"Docstrings","title":"PNML.Declarations","text":"","category":"section"},{"location":"library/#PNML.PnmlGraphics","page":"Docstrings","title":"PNML.PnmlGraphics","text":"","category":"section"},{"location":"library/#PNML.Labels","page":"Docstrings","title":"PNML.Labels","text":"","category":"section"},{"location":"library/#PNML.Parser","page":"Docstrings","title":"PNML.Parser","text":"","category":"section"},{"location":"library/#PNML.Expressions","page":"Docstrings","title":"PNML.Expressions","text":"","category":"section"},{"location":"library/#Index","page":"Docstrings","title":"Index","text":"Modules = [PNML, PNML.PnmlTypes, PNML.IDRegistrys, PNML.Sorts, PNML.Declarations, PNML.PnmlGraphics, PNML.Labels, PNML.Parser, PNML.Expressions]","category":"section"},{"location":"library/#PNML.PNML","page":"Docstrings","title":"PNML.PNML","text":"Petri Net Markup Language, is an XML-based format. PNML.jl reads a pnml model and emits an intermediate representation (IR).\n\nThe intermediate representation (IR) represents the XML tree via julia data structures: dictionaries, NamedTuples, strings, numbers, objects, vectors. The exact mixture changes as the project continues.\n\nThe tags of the XML are used as keys and names as much as possible.\n\nWhat is accepted as values is ~~often~~ a superset of what a given pntd schema specifies. This can be thought of as duck-typing. Conforming to the pntd is not the role of the IR.\n\nThe pnml standard has layers. This package has layers: PnmlNet, AbstractPetriNet\n\nThe core layer is useful and extendable. The standard defines extensions of the core, called meta-models, for\n\nplace-transition petri nets (integers) and\nhigh-level petri net graphs (many-sorted algebra).\n\nThis package family adds non-standard continuous net (float64) support. Note that there is not yet any RelaxNG schema for our extensions.\n\nOn top of the concrete PnmlNet of the IR are net adaptions and interpertations. This is the level that Petri Net conformance can be imposed. It is also where other Net constructs can be defined over PnmlNets. Perhaps as new meta-models.\n\n\n\n\n\n","category":"module"},{"location":"library/#PNML.CONFIG","page":"Docstrings","title":"PNML.CONFIG","text":"See PnmlConfig for default values.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.Maybe","page":"Docstrings","title":"PNML.Maybe","text":"Alias for Union{T, Nothing}.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractLabel","page":"Docstrings","title":"PNML.AbstractLabel","text":"abstract type AbstractLabel\n\nLabels are attached to the Petri Net Graph objects. See AbstractPnmlObject.\n\nExpected interface is for every concrete label to have at least these fields:     - text     - graphics     - toolspecinfos     - net\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractOperator","page":"Docstrings","title":"PNML.AbstractOperator","text":"abstract type AbstractOperator <: PNML.AbstractTerm\n\nOperators are part of the high-level pnml many-sorted algebra.\n\n...can be a built-in constant or a built-in operator, a multiset operator which among others can construct a multiset from an enumeration of its elements, or a tuple operator. Each operator has a sequence of sorts as its input sorts, and exactly one output sort, which defines its signature.\n\nSee NamedOperator and ArbitraryOperator.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractPnmlNet","page":"Docstrings","title":"PNML.AbstractPnmlNet","text":"abstract type AbstractPnmlNet\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractPnmlNode","page":"Docstrings","title":"PNML.AbstractPnmlNode","text":"abstract type AbstractPnmlNode <: PNML.AbstractPnmlObject\n\nPetri Net Graph nodes are Place, Transition. They are the source or target of an Arc\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractPnmlObject","page":"Docstrings","title":"PNML.AbstractPnmlObject","text":"abstract type AbstractPnmlObject\n\nObjects of a Petri Net Graph are pages, arcs, nodes.\n\nExpected interface is for every concrete object to have at least these fields:     - id     - namelabel     - graphics     - extralabels     - toolspecinfos\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractSort","page":"Docstrings","title":"PNML.AbstractSort","text":"AbstractSort\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractSortRef","page":"Docstrings","title":"PNML.AbstractSortRef","text":"SortRef\n\nSortRef is the name of the Module created by Moshi @data to hold an ADT.\n\nEach variant has a REFID Symbol that indexes one of the dictionaries in the network's declaration dictionary collection (DeclDict).\n\nThe REFID will be in the network's IDRegistry.\n\nUserSortRef is created from <usersort declaration=\"id\" />.\n\nWe use NamedSortRef -> ConcreteSort to add a name and REFID to built-in sorts, thus making them accessable. This extends this decoupling (symbols instead of sorts) to anonymous sorts that are inlined.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractTerm","page":"Docstrings","title":"PNML.AbstractTerm","text":"abstract type AbstractTerm\n\nTerms are part of the multi-sorted algebra that is part of a High-Level Petri Net.\n\nConcrete terms are Variable and Operator found within the <structure> element of a label. They are parsed into PnmlExpr as TermInterface expressions thar are evaluated during the enabling and firing rule.\n\nNotably, a Term is not a PnmlLabel (or a PNML Label).\n\nReferences\n\nSee also Declaration, Labels.SortType, AbstractDeclaration.\n\nTerm_(logic):\n\nA first-order term is recursively constructed from constant symbols, variables and function symbols.\n\nBesides in logic, terms play important roles in universal algebra, and rewriting systems.\n\nmore convenient to think of a term as a tree.\n\nA term that doesn't contain any variables is called a ground term\n\nWhen the domain of discourse contains elements of basically different kinds, it is useful to split the set of all terms accordingly. To this end, a sort (sometimes also called type) is assigned to each variable and each constant symbol, and a declaration...of domain sorts and range sort to each function symbol....\n\nType_theory\n\nterm in logic is recursively defined as a constant symbol, variable, or a function application, where a term is applied to another term\n\nif t is a term of type σ → τ, and s is a term of type σ, then the application of t to s, often written (t s), has type τ.\n\nLambda terms:\n\nThe term redex, short for reducible expression, refers to subterms that can be reduced by one of the reduction rules.\n\nSee Metatheory and SymbolicUtils\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractVariable","page":"Docstrings","title":"PNML.AbstractVariable","text":"abstract type AbstractVariable <: PNML.AbstractTerm\n\nVariables are part of the high-level pnml many-sorted algebra.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Annotation","page":"Docstrings","title":"PNML.Annotation","text":"abstract type Annotation <: PNML.AbstractLabel\n\nLabel that may be displayed. Differs from an Attribute Label by possibly having a Graphics field. We do not implement a separate Attribute type since graphics is optional.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AnyElement","page":"Docstrings","title":"PNML.AnyElement","text":"struct AnyElement{T}\n\ntag::Symbol\nelements::Any\n\nHold AbstractDict holding zero or more well-formed XML elments. See also ToolInfo and PnmlLabel.\n\nCreates a tree where the root is tag, leaf node values are Union{String, SubString{String}}, and interior nodes values are Union{XmlDictType, Vector{XmlDictType}}\n\nSee XmlDictType.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Arc","page":"Docstrings","title":"PNML.Arc","text":"Edge of a Petri Net Markup Language graph that connects place and transition.\n\nmutable struct Arc{T<:PNML.Expressions.PnmlExpr, N<:AbstractPnmlNet} <: PNML.AbstractPnmlNode\n\nid::Symbol\nsource::Base.RefValue{Symbol}\ntarget::Base.RefValue{Symbol}\ninscription::PNML.Labels.Inscription\narctypelabel::PNML.Labels.ArcType\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nextralabels::OrderedCollections.LittleDict{Symbol, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Symbol}}, AbstractVector{Symbol}}, VS<:Union{Tuple, AbstractVector{Any}}}\nnet::AbstractPnmlNet\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.BooleanConstant","page":"Docstrings","title":"PNML.BooleanConstant","text":"BooleanConstant(\"true\"|\"false\")\nBooleanConstant(true|false)\n\nA built-in operator constructor (constants are 0-ary operators).\n\nExamples\n\n    c = BooleanConstant(\"true\");\n    c == BooleanConstant(true)\n    c() == true\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.BooleanConstant-Tuple{AbstractString}","page":"Docstrings","title":"PNML.BooleanConstant","text":"Create by parsing string s to value of type Bool.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Coordinate","page":"Docstrings","title":"PNML.Coordinate","text":"struct Coordinate\n\nx_::Float32\ny_::Float32\n\nCartesian Coordinate are positive decimals. Ranges from 0 to 999.9.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Coordinate-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Docstrings","title":"PNML.Coordinate","text":"Construct a Coordinate from mixed Int, Float64.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.DeclDict","page":"Docstrings","title":"PNML.DeclDict","text":"struct DeclDict\n\nvariabledecls::Dict{Symbol, Any}:     Holds VariableDeclaration.     A Variable is used to locate the declaration's name and sort.\n\nnamedsorts::Dict{Symbol, Any}\narbitrarysorts::Dict{Symbol, Any}\npartitionsorts::Dict{Symbol, Any}\nmultisetsorts::Dict{Symbol, Any}\nproductsorts::Dict{Symbol, Any}\nnamedoperators::Dict{Symbol, Any}\narbitraryoperators::Dict{Symbol, Any}\npartitionops::Dict{Symbol, Any}\nfeconstants::Dict{Symbol, Any}\nuseroperators::Dict{Symbol, Any}\n\nCollection of dictionaries holding various kinds of PNML declarations. Each keyed by REFID symbols.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.DotConstant","page":"Docstrings","title":"PNML.DotConstant","text":"The only element of DotSort is DotConstant. This is a 0-arity opertor term that evaluates to 1.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.FEConstant","page":"Docstrings","title":"PNML.FEConstant","text":"FEConstant\n\nFinite enumeration constant and its containing sort.\n\n\"...these FEConstants are part of the declaration of the FiniteEnumeration sort. On the other hand, each of these FEConstants defines a 0-ary operation, i. e. is a declaration of a constant.\"\n\nUsage\n\nfec = FEConstant(:anID, \"somevalue\", sortref)\nfec() == :anID\nfec.name = \"somevalue\"\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.FiniteIntRangeConstant","page":"Docstrings","title":"PNML.FiniteIntRangeConstant","text":"struct FiniteIntRangeConstant{T<:Integer, S<:AbstractSortRef} <: PNML.AbstractOperator\n\nMust refer to a value between the start and end of the respective FiniteIntRangeSort.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.HLAnnotation","page":"Docstrings","title":"PNML.HLAnnotation","text":"abstract type HLAnnotation <: PNML.AbstractLabel\n\nAnnotation label that adds <structure>.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.LabelParser","page":"Docstrings","title":"PNML.LabelParser","text":"struct LabelParser\n\ntag::Symbol\nfunc::Union{Function, Type}\n\nMaps a Symbol to a callable for parsing an XML label <tag>'s well-formed contents. The parser will be called as func(node, pntd) and return a label object.\n\nSee fill_builtin_labelparsers! for some built-in label parsers.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.MalformedException","page":"Docstrings","title":"PNML.MalformedException","text":"struct MalformedException <: PNML.PnmlException\n\nmsg::String\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.MissingIDException","page":"Docstrings","title":"PNML.MissingIDException","text":"struct MissingIDException <: PNML.PnmlException\n\nmsg::String\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.NumberConstant","page":"Docstrings","title":"PNML.NumberConstant","text":"NumberConstant{T<:Number, S}\n\nBuiltin operator that has arity=0 means the same result every time, a constant. Restricted to NumberSorts, those Sorts whose eltype isa Number.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Operator","page":"Docstrings","title":"PNML.Operator","text":"PNML Operator as Functor\n\ntag maps to func, a functor/function Callable. Its arity is same as length of inexprs and insorts\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Page","page":"Docstrings","title":"PNML.Page","text":"mutable struct Page{PNTD<:PNML.PnmlTypes.PnmlType, N<:AbstractPnmlNet} <: PNML.AbstractPnmlObject\n\nnet::AbstractPnmlNet\npntd::PNML.PnmlTypes.PnmlType\nid::Symbol\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nextralabels::OrderedCollections.LittleDict{Symbol, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Symbol}}, AbstractVector{Symbol}}, VS<:Union{Tuple, AbstractVector{Any}}}\nnetsets::PNML.PnmlNetKeys\n\nContain all places, transitions & arcs. Pages are for visual presentation. There must be at least 1 Page for a valid pnml model.\n\nPNTD binds the other type parameters together to express a specific PNG. See PnmlNet\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Place","page":"Docstrings","title":"PNML.Place","text":"mutable struct Place{S<:AbstractSortRef, N<:AbstractPnmlNet} <: PNML.AbstractPnmlNode\n\nid::Symbol\ninitialMarking::PNML.Labels.Marking\nsorttype::PNML.Labels.SortType\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nextralabels::OrderedCollections.LittleDict{Symbol, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Symbol}}, AbstractVector{Symbol}}, VS<:Union{Tuple, AbstractVector{Any}}}\nnet::AbstractPnmlNet\n\nPlace node of a Petri Net Markup Language graph.\n\nEach place has an initial marking that has a basis matching sorttype. M is a \"multiset sort denoting a collection of tokens\". A \"multiset sort over a basis sort is interpreted as \"the set of multisets over the type associated with the basis sort\".\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlConfig","page":"Docstrings","title":"PNML.PnmlConfig","text":"Configuration with default values that can be overidden by a LocalPreferences.toml.\n\nOptions\n\nindent_width::Int: Indention of nested lines.\ntext_element_optional::Bool: There are pnml files that break the rules & do not have <text> elements.\nwarn_on_fixup::Bool: When an missing value is replaced by a default value, issue a warning.\nwarn_on_namespace::Bool: There are pnml files that break the rules & do not have an xml namespace.\nwarn_on_unclaimed::Bool: Issue warning when PNML label does not have a parser defined. While allowed, there will be code required to do anything useful with the label.\nwarn_on_unimplemented::Bool: Issue warning to highlight something unimplemented. Expect high volume of messages.\nverbose::Bool: Print information as runs.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlException","page":"Docstrings","title":"PNML.PnmlException","text":"abstract type PnmlException <: Exception\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlModel","page":"Docstrings","title":"PNML.PnmlModel","text":"struct PnmlModel\n\nnets::Dict{Symbol, Any}\nnamespace::String\n\nOne or more Petri Nets.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlMultiset","page":"Docstrings","title":"PNML.PnmlMultiset","text":"pnmlmultiset(basis::AbstractSortRef, x::T, multi::Int=1) -> PnmlMultiset{T,S<:AbstractsortRef}\n\nConstruct as a multiset with one element, x, with default multiplicity of 1.\n\nPnmlMultiset wraps a Multisets.Multiset{T} where T is the basis sort element type.\n\nSome Operatorsand [Variables`](@ref) create/use a multiset. Thre are constants (and 0-arity operators) defined that must be multisets since HL markings are multisets.\n\nSee Bag for expression that returns this data structure.\n\n\"multix\" is text representation of the<numberof>operator that produces a multiset. As does<all>` operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlNet","page":"Docstrings","title":"PNML.PnmlNet","text":"mutable struct PnmlNet{PNTD<:PNML.PnmlTypes.PnmlType} <: AbstractPnmlNet\n\nOne Petri Net of a PNML model.\n\ntype::PNML.PnmlTypes.PnmlType\nid::Symbol\nidregistry::PNML.IDRegistrys.IDRegistry: The meta-model type this net implements.\npagedict::OrderedCollections.OrderedDict{Symbol, Page{PNTD}} where PNTD<:PNML.PnmlTypes.PnmlType\nnetdata::PNML.PnmlNetData\npage_idset::OrderedCollections.OrderedSet{Symbol}\nddict::PNML.DeclDict\ndeclaration::Union{Nothing, PNML.Labels.Declaration}\nnamelabel::Union{Nothing, PNML.Labels.Name}\ntoolspecinfos::Vector{PNML.Labels.ToolInfo}\nextralabels::OrderedCollections.LittleDict{Symbol, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Symbol}}, AbstractVector{Symbol}}, VS<:Union{Tuple, AbstractVector{Any}}}\nlabelparser::OrderedCollections.LittleDict{Symbol, Union{Function, Type}, KS, VS} where {KS<:Union{Tuple{Vararg{Symbol}}, AbstractVector{Symbol}}, VS<:Union{Tuple{Vararg{Union{Function, Type}}}, AbstractVector{Union{Function, Type}}}}\ntoolparser::OrderedCollections.LittleDict{Pair{String, String}, Union{Function, Type}, KS, VS} where {KS<:Union{Tuple{Vararg{Pair{String, String}}}, AbstractVector{Pair{String, String}}}, VS<:Union{Tuple{Vararg{Union{Function, Type}}}, AbstractVector{Union{Function, Type}}}}:     Collection that associates a tool name & version with a callable parser.     The parser turns <toolspecific name=\"\" version=\"\"> into ToolInfo objects.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlNetData","page":"Docstrings","title":"PNML.PnmlNetData","text":"struct PnmlNetData\n\nplace_dict::OrderedCollections.OrderedDict{Symbol, Any}\ntransition_dict::OrderedCollections.OrderedDict{Symbol, Any}\narc_dict::OrderedCollections.OrderedDict{Symbol, Any}\nrefplace_dict::OrderedCollections.OrderedDict{Symbol, Any}\nreftransition_dict::OrderedCollections.OrderedDict{Symbol, Any}\n\nCollect each of the PnmlNodess & Arcs of a Petri Net Graph into one collection. Accessed via pnml ID key or iterate over values of an OrderedDict.\n\nIn the 'pnml' standard there is a Page structure that can be removed by flatten_pages!, removing some display-related information, leaving a functional Petri Net Graph as described in this structure. It is intended to be a per-PnmlNet database that is mutated as each page is parsed.\n\nSee PnmlNetKeys for page-level pnml ID of \"owners\" net data.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlNetKeys","page":"Docstrings","title":"PNML.PnmlNetKeys","text":"struct PnmlNetKeys\n\npage_set::OrderedCollections.OrderedSet{Symbol}\nplace_set::OrderedCollections.OrderedSet{Symbol}\ntransition_set::OrderedCollections.OrderedSet{Symbol}\narc_set::OrderedCollections.OrderedSet{Symbol}\nreftransition_set::OrderedCollections.OrderedSet{Symbol}\nrefplace_set::OrderedCollections.OrderedSet{Symbol}\n\nPer-page structure of OrderedSets of pnml IDs for each \"owned\" Page and other AbstractPnmlObject.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.REFID","page":"Docstrings","title":"PNML.REFID","text":"Alias for Symbol that refers to something with an ID Symbol.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.RefPlace","page":"Docstrings","title":"PNML.RefPlace","text":"Reference Place node of a Petri Net Markup Language graph. For connections between pages.\n\nstruct RefPlace{N<:AbstractPnmlNet} <: PNML.ReferenceNode\n\nr\n\nid::Symbol\nref::Symbol\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nextralabels::OrderedCollections.LittleDict{Symbol, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Symbol}}, AbstractVector{Symbol}}, VS<:Union{Tuple, AbstractVector{Any}}}\nnet::AbstractPnmlNet\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.RefTransition","page":"Docstrings","title":"PNML.RefTransition","text":"Refrence Transition node of a Petri Net Markup Language graph. For connections between pages.\n\nstruct RefTransition{N<:AbstractPnmlNet} <: PNML.ReferenceNode\n\nid::Symbol\nref::Symbol\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nextralabels::OrderedCollections.LittleDict{Symbol, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Symbol}}, AbstractVector{Symbol}}, VS<:Union{Tuple, AbstractVector{Any}}}\nnet::AbstractPnmlNet\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.ReferenceNode","page":"Docstrings","title":"PNML.ReferenceNode","text":"abstract type ReferenceNode <: PNML.AbstractPnmlObject\n\nFor common behavior shared by RefPlace, RefTransition used to connect Page together.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.ToolParser","page":"Docstrings","title":"PNML.ToolParser","text":"struct ToolParser{T<:Union{Function, Type}}\n\ntoolname::String\nversion::String\nfunc::Union{Function, Type}\n\nHolds a parser callable for a <toolspecific> tag's well-formed contents.\n\nWill be in an iteratable collection that maps tool name & version to a parser callable. See toolspecific_content_fallback(node, pntd).\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Transition","page":"Docstrings","title":"PNML.Transition","text":"Transition node of a Petri Net Markup Language graph.\n\nmutable struct Transition{N<:AbstractPnmlNet} <: PNML.AbstractPnmlNode\n\nid::Symbol\ncondition::PNML.Labels.Condition\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nextralabels::OrderedCollections.LittleDict{Symbol, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Symbol}}, AbstractVector{Symbol}}, VS<:Union{Tuple, AbstractVector{Any}}}\nvars::Set{Symbol}\nvarsubs::Vector{NamedTuple}: Cache of variable substitutons for this transition\nnet::AbstractPnmlNet\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.UserOperator","page":"Docstrings","title":"PNML.UserOperator","text":"struct UserOperator{N<:AbstractPnmlNet} <: PNML.AbstractOperator\n\ndeclaration::Symbol\nnet::AbstractPnmlNet\n\nUser operator wraps a REFID to a OperatorDeclaration.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Variable","page":"Docstrings","title":"PNML.Variable","text":"struct Variable{N<:AbstractPnmlNet} <: PNML.AbstractVariable\n\nrefvariable::Symbol\nnet::AbstractPnmlNet\n\nVariable refers to a VariableDeclaration. Example input: <variable refvariable=\"varx\"/>.\n\n#TODO examples of use, modifying and accessing\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.XmlDictType","page":"Docstrings","title":"PNML.XmlDictType","text":"Dictionary passed to XMLDict.xml_dict as dict_type. See xmldict.\n\n\n\n\n\n","category":"type"},{"location":"library/#Base.:*-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{Number, PNML.PnmlMultiset{T, S, N}}} where {T, S<:AbstractSortRef, N<:AbstractPnmlNet}","page":"Docstrings","title":"Base.:*","text":"n*B for PnmlMultisets is the scalar multiset product.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:*-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{PNML.PnmlMultiset{T, S, N}, PNML.PnmlMultiset{T}}} where {T, S<:AbstractSortRef, N<:AbstractPnmlNet}","page":"Docstrings","title":"Base.:*","text":"A*B for PnmlMultisets is forwarded to Multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:+-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{PNML.PnmlMultiset{T, S, N}, PNML.PnmlMultiset{T, S, N}}} where {T, S<:AbstractSortRef, N<:AbstractPnmlNet}","page":"Docstrings","title":"Base.:+","text":"A+B for PnmlMultisets is the disjoint union of enclosed multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:--Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{PNML.PnmlMultiset{T, S, N}, PNML.PnmlMultiset{T, S, N}}} where {T, S<:AbstractSortRef, N<:AbstractPnmlNet}","page":"Docstrings","title":"Base.:-","text":"A-B for PnmlMultisets is the disjoint union of enclosed multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:<-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{PNML.PnmlMultiset{T, S, N}, PNML.PnmlMultiset{T, S, N}}} where {T, S<:AbstractSortRef, N<:AbstractPnmlNet}","page":"Docstrings","title":"Base.:<","text":"A<B for PnmlMultisets is forwarded  toMultiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:<=-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{PNML.PnmlMultiset{T, S, N}, PNML.PnmlMultiset{T, S, N}}} where {T, S<:AbstractSortRef, N<:AbstractPnmlNet}","page":"Docstrings","title":"Base.:<=","text":"A<=B for PnmlMultisets is forwarded to Multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:>-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{PNML.PnmlMultiset{T, S, N}, PNML.PnmlMultiset{T, S, N}}} where {T, S<:AbstractSortRef, N<:AbstractPnmlNet}","page":"Docstrings","title":"Base.:>","text":"A>B for PnmlMultisets is forwarded  toMultiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:>=-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{PNML.PnmlMultiset{T, S, N}, PNML.PnmlMultiset{T, S, N}}} where {T, S<:AbstractSortRef, N<:AbstractPnmlNet}","page":"Docstrings","title":"Base.:>=","text":"A>=B for PnmlMultisets is forwarded to Multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._attribute-Tuple{OrderedCollections.LittleDict{Union{String, Symbol}, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Union{String, Symbol}}}, AbstractVector{Union{String, Symbol}}}, VS<:Union{Tuple, AbstractVector{Any}}}, Symbol}","page":"Docstrings","title":"PNML._attribute","text":"XMLDict uses symbols as keys. Value returned is a string.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._cvt_inscription_value-Tuple{PNML.PnmlTypes.PnmlType, Union{Nothing, Arc}, Any, Any}","page":"Docstrings","title":"PNML._cvt_inscription_value","text":"Convert inscription value of PT_HLPNG from multiset to cardinality of the multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._op_dictionaries-Tuple{}","page":"Docstrings","title":"PNML._op_dictionaries","text":"Return tuple of operator dictionary fields in the Declaration Dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._ops-Tuple{Any}","page":"Docstrings","title":"PNML._ops","text":"Return iterator over operator dictionaries of Declaration Dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._sort_dictionaries-Tuple{}","page":"Docstrings","title":"PNML._sort_dictionaries","text":"Return tuple of sort dictionary fields in the Declaration Dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._sorts-Tuple{Any}","page":"Docstrings","title":"PNML._sorts","text":"Return iterator over sort dictionaries of Declaration Dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.accum_varset!-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict, Symbol}","page":"Docstrings","title":"PNML.accum_varset!","text":"Collect/intersect binding of one arc variable binding set.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.accum_varsets!-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Docstrings","title":"PNML.accum_varsets!","text":"accum_varsets!(bvs, arc_bvs) -> Bool\n\nCollect variable bindings, intersecting among arcs. Return enabled status of false if any variable does not have a substitution.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.adjacent_place","page":"Docstrings","title":"PNML.adjacent_place","text":"adjacent_place(net::PnmlNet, arc::Arc) -> Place\nadjacent_place(netdata::PnmlNetData, source,::Symbol target::Symbol) -> Place\n\nAdjacent place of an arc is either the source or target.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.all_arcs","page":"Docstrings","title":"PNML.all_arcs","text":"Return arcs that have a source or target of transition id.\n\nSee also src_arcs, tgt_arcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.allpages-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.allpages","text":"allpages(net::PnmlNet|dict::OrderedDict) -> Iterator\n\nReturn iterator over all pages in the net. Maintains insertion order.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.append_page!-Tuple{Page, Page}","page":"Docstrings","title":"PNML.append_page!","text":"Append selected fields of r to fields of l. Some, like Names and xml, are omitted because they are scalar values, not collections.\n\npagedict & netdata (holding the arc and pnml nodes) are per-net data that is not modified here. netsets hold pnml IDs \"owned\"\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arbitraryop-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.arbitraryop","text":"Lookup arbitraryop with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arbitraryop-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.arbitraryop","text":"Lookup arbitraryop with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arbitraryops-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.arbitraryops","text":"Return dictionary of ArbitraryOperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arbitraryops-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.arbitraryops","text":"Return dictionary of ArbitraryOperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arbitrarysort-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.arbitrarysort","text":"Lookup arbitrarysort with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arbitrarysort-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.arbitrarysort","text":"Lookup arbitrarysort with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arbitrarysorts-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.arbitrarysorts","text":"Return dictionary of ArbitrarySort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arbitrarysorts-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.arbitrarysorts","text":"Return dictionary of ArbitrarySort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arc","page":"Docstrings","title":"PNML.arc","text":"Return arc with id if found, otherwise nothing.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.arc-Tuple{Any, Symbol, Symbol}","page":"Docstrings","title":"PNML.arc","text":"Return Arc from 's' to 't' or nothing. Useful for graphs where arcs are represented by a tuple or pair (source,target).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arc_idset","page":"Docstrings","title":"PNML.arc_idset","text":"Return iterator over arc ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.arcs","page":"Docstrings","title":"PNML.arcs","text":"arcs(n::PnmlNet) -> iterator\narcs(p::AbstractPetriNet) -> iterator\n\nReturn iterator over arc ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.arctypelabel-Tuple{Arc}","page":"Docstrings","title":"PNML.arctypelabel","text":"arctypelabel(arc::Arc) -> ArcType\n\nAccess arctype label of arc.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.basis","page":"Docstrings","title":"PNML.basis","text":"basis(x, ddict) -> AbstractSortRef\n\nReturn AbstractSortRef referencing a NamedSort, ArbitrarySort or PartitionSort declaration. MultisetSort, Multiset, List have a basis.  Default basis is sortof Place marking & sorttype, arc inscriptions have a basis.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.basis-Tuple{PNML.PnmlMultiset}","page":"Docstrings","title":"PNML.basis","text":"basis(ms::PnmlMultiset) -> AbstractSortRef\n\nMultiset basis sort is accessed through a AbstractSortRef that holds a REFID index into decldict(net). MultisetSorts not allowed here. Nor loops in sort references.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.binding_value_sets-Tuple{PnmlNet, Any}","page":"Docstrings","title":"PNML.binding_value_sets","text":"binding_value_sets(net::PnmlNet, marking) -> Vector{Dict{REFID,Any}}\n\nReturn dictionary with transaction ID is key and value is binding set for variables of that transition. Each variable of an enabled transition will have a non-empty binding.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.cardinality-Tuple{PNML.PnmlMultiset}","page":"Docstrings","title":"PNML.cardinality","text":"cardinality(ms::PnmlMultiset, x) -> Integer\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.condition","page":"Docstrings","title":"PNML.condition","text":"Return condition's value of transition.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.condition-Tuple{Transition}","page":"Docstrings","title":"PNML.condition","text":"condition(::Transition) -> Condition\n\nReturn condition label.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.conditions","page":"Docstrings","title":"PNML.conditions","text":"conditions(net::PnmlNet) -> Iterator\n\nIterate over REFID => condition(transaction) pairs of net. This is the same order as transactions.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.coordinate_type","page":"Docstrings","title":"PNML.coordinate_type","text":"coordinate_type(x) -> Type(Coordinate)\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.declarations-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.declarations","text":"declarations(dd::DeclDict) -> Iterator\n\nReturn an iterator over all the declaration dictionaries' values.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.decldict","page":"Docstrings","title":"PNML.decldict","text":"decldict(net::AbstractPnmlNet) -> DeclDict\n\nAccess net-level DeclDict.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.deref!-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.deref!","text":"deref!(net::PnmlNet; trim, verbose)\n\n\nRemove reference nodes from arcs.\n\nOperates on the PnmlNetData at the net level. Expects that the PnmlNetKeys of the firstpage will have to be cleaned as part of flatten_pages!,\n\nAxioms\n\nAll ids in a network are unique in that they only have one instance in the XML.\nA chain of reference Places (or Transitions) always ends at a Place (or Transition).\nAll ids are valid.\nNo cycles.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.deref_place-Tuple{PnmlNet, Symbol}","page":"Docstrings","title":"PNML.deref_place","text":"deref_place(net, id[], trim::Bool] ) -> Symbol\n\nReturn id of referenced place. If trim is true (default) the reference is removed.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.deref_transition-Tuple{PnmlNet, Symbol}","page":"Docstrings","title":"PNML.deref_transition","text":"deref_transition(net, id[, trim::Bool] ) -> Symbol\n\nReturn id of referenced transition. If trim is true (default) the reference is removed.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.dict_show","page":"Docstrings","title":"PNML.dict_show","text":"dict_show(io::IO, x)\n\nInternal helper for things that contain XmlDictType.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.enabled","page":"Docstrings","title":"PNML.enabled","text":"enabled(::PnmlNet, marking) -> Vector{Bool}\n\nReturn vector of booleans where true means the matching transition is enabled at current marking. Has the same order as the transitions dictionary. Used in the firing rule. Update tr.vars Set and tr.varsubs NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.feconstant-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.feconstant","text":"Lookup feconstant with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.feconstant-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.feconstant","text":"Lookup feconstant with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.feconstants-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.feconstants","text":"Return dictionary of FEConstant\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.feconstants-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.feconstants","text":"Return dictionary of FEConstant\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.fill_builtin_labelparsers!-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.fill_builtin_labelparsers!","text":"fill_builtin_labelparsers!(net::AbstractPnmlNet) -> Nothing\nfill_builtin_labelparsers!(labelparser::AbstractDict) -> Nothing\n\nFill context with the base built-in label parsers.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.fill_builtin_sorts!-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.fill_builtin_sorts!","text":"fill_builtin_sorts!(net::AbstractPnmlNet) -> Nothing\n\nFill a DeclDict with built-ins and defaults (that may be redefined).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.fill_builtin_toolparsers!-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.fill_builtin_toolparsers!","text":"fill_builtin_toolparsers!(net::AbstractPnmlNet) -> Nothing\nfill_builtin_toolparsers!(toolparsers::AbstractDict) -> Nothing\n\nFill context with the base built-in tool parsers.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.fill_sort_tag!-Tuple{AbstractPnmlNet, Symbol, Any, Union{Function, Type}}","page":"Docstrings","title":"PNML.fill_sort_tag!","text":"fill_sort_tag!(net::AbstractPnmlNet, tag::Symbol, sort, dict) -> AbstractSortRef\n\nIf not already in the declarations dictionary dict, add sort with key of tag.\n\nRegister the tag and create and return an AbstractSortRef holding tag.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.fill_toolparsers!-Tuple{AbstractDict, Any}","page":"Docstrings","title":"PNML.fill_toolparsers!","text":"Add parser to dictionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.find_net-Tuple{Any, Symbol}","page":"Docstrings","title":"PNML.find_net","text":"find_net(model, id::Symbol) -> Any\n\n\nReturn PnmlNet having id or nothing.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.find_nets","page":"Docstrings","title":"PNML.find_nets","text":"Return nets matching pntd type given as string, symbol or pnmltype instance.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.find_valuekey","page":"Docstrings","title":"PNML.find_valuekey","text":"Look for matching value x in dictionary d, return key symbol or nothing.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.fire-Tuple{Any, Any, Any}","page":"Docstrings","title":"PNML.fire","text":"fire(incidence, enabled, marking) -> ArbitraryOperator\n\nReturn the marking vector after firing transition:   marking + incidence * enabled\n\nmarking values added to product of incidence' matrix and firing vector enabled.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.firstpage-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.firstpage","text":"Usually the only interesting page.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.flatten_pages!","page":"Docstrings","title":"PNML.flatten_pages!","text":"flatten_pages!(net::PnmlNet[; options])\n\nMerge page content into the 1st page of the net.\n\nOptions\n\ntrim::Bool Remove refrence nodes (default true). See deref!.\nverbose::Bool Print breadcrumbs See CONFIG.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.func-Tuple{PNML.LabelParser}","page":"Docstrings","title":"PNML.func","text":"LabelParser Callable.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.func-Tuple{PNML.ToolParser}","page":"Docstrings","title":"PNML.func","text":"Return callable parser of a ToolInfo.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.get_arc_bvs!-Tuple{AbstractDict, Vararg{Any, 4}}","page":"Docstrings","title":"PNML.get_arc_bvs!","text":"get_arc_bvs!(arc_bvs, arc_vars, placesort, mark, net) -> Bool\n\nFill arc_bvs with an entry for each key in arc_vars. Return true if no variables are present or all variables have at least 1 substution.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.get_label","page":"Docstrings","title":"PNML.get_label","text":"get_label(x, tag::Symbol) -> PnmlLabel\n\nReturn first label of x with a matching tagvalue.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.get_label-Tuple{Any, Union{SubString{String}, String, Symbol}}","page":"Docstrings","title":"PNML.get_label","text":"get_label(x, tag) -> Maybe{AbstractLabel}\n\nx is anyting that supports 'labels'. tag is the tag of the xml label element.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.has_arc","page":"Docstrings","title":"PNML.has_arc","text":"\n\nReturn true if any arc has id.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.has_key-Tuple{AbstractPnmlNet, Any, Symbol}","page":"Docstrings","title":"PNML.has_key","text":"has_key(net::AbstractPnmlnet, dict, key::Symbol) -> Bool\n\nWhere dict is the access method for a dictionary in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.has_key-Tuple{PNML.DeclDict, Any, Symbol}","page":"Docstrings","title":"PNML.has_key","text":"has_key(dd::DeclDict, dict, key::Symbol) -> Bool\n\nWhere dict is the access method for a dictionary in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.has_operator-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.has_operator","text":"Does any operator dictionary contain id?\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.has_operator-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.has_operator","text":"Does any operator dictionary contain id?\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.has_place","page":"Docstrings","title":"PNML.has_place","text":"Return true if there is any place with id?\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.has_refplace","page":"Docstrings","title":"PNML.has_refplace","text":"\n\n\n\n","category":"function"},{"location":"library/#PNML.has_reftransition","page":"Docstrings","title":"PNML.has_reftransition","text":"\n\n\n\n","category":"function"},{"location":"library/#PNML.has_transition","page":"Docstrings","title":"PNML.has_transition","text":"Is there a transition with id?\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.inc_indent","page":"Docstrings","title":"PNML.inc_indent","text":"Increment the :indent value by inc.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.incidence_matrix","page":"Docstrings","title":"PNML.incidence_matrix","text":"incidence_matrix(petrinet) -> Matrix\n\nWhen token identity is collective, marking and inscription values are Numbers and matrix C[arc(transition,place)] = inscription(arc(transition,place)) - inscription(arc(place,transition)) is called the incidence_matrix.\n\nHigh-level nets have tokens with individual identity, perhaps tuples of them, usually multisets of finite enumerations, can be other sorts including numbers, strings, lists. Symmetric nets are restricted, and thus easier to deal with and reason about.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.indent-Tuple{IO}","page":"Docstrings","title":"PNML.indent","text":"Return blank string of current indent size in io.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.initial_marking","page":"Docstrings","title":"PNML.initial_marking","text":"Return the initial marking of a place.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.input_matrix","page":"Docstrings","title":"PNML.input_matrix","text":"input_matrix(petrinet::AbstractPetriNet) -> Matrix{value_type(Inscription, ::PnmlType))}\ninput_matrix(petrinet::PnmlNet) -> Matrix{value_type(Inscription, ::PnmlType)}\n\nCreate and return a matrix ntransitions x nplaces.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.inscription","page":"Docstrings","title":"PNML.inscription","text":"Return incription value of arc.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.inscription-Tuple{Arc}","page":"Docstrings","title":"PNML.inscription","text":"inscription(arc::Arc) -> Inscription\n\nAccess inscription label of arc.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.inscription-Tuple{PnmlNet, Symbol}","page":"Docstrings","title":"PNML.inscription","text":"Forward inscription to arcdict\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.inscription_value","page":"Docstrings","title":"PNML.inscription_value","text":"inscription_value(a::Maybe{Arc}, def, varsub) -> T\n\nIf a is nothing return def else evaluate inscription expression with varsub, where def is a default value of same sort as adjacent place. and varsub is a possibly empty variable substitution.\n\nUsed to create arrays where the default value is used when there is no arc between an place and transition of the net.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.inscriptions","page":"Docstrings","title":"PNML.inscriptions","text":"inscriptions(net::PnmlNet) -> Iterator\n\nIterate over REFID => inscription(arc) pairs of net. This is the same order as arcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.isbuiltinoperator-Tuple{Symbol}","page":"Docstrings","title":"PNML.isbuiltinoperator","text":"isbuiltinoperator(::Symbol) -> Bool\n\nIs tag in builtin_operators()?\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.isfiniteoperator-Tuple{Symbol}","page":"Docstrings","title":"PNML.isfiniteoperator","text":"iisfiniteoperator(::Symbol) -> Bool\n\nIs tag in finite_operators()?\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.isoperator-Tuple{Symbol}","page":"Docstrings","title":"PNML.isoperator","text":"isoperator(tag::Symbol) -> Bool\n\nPredicate to identify operators in the high-level pntd's many-sorted algebra abstract syntaxt tree.\n\nNote: It is not the same as Meta.isoperator. Both work on Symbols. Not expecting any conflict.\n\ninteger\nmultiset\nboolean\ntuple\nbuiltin constant\nuseroperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.ispid-Tuple{Symbol}","page":"Docstrings","title":"PNML.ispid","text":"ispid(x::Symbol)\n\nReturn function to be used like: any(ispid(:asym), iterablewithpid).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.labeled_places","page":"Docstrings","title":"PNML.labeled_places","text":"labeled_places(net::PnmlNet)\n\nReturn Vector of placeid=>markingvalue.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.labels","page":"Docstrings","title":"PNML.labels","text":"labels(x) -> Iterateable\nlabels(x, tag::Union{Symbol, String, SubString{String}) -> Iterateable\n\nReturn iterator of labels attached to x.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.make_net","page":"Docstrings","title":"PNML.make_net","text":"Create empty net with builtins installed for use in test scaffolding.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.mcontains-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{PNML.PnmlMultiset{T, S, N}, PNML.PnmlMultiset{T, S, N}}} where {T, S<:AbstractSortRef, N<:AbstractPnmlNet}","page":"Docstrings","title":"PNML.mcontains","text":"mcontains(a::PnmlMultiset, b::PnmlMultiset) -> Bool\n\nForwarded to Multiset.issubset(multiset(b), multiset(a)).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.multiplicity-Tuple{PNML.PnmlMultiset, Any}","page":"Docstrings","title":"PNML.multiplicity","text":"multiplicity(ms::PnmlMultiset, x) -> Integer\nmultiplicity(ms::Number, x) -> Number\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.multiset-Tuple{PNML.PnmlMultiset}","page":"Docstrings","title":"PNML.multiset","text":"multiset(ms::PnmlMultiset) -> Multiset\n\nAccess wrapped multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.multisetsort-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.multisetsort","text":"Lookup multisetsort with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.multisetsort-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.multisetsort","text":"Lookup multisetsort with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.multisetsorts-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.multisetsorts","text":"Return dictionary of MultisetSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.multisetsorts-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.multisetsorts","text":"Return dictionary of MultisetSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.name","page":"Docstrings","title":"PNML.name","text":"name(x) -> String\n\nReturn name String. Default to empty string.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.name-Tuple{Any}","page":"Docstrings","title":"PNML.name","text":"name(x) -> String\n\nIf x has a namelabel,return its text, else return any name field. Default to string()\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedop-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.namedop","text":"Lookup namedop with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedop-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.namedop","text":"Lookup namedop with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedoperators-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.namedoperators","text":"Return dictionary of NamedOperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedoperators-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.namedoperators","text":"Return dictionary of NamedOperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedsort-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.namedsort","text":"Lookup namedsort with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedsort-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.namedsort","text":"Lookup namedsort with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedsorts-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.namedsorts","text":"Return dictionary of NamedSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedsorts-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.namedsorts","text":"Return dictionary of NamedSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.netdata","page":"Docstrings","title":"PNML.netdata","text":"netdata(x) -> PnmlNetData\n\nAccess PnmlNet-level data structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.nets-Tuple{PnmlModel}","page":"Docstrings","title":"PNML.nets","text":"nets(\n    model::PnmlModel\n) -> Base.ValueIterator{Dict{Symbol, Any}}\n\n\nReturn all nets of model.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.nettype","page":"Docstrings","title":"PNML.nettype","text":"Return the PnmlType subtype representing the flavor (or pntd) of this kind of Petri Net Graph.\n\nSee also pnmltype\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.null_function-Tuple{Any}","page":"Docstrings","title":"PNML.null_function","text":"Dummy function\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.number_value-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T<:Number","page":"Docstrings","title":"PNML.number_value","text":"number_value(::Type{T}, s) -> T\n\nParse string as a type T <: Number.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.operator-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.operator","text":"Lookup operator with id in DeclDict.::Symbol May be namedop, feconstant, etc\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.operator-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.operator","text":"operator(dd::DeclDict, id::Symbol) -> AbstractOperator\n\nReturn operator TermInterface expression for id.     toexpr(::AbstractOpExpr, varsub, ddict) = :(useroperator(ddict, REFID)(varsub))\n\nOperator Declarations include: :namedoperator, :feconstant, :partitionelement, :arbitraryoperator with types NamedOperator, FEConstant, PartitionElement, ArbitraryOperator. These define operators of different types that are placed into separate dictionaries.\n\n#! AbstractDeclarations and AbstractTerms are \"parallel\" semi-overlapping hierarchies #! in the UML, with AbstractTerms divided into AbstractOperators and AbstractVariables.\n\n#! AbstractTerms overlap with OperatorDeclaration and VariableDeclaration . #! AbstractSorts overlap with SortDeclaration.\n\n#! Consider OperatorDeclaration, SortDeclaration to be generators of concrete subtypes of #! AbstractOperator, AbstractSort. #! Without multiple inheritance, this cannot be expressed in a Julia type hiearchy.\n\n#! What the 'parse_*' of these <declaration> XML elements produce is #! a concrete AbstractOperator, AbstractSort.\n\n#! VariableDeclaration and Variable are not hiearchies. #! A Varaible is a reference to a VariableDeclaration, #! The variable declaration is a id, name, sort triplet. #! Where the sort is a SortRef or a sort declaration.\n\nuseroperator(REFID) is used to locate the operator definition, when it is found in feconstants(), is a callable returning a FEConstant literal.\n\n`toexpr(::FEConstantEx, varsub, ddict) = :(useroperator(ddict, REFID)(varsub))`\n\nThe FEConstant operators defined by the declaration do not have a distinct type name in the standard. Note that a FEConstant's value in the standard is its identity. We could use objectid(::FEConstant), REFID or name for output value. Output sort of op is FEConstant.\n\nOther OperatorDeclaration dictionarys also hold TermInterface expressions accessed by\n\n`toexpr(::PnmlExpr, varsub, ddict) = :(useroperator(ddict, REFID)(varsub))`\n\nwhere PnmlExpr is the TermInterface to match OperatorDeclaration. With output sort to match OperatorDeclaration .\n\n#TODO named operator input variables and their sorts\n\n#TODO partition element\n\n#TODO arbitrary opearator\n\n#TODO built-in operators\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.operators-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.operators","text":"operators(net::AbstractPnmlNet)-> Iterator\n\nIterate over each operator in the operator subset of declaration dictionaries .\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.operators-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.operators","text":"operators(dd::DeclDict)-> Iterator\n\nIterate over each operator in the operator subset of declaration dictionaries .\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.output_matrix","page":"Docstrings","title":"PNML.output_matrix","text":"output_matrix(petrinet::AbstractPetriNet) -> Matrix{value_type(Inscription, ::PnmlType)}\noutput_matrix(petrinet::PnmlNet) -> Matrix{value_type(Inscription, ::PnmlType)}\n\nCreate and return a matrix ntransitions x nplaces.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.pages","page":"Docstrings","title":"PNML.pages","text":"pages(net::PnmlLabel|page::Page) -> iterator\n\nReturn iterator of pages directly owned by that object.\n\nSee allpages for an iterator over all pages in the PNML network model. When there is only one page in the net, or all pages are owned by the 'net' itself, 'allpages' and 'pages` behave the same.\n\nMaintains order (insertion order).\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.pages-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.pages","text":"Iterator of Pages directly owned by net.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.partitionop-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.partitionop","text":"Lookup partitionop with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.partitionop-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.partitionop","text":"Lookup partitionop with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.partitionops-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.partitionops","text":"Return dictionary of partitionops (PartitionElement)\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.partitionops-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.partitionops","text":"Return dictionary of partitionops (PartitionElement)\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.partitionsort-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.partitionsort","text":"Lookup partitionsort with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.partitionsort-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.partitionsort","text":"Lookup partitionsort with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.partitionsorts-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.partitionsorts","text":"Return dictionary of PartitionSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.partitionsorts-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.partitionsorts","text":"Return dictionary of PartitionSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.pid","page":"Docstrings","title":"PNML.pid","text":"pid(x) -> Symbol\n\nReturn pnml id symbol of x. An id's value is unique in the XML model of PNML. REFID is used for refrences to pnml ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.place","page":"Docstrings","title":"PNML.place","text":"Return the place with id.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.place_idset","page":"Docstrings","title":"PNML.place_idset","text":"Return iterator of all place IDs.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.places","page":"Docstrings","title":"PNML.places","text":"Return iterator of all places.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.pnml_hl_operator-Tuple{Symbol}","page":"Docstrings","title":"PNML.pnml_hl_operator","text":"pnml_hl_operator(tag::Symbol) -> Callable(::Vector{AbstractTerm})\n\nReturn callable with a single argument, a vector of inputs.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.pnml_hl_outsort-Tuple{Symbol}","page":"Docstrings","title":"PNML.pnml_hl_outsort","text":"pnml_hl_outsort(tag::Symbol; insorts::Vector{UserSortRef}) -> AbstractSortRef\n\nReturn sort that operator tag returns.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.pnmlmultiset","page":"Docstrings","title":"PNML.pnmlmultiset","text":"pnmlmultiset(basis::AbstractSortRef, x, multi::Int=1; ddict) -> PnmlMultiset\npnmlmultiset(basis::AbstractSortRef, x::Multisets.Multiset; ddict) -> PnmlMultiset\npnmlmultiset(basis::AbstractSortRef; ddict) -> PnmlMultiset\n\nConstructs a PnmlMultiset containing a multiset and a sort from either\n\na sortref, one element and a multiplicity, default = 1, denoted \"1'x\",\na sortref and Multiset\nor just a sortref (not a multisetsort), uses all sortelements, each with multiplicity 1.\n\nAre mapping to Multisets.jl implementation: Create empty Multiset{T}() then fill.   If we have an element we can use typeof(x) to deduce T.   If we have a basis sort definition we use eltype(basis) to deduce T.\n\nUsages\n\n⟨all⟩ wants all sortelements\ndefault marking, inscription want one element or zero elements (elements can be PnmlTuples)\n\nwe always find a sort to use, And use dummy elements for their typeof for empty multisets.\n\nExpect to be called from a @matchable Terminterface, thusly:\n\neval(toexpr(Bag(basis, x, multi, ddict), variable_substitutions))\neval(toexpr(Bag(basis), ddict), variable_substitutions))\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.post_flatten_verify","page":"Docstrings","title":"PNML.post_flatten_verify","text":"Verify a PnmlNet after it has been flattened or is otherwise expected to be a single-page net.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.postset-Tuple{PnmlNet, Symbol}","page":"Docstrings","title":"PNML.postset","text":"postset(net, id) -> Iterator\n\nIterate ids of output (arc's target) for source transition or place id.\n\nSee PNet.out_inscriptions and PNet.transition_function`).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.preset-Tuple{PnmlNet, Symbol}","page":"Docstrings","title":"PNML.preset","text":"preset(net, id) -> Iterator\n\nIterate ids of input (arc's source) for output transition or place id.\n\nSee PNet.in_inscriptions and PNet.transition_function.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.productsort-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.productsort","text":"Lookup productsort with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.productsort-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.productsort","text":"Lookup productsort with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.productsorts-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.productsorts","text":"Return dictionary of ProductSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.productsorts-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.productsorts","text":"Return dictionary of ProductSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.rates","page":"Docstrings","title":"PNML.rates","text":"rates(net::PnmlNet) -> [id(transition) => rate_value(transition)]\n\nReturn a vector of transitionid=>ratevalue.\n\nWe allow all PNML nets to be stochastic Petri nets. See rate_value.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.refid","page":"Docstrings","title":"PNML.refid","text":"refid(x) -> REFID\n\nReturn reference id symbol. Multiple objects may hold the same refid value.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.refplace","page":"Docstrings","title":"PNML.refplace","text":"Return reference place matching id.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.refplace_idset","page":"Docstrings","title":"PNML.refplace_idset","text":"refplace_idset(x) -> OrderedSet{Symbol}\n\nReturn reference place pnml ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.refplaces","page":"Docstrings","title":"PNML.refplaces","text":"Return vector of all reference places.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.reftransition","page":"Docstrings","title":"PNML.reftransition","text":"Return reference transition matching id.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.reftransition_idset","page":"Docstrings","title":"PNML.reftransition_idset","text":"reftransition_idset(x) -> OrderedSet{Symbol}\n\nReturn reference transition pnml ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.reftransitions","page":"Docstrings","title":"PNML.reftransitions","text":"Return vector of all reference transitions.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.registry_of-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.registry_of","text":"Return IDRegistry of a PnmlNet.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.save_config!-Tuple{PNML.PnmlConfig}","page":"Docstrings","title":"PNML.save_config!","text":"save_config!(config::PnmlConfig)\n\nSave a configuration to your LocalPreferences.toml file using Preferences.jl. The saved preferences will be automatically loaded next time you do using PNML\n\nExamples\n\njulia> using PNML\n\njulia> PNML.CONFIG[].verbose = true;\n\njulia> PNML.CONFIG[].warn_on_unclaimed = true;     # Customize some defaults\n\njulia> PNML.save_config!(PNML.CONFIG[]); # Will be automatically read next time you `using PNML`\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.sortdefinition","page":"Docstrings","title":"PNML.sortdefinition","text":"sortdefinition(::NamedSort) -> Sort\n\nReturn concrete sort attached to a sort declaration object.\n\nDictionaries in a network-level DeclDict hold, among other things, NamedSort, ArbitrarySort and PartitionSort declarations. These declarations add an ID and name to a concrete sort, with the ID symbol used as the dictionary key.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.sortelements","page":"Docstrings","title":"PNML.sortelements","text":"sortelements(x, net) -> Iterator\n\nReturn iterator over elements of the sort of x in net.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.sortelements-Tuple{PNML.PnmlMultiset, AbstractPnmlNet}","page":"Docstrings","title":"PNML.sortelements","text":"sortelements(ms::PnmlMultiset, net::AbstractPnmlNet) -> iterator\n\nIterates over elements of the basis sort. May not be finite sort!\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.sortof","page":"Docstrings","title":"PNML.sortof","text":"sortof(x[, net]) -> AbstractSort\n\nReturn the sort of an object or type.\n\nOften implemented as sortdefinition(namedsort(net, sortref(x))). Default implementation is identity.\n\nWe provide a sort for some Julia types: Integer, Int64, Float64. Used for PTNet.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.sortref","page":"Docstrings","title":"PNML.sortref","text":"sortref(x) -> AbstractSortRef\n\nReturn a REFID wrapped in a AbstractSortRef.\n\nThings that have a sortref include: Place, Arc, Inscription, Marking, MultisetSort,  SortType, NumberConstant, Int64, Integer, Float64, FEConstant, FiniteIntRangeConstant, DotConstant, BooleanConstant, PnmlMultiset, Operator, Variable,\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.source-Tuple{Arc}","page":"Docstrings","title":"PNML.source","text":"source(arc) -> Symbol\n\nReturn identity symbol of source of arc.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.src_arcs","page":"Docstrings","title":"PNML.src_arcs","text":"Return arcs that have a source of transition id.\n\nSee also all_arcs, tgt_arcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.tag","page":"Docstrings","title":"PNML.tag","text":"tag(x) -> Symbol\n\nReturn tag symbol. Multiple objects may hold the same tag value. Often used to refer to an XML tag.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.target-Tuple{Arc}","page":"Docstrings","title":"PNML.target","text":"target(arc) -> Symbol\n\nReturn identity symbol of target of arc.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.term","page":"Docstrings","title":"PNML.term","text":"term(x)\n\nReturn 'PnmlExpr` term of x.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.text_content","page":"Docstrings","title":"PNML.text_content","text":"Find first :text and return its :content as string.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.tgt_arcs","page":"Docstrings","title":"PNML.tgt_arcs","text":"Return arcs that have a target of transition id.\n\nSee also all_arcs, src_arcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.transition","page":"Docstrings","title":"PNML.transition","text":"\n\n\n\n","category":"function"},{"location":"library/#PNML.transition_idset","page":"Docstrings","title":"PNML.transition_idset","text":"\n\n\n\n","category":"function"},{"location":"library/#PNML.transitions","page":"Docstrings","title":"PNML.transitions","text":"Return iterator of all transitions.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.unwrap_pmset-Tuple{Any}","page":"Docstrings","title":"PNML.unwrap_pmset","text":"unwrap_pmset(mark) -> Multiset\n\nIf marking wraps a PnmlMultiset, extract a singleton.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.useroperator-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.useroperator","text":"Lookup useroperator with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.useroperator-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.useroperator","text":"Lookup useroperator with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.useroperators-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.useroperators","text":"Return dictionary of UserOperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.useroperators-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.useroperators","text":"Return dictionary of UserOperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.value","page":"Docstrings","title":"PNML.value","text":"value(x)\n\nReturn value of x. Can be a wrapped value or a derived value. May return an Expr that returns the value when eval'ed.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.value_type","page":"Docstrings","title":"PNML.value_type","text":"value_type(::Type{<AbstractLabel}, ::PnmlType) -> Type\n\nReturn the Type of a label's value.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.variabledecl-Tuple{AbstractPnmlNet, Symbol}","page":"Docstrings","title":"PNML.variabledecl","text":"Lookup variable with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.variabledecl-Tuple{PNML.DeclDict, Symbol}","page":"Docstrings","title":"PNML.variabledecl","text":"Lookup variable with id in DeclDict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.variabledecls-Tuple{AbstractPnmlNet}","page":"Docstrings","title":"PNML.variabledecls","text":"Return dictionary of VariableDecl\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.variabledecls-Tuple{PNML.DeclDict}","page":"Docstrings","title":"PNML.variabledecls","text":"Return dictionary of VariableDecl\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.varsubs","page":"Docstrings","title":"PNML.varsubs","text":"varsubs(transition) -> Vector{NamedTuple}\n\nAccess the variable substitutions of a transition.\n\nVariable substitutions depend on the current marking. Cache value in transition field as part of enabling rule phase of a Petri net lifecycle.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.verify!","page":"Docstrings","title":"PNML.verify!","text":"verify!(errors::Vector{String}, x, verbose::Bool, net::AbstractPnmlNet)\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.verify-Tuple{PNML.DeclDict, Bool, AbstractPnmlNet}","page":"Docstrings","title":"PNML.verify","text":"verify(dd::DeclDict, verbose::Bool, net::AbstractPnmlNet) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.verify-Tuple{PnmlNet, Bool}","page":"Docstrings","title":"PNML.verify","text":"Error if any diagnostic messages are collected. Especially intended to detect semantc error.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.verify_ids!-Tuple{Any, AbstractString, Any, AbstractPnmlNet}","page":"Docstrings","title":"PNML.verify_ids!","text":"verify_ids!(errors, str, iterable, net::AbstractPnmlNet) -> Vector{String}\n\nIterate over iterable testing that pid is registered in net. str used in message appended to errors vector of strings.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.version","page":"Docstrings","title":"PNML.version","text":"\"Version of tool for this tool specific information element and its parser.\"\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.vertex_codes-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.vertex_codes","text":"pnml id symbol mapped to graph vertex code.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.vertex_data!-Tuple{Dict{Symbol, Tuple{Int64, Union{Place, Transition}}}, PnmlNet, Any}","page":"Docstrings","title":"PNML.vertex_data!","text":"Fill dictionary where keys are pnml ids, values are tuples of vertex code, place or transition.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.vertex_labels-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.vertex_labels","text":"graph vertex code mapped to pnml id symbol.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.zero_marking-Tuple{Place}","page":"Docstrings","title":"PNML.zero_marking","text":"Return zero-valued object with same basis and eltype as place's marking.\n\nUsed in enabling and firing rules to deduce type of Arc's adjacent_place.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlTypes","page":"Docstrings","title":"PNML.PnmlTypes","text":"Petri Net Type Definition (pntd) URI mapped to PnmlType subtype singleton.\n\n\n\n\n\n","category":"module"},{"location":"library/#PNML.PnmlTypes.pnmltype_map","page":"Docstrings","title":"PNML.PnmlTypes.pnmltype_map","text":"The key Symbols are the supported kinds of Petri Nets. Maps to singletons.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.PnmlTypes.pntd_map","page":"Docstrings","title":"PNML.PnmlTypes.pntd_map","text":"Map from Petri Net Type Definition (pntd) URI to Symbol. Allows multiple strings to map to the same pntd.\n\nThere is a companion map pnmltype_map that takes the symbol to a type object.\n\nThe URI is a string and may be the full URL of a pntd schema, just the schema file name, or a placeholder for a future schema.\n\nFor readability, the 'pntd symbol' should match the name used in the URI with inconvinient characters removed or replaced. For example, '-' is replaced by '_'.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.PnmlTypes.AbstractContinuousNet","page":"Docstrings","title":"PNML.PnmlTypes.AbstractContinuousNet","text":"abstract type AbstractContinuousNet <: PNML.PnmlTypes.PnmlType\n\nUses floating point numbers for markings, inscriptions. Most of the functionality is shared with AbstractPnmlCore. This seperates the\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.AbstractHLCore","page":"Docstrings","title":"PNML.PnmlTypes.AbstractHLCore","text":"abstract type AbstractHLCore <: PNML.PnmlTypes.PnmlType\n\nBase of High Level Petri Net pntds which add large extensions to PNML core. hlinitialMarking, hlinscription, and defined label structures.\n\nSee PnmlTypes.HLCoreNet, PnmlTypes.SymmetricNet, PnmlTypes.PT_HLPNG and others.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.AbstractPnmlCore","page":"Docstrings","title":"PNML.PnmlTypes.AbstractPnmlCore","text":"abstract type AbstractPnmlCore <: PNML.PnmlTypes.PnmlType\n\nBase of token/integer-based Petri Net pntds.\n\nSee PnmlCoreNet, PTNet and others.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.ContinuousNet","page":"Docstrings","title":"PNML.PnmlTypes.ContinuousNet","text":"struct ContinuousNet <: PNML.PnmlTypes.AbstractContinuousNet\n\nTODO: Continuous Petri Net\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.HLCoreNet","page":"Docstrings","title":"PNML.PnmlTypes.HLCoreNet","text":"struct HLCoreNet <: PNML.PnmlTypes.AbstractHLCore\n\nHLCoreNet can be used for generic high-level nets. We try to implement and test all function at `PnmlCoreNet level, but expect to find use for a concrete type at this level for testing high-level extensions.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.HLPNG","page":"Docstrings","title":"PNML.PnmlTypes.HLPNG","text":"struct HLPNG <: PNML.PnmlTypes.AbstractHLCore\n\nHigh-Level Petri Net Graphs (HLPNGs) are the most intricate High-Level Petri Net schema. It extends SymmetricNet, including with\n\ndeclarations for sorts and functions (ArbitraryDeclarations)\nsorts for Integer, String, and List\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.PTNet","page":"Docstrings","title":"PNML.PnmlTypes.PTNet","text":"struct PTNet <: PNML.PnmlTypes.AbstractPnmlCore\n\nPlace-Transition Petri Nets add small extensions to core PNML. Integer-valued initialMarking and inscription.\n\nThe grammer file is ptnet.pnml so we name it PTNet. Note that 'PT' is often the prefix for XML tags specialized for this net type.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.PT_HLPNG","page":"Docstrings","title":"PNML.PnmlTypes.PT_HLPNG","text":"struct PT_HLPNG <: PNML.PnmlTypes.AbstractHLCore\n\nPlace-Transition Net in HLCoreNet notation.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.PnmlCoreNet","page":"Docstrings","title":"PNML.PnmlTypes.PnmlCoreNet","text":"struct PnmlCoreNet <: PNML.PnmlTypes.AbstractPnmlCore\n\nThe most minimal concrete Petri Net.\n\nUsed to implement and test the core PNML support. Covers the complete graph infrastructure including labels attached to nodes and arcs.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.PnmlType","page":"Docstrings","title":"PNML.PnmlTypes.PnmlType","text":"abstract type PnmlType\n\nAbstract root of a dispatch type based on Petri Net Type Definitions (pntd).\n\nEach Petri Net Markup Language (PNML) network element will have a single pntd URI as a required 'type' XML attribute. That URI should refer to a RelaxNG schema defining the syntax and semantics of the XML model.\n\nSelected abbreviations, URIs that do not resolve to a valid schema file, are also allowed.\n\nRefer to pntd_symbol and pnmltype for how to get from the URI to a singleton.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.SymmetricNet","page":"Docstrings","title":"PNML.PnmlTypes.SymmetricNet","text":"struct SymmetricNet <: PNML.PnmlTypes.AbstractHLCore\n\nSymmetric Petri Net is the best-worked use case in the primer and ISO 15909 standard part 2.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypes.add_nettype!-Tuple{AbstractDict, Symbol, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.PnmlTypes.add_nettype!","text":"add_nettype!(\n    dict::AbstractDict,\n    s::Symbol,\n    pntd::PNML.PnmlTypes.PnmlType\n) -> AbstractDict\n\n\nAdd or replace mapping from Symbol s to PnmlType singleton pntd.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlTypes.all_nettypes-Tuple{Any}","page":"Docstrings","title":"PNML.PnmlTypes.all_nettypes","text":"Return iterator over PnmlType singletons filtered by the prediciate p.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlTypes.all_nettypes-Tuple{}","page":"Docstrings","title":"PNML.PnmlTypes.all_nettypes","text":"Return iterator over PnmlType singletons.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlTypes.iscontinuous","page":"Docstrings","title":"PNML.PnmlTypes.iscontinuous","text":"Tokens represented by floating point.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.PnmlTypes.isdiscrete","page":"Docstrings","title":"PNML.PnmlTypes.isdiscrete","text":"Tokens represented by integers.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.PnmlTypes.ishighlevel","page":"Docstrings","title":"PNML.PnmlTypes.ishighlevel","text":"Tokens represented by multiset (aka bag).\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.PnmlTypes.pnmltype","page":"Docstrings","title":"PNML.PnmlTypes.pnmltype","text":"pnmltype(pntd::PnmlType) -> pnml\npnmltype(uri::AbstractString) -> PnmlType\npnmltype(s::Symbol; pnmltype_map=pnmltype_map) -> PnmlType\n\nMap either a text string or a symbol to a dispatch type object.\n\nWhile that string may be a URI for a pntd, we treat it as a simple string without parsing. The PnmlTypes.pnmltype_map and PnmlTypes.pntd_map are both assumed to be correct here.\n\nUnknown or empty uri will map to symbol :pnmlcore. Unknown symbol throws a DomainError exception.\n\nExamples\n\njldoctest; setup=:(using PNML; using PNML: pnmltype, pntd_symbol)\njulia> pnmltype(PnmlCoreNet())\nPnmlCoreNet()\n\njulia> pnmltype(\"nonstandard\")\nPnmlCoreNet()\n\njulia> pnmltype(:symmetric)\nSymmetricNet()\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.PnmlTypes.pntd_symbol-Tuple{AbstractString}","page":"Docstrings","title":"PNML.PnmlTypes.pntd_symbol","text":"pntd_symbol(s::AbstractString) -> Symbol\n\n\nMap string s to a pntd symbol using pntd_map. Any unknown s is mapped to :pnmlcore. Returned symbol is suitable for pnmltype to use to index into pnmltype_map.\n\nExamples\n\njulia> PNML.PnmlTypes.pntd_symbol(\"foo\")\n:pnmlcore\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.IDRegistrys","page":"Docstrings","title":"PNML.IDRegistrys","text":"Petri Net Markup Language identifier registry.\n\n\n\n\n\n","category":"module"},{"location":"library/#PNML.IDRegistrys.DuplicateIDException","page":"Docstrings","title":"PNML.IDRegistrys.DuplicateIDException","text":"struct DuplicateIDException <: Exception\n\nmsg::String\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.IDRegistrys.IDRegistry","page":"Docstrings","title":"PNML.IDRegistrys.IDRegistry","text":"Holds a set of PNML ID symbols and, optionally, a lock to allow safe reentrancy.\n\nstruct IDRegistry\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.IDRegistrys.isregistered-Tuple{PNML.IDRegistrys.IDRegistry, Symbol}","page":"Docstrings","title":"PNML.IDRegistrys.isregistered","text":"isregistered(\n    registry::PNML.IDRegistrys.IDRegistry,\n    id::Symbol\n) -> Bool\n\n\nReturn true if id is registered in registry.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.IDRegistrys.register_id!-Tuple{PNML.IDRegistrys.IDRegistry, Symbol}","page":"Docstrings","title":"PNML.IDRegistrys.register_id!","text":"register_id!(\n    registry::PNML.IDRegistrys.IDRegistry,\n    id::Symbol\n) -> Symbol\n\n\nRegister id symbol and return the symbol.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.IDRegistrys.reset_reg!-Tuple{PNML.IDRegistrys.IDRegistry}","page":"Docstrings","title":"PNML.IDRegistrys.reset_reg!","text":"reset_reg!(\n    registry::PNML.IDRegistrys.IDRegistry\n) -> PNML.IDRegistrys.IDRegistry\n\n\nEmpty the set of id symbols. Use case is tests.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Sorts","page":"Docstrings","title":"PNML.Sorts","text":"Part of the high-level pnml many-sorted algebra. See PNML.Labels.SortType.\n\nNamedSort is a SortDecl (SortDeclaration) that gives a name and id to a Sort.\n\nThe pnml standard sometimes uses overlapping language. And explains little, expecting one to be knowledgeable about colored petri nets.\n\nFrom the 'primer': built-in sorts of Symmetric Nets are the following: booleans, integerrange, finite enumerations, cyclic enumerations, products, dots and partitions.\n\nAnd more sorts for HLPNG: integer, strings, list\n\nWith additions we made: real.\n\nOh, also ArbitrarySorts.\n\n#! XXX The eltype is expected to be a concrete subtype of Number such as Int, Bool or Float64.\n\nExtras\n\nNotes:\n\nNamedSort is a Declarations.SortDeclaration\nPNML.PnmlTypes.HLPNG adds PNML.Declarations.ArbitrarySort.\nPartitionSort is called \"Partition\" in the standard.\nSortRef holds the id symbol of a concrete sort.\nWe use sorts even for non-high-level nets.\nExpect eltype(::AbstractSort) to return a concrete subtype of Number.\n\n\n\n\n\n","category":"module"},{"location":"library/#PNML.Sorts.BoolSort","page":"Docstrings","title":"PNML.Sorts.BoolSort","text":"Built-in sort whose eltype is Bool\n\nOperators: and, or, not, imply\n\nFunctions: equality, inequality\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.CyclicEnumerationSort","page":"Docstrings","title":"PNML.Sorts.CyclicEnumerationSort","text":"struct CyclicEnumerationSort <: PNML.Sorts.EnumerationSort\n\nOrderedcollection of REFIDs into feconstant(net).\n\nOperations differ between EnumerationSorts. All wrap a tuple of symbols and metadata, allowing attachment of Partition/PartitionElement.\n\nSee ISO/IEC 15909-2:2011/Cor.1:2013(E) defect 11 power or nth successor/predecessor\n\nMCC2023/SharedMemory-COL-100000 has cyclic enumeration with 100000 <feconstant> elements.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.DotSort","page":"Docstrings","title":"PNML.Sorts.DotSort","text":"DotSort\n\nBuilt-in sort whose eltype is Bool, the smallest Integer subtype that can represent one.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.EnumerationSort","page":"Docstrings","title":"PNML.Sorts.EnumerationSort","text":"abstract type EnumerationSort <: PNML.AbstractSort\n\nSee FiniteEnumerationSort, PNML.Sorts.CyclicEnumerationSort. Both hold an ordered collection of PNML.FEConstant REFIDs.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.FiniteEnumerationSort","page":"Docstrings","title":"PNML.Sorts.FiniteEnumerationSort","text":"FiniteEnumerationSort(ntuple) -> FiniteEnumerationSort{M}\n\nWraps a collection of FEConstant REFIDs. Usage: feconstant(net)[refid].\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.FiniteIntRangeSort","page":"Docstrings","title":"PNML.Sorts.FiniteIntRangeSort","text":"struct FiniteIntRangeSort{T<:Integer} <: PNML.AbstractSort\n\nFiniteIntRangeSort(start::T, stop::T) where {T<:Integer}\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.IntegerSort","page":"Docstrings","title":"PNML.Sorts.IntegerSort","text":"Built-in sort whose eltype is Int\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.ListSort","page":"Docstrings","title":"PNML.Sorts.ListSort","text":"struct ListSort{T<:AbstractSortRef} <: PNML.AbstractSort\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.MultisetSort","page":"Docstrings","title":"PNML.Sorts.MultisetSort","text":"struct MultisetSort{S<:AbstractSortRef} <: PNML.AbstractSort\n\nWrap a SortRef. Warning: do not cause recursive multiset Sorts.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.NaturalSort","page":"Docstrings","title":"PNML.Sorts.NaturalSort","text":"Built-in sort whose eltype is Int\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.NullSort","page":"Docstrings","title":"PNML.Sorts.NullSort","text":"Built-in sort whose eltype is Nothing\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.PositiveSort","page":"Docstrings","title":"PNML.Sorts.PositiveSort","text":"Built-in sort whose eltype is Int\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.ProductSort","page":"Docstrings","title":"PNML.Sorts.ProductSort","text":"struct ProductSort{N, P<:AbstractPnmlNet} <: PNML.AbstractSort\n\nAn ordered collection of sorts. The elements of the sort are tuples of elements of each sort.\n\nISO 15909-1:2019 Concept 14 (color domain) finite cartesian product of color classes. Where sorts are the syntax for color classes and ProductSort is the color domain.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.RealSort","page":"Docstrings","title":"PNML.Sorts.RealSort","text":"Built-in sort whose eltype is Float64\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.StringSort","page":"Docstrings","title":"PNML.Sorts.StringSort","text":"struct StringSort <: PNML.AbstractSort\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.builtin_sorts-Tuple{}","page":"Docstrings","title":"PNML.Sorts.builtin_sorts","text":"Set of sort IDs that are considered builtin.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Sorts.isbuiltinsort-Tuple{Symbol}","page":"Docstrings","title":"PNML.Sorts.isbuiltinsort","text":"isbuiltinsort(::Symbol) -> Bool\n\nIs tag in builtin_sorts().\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Sorts.make_sortref","page":"Docstrings","title":"PNML.Sorts.make_sortref","text":"make_sortref(net, dict, sort, seed, id, name) ->  AbstractSortRef`\n\ndict is a method/callable that returns an AbstractDict a DeclDict attached to net.\nsort ia a concrete sort that is to be in dict.\nseed is passed to gensym if id is nothing and no sort is already in dict.\nid is a Symbol and the string name are nothing and \"\" unless there is a wrapper providing such information,\n\nUses fill_sort_tag!.\n\nReturn concrete AbstractSortRef matching dict, wrapping id.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Sorts.refs-Tuple{PNML.Sorts.EnumerationSort}","page":"Docstrings","title":"PNML.Sorts.refs","text":"refs(sort::EnumerationSort) -> Vector{REFID}\n\nReturn Vector of FEConstant REFIDs.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Sorts.sorts-Tuple{PNML.Sorts.ProductSort, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Sorts.sorts","text":"sorts(ps::ProductSort, ::AbstractPnmlNet) -> NTuple\n\nReturn iterator over SortRefs to sorts in the product.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.sortelements-Tuple{PNML.Sorts.BoolSort, AbstractPnmlNet}","page":"Docstrings","title":"PNML.sortelements","text":"Elements of boolean sort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.sortelements-Tuple{PNML.Sorts.EnumerationSort, AbstractPnmlNet}","page":"Docstrings","title":"PNML.sortelements","text":"sortelements(sort::EnumerationSort, ::AbstractPnmlNet) -> Iterator\n\nReturn iteratable ordered collection of keys into feconstant(net) dictionary.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.sortelements-Tuple{PNML.Sorts.FiniteIntRangeSort, AbstractPnmlNet}","page":"Docstrings","title":"PNML.sortelements","text":"Return iterator from start to stop, inclusive.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Declarations.AbstractDeclaration","page":"Docstrings","title":"PNML.Declarations.AbstractDeclaration","text":"abstract type AbstractDeclaration\n\nDeclarations define objects/names that are used for high-level terms in conditions, inscriptions, markings. The definitions are attached to PNML nets and/or pages using a PNML Label defined in a <declarations> tag.\n\nid\nname\nnet\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.ArbitraryOperator","page":"Docstrings","title":"PNML.Declarations.ArbitraryOperator","text":"struct ArbitraryOperator{N<:AbstractPnmlNet} <: PNML.Declarations.OperatorDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\ndeclaration::Symbol\nnet::AbstractPnmlNet\n\n...arbitrary sorts and operators do not come with a definition of the sort or operation;\n\nthey just introduce a new symbol.\n\nLike ArbitrarySort, does not have an associated algebra, not usable by SymmetricNet.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.ArbitrarySort","page":"Docstrings","title":"PNML.Declarations.ArbitrarySort","text":"struct ArbitrarySort{N<:AbstractPnmlNet} <: PNML.Declarations.SortDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\nnet::AbstractPnmlNet\n\nArbitrary sorts that can be used for constructing terms are reserved for/supported by HLPNG in the pnml standard.\n\n...arbitrary sorts and operators do not come with a definition of the sort or operation;\n\nthey just introduce a new symbol.\n\nLike ArbitraryOperator, does not have an associated algebra, not usable by SymmetricNet.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.NamedOperator","page":"Docstrings","title":"PNML.Declarations.NamedOperator","text":"struct NamedOperator{T, N<:AbstractPnmlNet} <: PNML.Declarations.OperatorDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\nparameter::Vector{PNML.Declarations.VariableDeclaration}\ndef::Any\nnet::AbstractPnmlNet\n\nSee UserOperator.\n\nVector of VariableDeclaration for parameters (ordered), and duck-typed AbstractTerm for its body.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.NamedSort","page":"Docstrings","title":"PNML.Declarations.NamedSort","text":"struct NamedSort{S<:PNML.AbstractSort, N<:AbstractPnmlNet} <: PNML.Declarations.SortDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\ndef::PNML.AbstractSort\nnet::AbstractPnmlNet\n\nDeclaration of a NamedSort gives an id and name to a concrete instance of a built-in AbstractSort. The sort defined in the XML file may be shared with other named sorts.\n\nSee MultisetSort, PartitionSort, PartitionSort. These are all Declaration subtypes in the UML2/RelaxNG parts of ISO 15909-2:2011 which has a strong Java bias. The text on the standard states they are also sort-like. We use a different type system.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.OperatorDeclaration","page":"Docstrings","title":"PNML.Declarations.OperatorDeclaration","text":"abstract type OperatorDeclaration <: PNML.AbstractSort\n\nNamedOperator. PNML.FEConstant, PartitionElement and ArbitraryOperator are all referenced by UserOperator.\n\nUserOperator wraps REFID used to access DeclDict.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.PartitionElement","page":"Docstrings","title":"PNML.Declarations.PartitionElement","text":"PartitionElement(id::Symbol, name, Vector{IDREF}, REFID)\n\nid::Symbol\nname::Union{SubString{String}, String}\nterms::Vector{Symbol}\npartition::Symbol\n\nEstablishes an equivalence class over a Declarations.PartitionSort's emumeration. See also FiniteEnumerationSort. Gives a name to an element of a partition. The element is an equivalence class.\n\nPartitionElement is different from FiniteEnumeration, CyclicEnumeration, FiniteIntRangeSort in that it holds UserOperators, not FEConstants. The UserOperator refers to the FEConstants of the sort over which the partition is defined. NB: FEConstants are 0-arity operators. UserOperator is how operation declarations are accessed.\n\nNB: The \"PartitionElementOf\" operator maps each element of the FiniteEnumeration (referenced by the partition) to the PartitionElement (of the partition) to which it belongs.\n\nPartitionElementOf(partition, feconstant) -> PartitionElement partitionelementof(partition, feconstant) -> PartitionElement\n\nPartitionElementOf is passed a REFID of the partition whose PartitionElement membership is being queried.\n\nEach PartitionElement contains a collection of REFIDs to UserOperators which refer to a finite sort's (FiniteEnumeration, CyclicEnumeration, FiniteIntRangeSort) FEConstant by REFID.\n\nTest for membership by iterating over each partition element, and over each term.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.PartitionSort","page":"Docstrings","title":"PNML.Declarations.PartitionSort","text":"struct PartitionSort{S<:AbstractSortRef, N<:AbstractPnmlNet} <: PNML.Declarations.SortDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\ndef::AbstractSortRef\nelements::Vector{PNML.Declarations.PartitionElement}\nnet::AbstractPnmlNet\n\nPartition sort declaration is a finite enumeration that is partitioned into sub-ranges of enumerations. Is the sort at the partition or the element level (1 sort or many sorts?)\n\nLike NamedSort, will add an id and name to a sort, may be accessed by UserSortRef indirection.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.SortDeclaration","page":"Docstrings","title":"PNML.Declarations.SortDeclaration","text":"abstract type SortDeclaration <: PNML.AbstractSort\n\nSee Declarations.NamedSort, Declarations.PartitionSort and [Declarations.ArbitrarySort] as concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.UnknownDeclaration","page":"Docstrings","title":"PNML.Declarations.UnknownDeclaration","text":"struct UnknownDeclaration{N<:AbstractPnmlNet} <: PNML.Declarations.AbstractDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\nnodename::Union{SubString{String}, String}\ncontent::PNML.AnyElement\nnet::AbstractPnmlNet\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.VariableDeclaration","page":"Docstrings","title":"PNML.Declarations.VariableDeclaration","text":"struct VariableDeclaration{S<:AbstractSortRef, N<:AbstractPnmlNet} <: PNML.Declarations.AbstractDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\nsort::AbstractSortRef\nnet::AbstractPnmlNet\n\nVariable declaration <variabledecl> adds a name string and sort to the id shared with <variable> terms in non-ground terms.\n\nEXAMPLE\n\nPNML.DeclDict\n\nPNML.variabledecls[id] = VariableDeclaration(id, \"human name\", sort)\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.contains","page":"Docstrings","title":"PNML.Declarations.contains","text":"Return Bool true if partition contains the FEConstant\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Declarations.element_ids-Tuple{PNML.Declarations.PartitionSort}","page":"Docstrings","title":"PNML.Declarations.element_ids","text":"Iterator over partition element REFIDs of a `PartitionSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Declarations.element_names-Tuple{PNML.Declarations.PartitionSort}","page":"Docstrings","title":"PNML.Declarations.element_names","text":"Iterator over partition element names\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.PnmlGraphics","page":"Docstrings","title":"PNML.Labels.PnmlGraphics","text":"PnmlGraphics holds CSS-like data. Can be attached to 'AbstractPnmlObject`s and\n\nAnnotation label parts of PnmlNets.\n\n\n\n\n\n","category":"module"},{"location":"library/#PNML.Labels.PnmlGraphics.Fill","page":"Docstrings","title":"PNML.Labels.PnmlGraphics.Fill","text":"Fill attributes as strings.\n\nstruct Fill\n\ncolor::String\nimage::String\ngradient_color::String\ngradient_rotation::String\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.PnmlGraphics.Font","page":"Docstrings","title":"PNML.Labels.PnmlGraphics.Font","text":"Font attributes as strings.\n\nstruct Font\n\nfamily::String\nstyle::String\nweight::String\nsize::String\nalign::String\nrotation::String\ndecoration::String\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.PnmlGraphics.Graphics","page":"Docstrings","title":"PNML.Labels.PnmlGraphics.Graphics","text":"PNML Graphics can be attached to 'AbstractPnmlObjects andAnnotation` label parts of Pnml models.\n\nstruct Graphics{T<:Float32}\n\ndimension::PNML.Coordinate\nfill::PNML.Labels.PnmlGraphics.Fill\nfont::PNML.Labels.PnmlGraphics.Font\nline::PNML.Labels.PnmlGraphics.Line\noffset::PNML.Coordinate\npositions::Vector{PNML.Coordinate}\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.PnmlGraphics.Line","page":"Docstrings","title":"PNML.Labels.PnmlGraphics.Line","text":"Line attributes as strings.\n\nstruct Line\n\ncolor::String\nshape::String\nstyle::String\nwidth::String\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.ArcType","page":"Docstrings","title":"PNML.Labels.ArcType","text":"struct ArcType{T<:AbstractArcEnum} <: PNML.Annotation\n\ntext::String\narctype::AbstractArcEnum\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\n\nArc type label.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Condition","page":"Docstrings","title":"PNML.Labels.Condition","text":"(c::Condition)(args) -> Bool\n\nUse args, a dictionary of variable substitutions into the expression to return a Bool.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Condition-2","page":"Docstrings","title":"PNML.Labels.Condition","text":"struct Condition{T<:PNML.Expressions.PnmlExpr, N<:AbstractPnmlNet} <: PNML.HLAnnotation\n\ntext::Union{Nothing, String}\nterm::PNML.Expressions.PnmlExpr\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nvars::Vector{Symbol}\nnet::AbstractPnmlNet\n\nLabel a Transition with an boolean expression used to determine when/if the transition fires.\n\nThere may be other things evaluating to boolean used to determine transition firing filters, including: priority labels, inhibitor arc, place capacity labels, time/delay labels. ```\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Declaration","page":"Docstrings","title":"PNML.Labels.Declaration","text":"struct Declaration <: PNML.Annotation\n\ntext::Union{Nothing, String}\nddict::PNML.DeclDict\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\n\nLabel of a <net> or <page> that holds zero or more declarations. The declarations are used to define parts of the many-sorted algebra used by High-Level Petri Nets.\n\nAll the declarations in the <structure> are placed into a single per-net dictionary collection ddict. The text, graphics, and toolspecinfos fields are expected to be nothing, but are present because, being labels, it is allowed.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.HLLabel","page":"Docstrings","title":"PNML.Labels.HLLabel","text":"struct HLLabel{PNTD} <: PNML.HLAnnotation\n\ntext::Union{Nothing, String}\nstructure::Union{Nothing, PNML.AnyElement}\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\n\nHigh-level pnml labels are expected to have <text> and <structure> elements. This concrete type is for \"unclaimed\" labels in a high-level petri net.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Inscription","page":"Docstrings","title":"PNML.Labels.Inscription","text":"struct Inscription{T<:PNML.Expressions.PnmlExpr, N<:AbstractPnmlNet} <: PNML.HLAnnotation\n\ntext::Union{Nothing, String}\nterm::PNML.Expressions.PnmlExpr\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nvars::Vector{Symbol}\nnet::AbstractPnmlNet\n\nLabels an Arc with a expression term .\n\nInscription(t::PnmlExpr)() is a functor evaluating the expression and returns a value of the eltype of sort of inscription.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Marking","page":"Docstrings","title":"PNML.Labels.Marking","text":"struct Marking{T<:PNML.Expressions.PnmlExpr, N<:AbstractPnmlNet} <: PNML.Annotation\n\nterm::PNML.Expressions.PnmlExpr\ntext::Union{Nothing, String}\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nnet::AbstractPnmlNet\n\nLabel of Place.\n\nIs a functor that returns the value. ```\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Marking-Tuple{}","page":"Docstrings","title":"PNML.Labels.Marking","text":"Evaluate Marking instance by evaluating term expression.\n\nPlace/Transition Nets (and ContinuousNet) use collective token identity (map to Number). High-level Nets (SymmetricNet, HLPNG) use individual token identity (colored petri nets).\n\nThere is a multi-sorted algebra definition mechanism defined for HL Nets. HL Net Marking values are a ground terms of this multi-sorted algebra.\n\nUsed to initialize a marking vector that will then be updated by firing a transition.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.Name","page":"Docstrings","title":"PNML.Labels.Name","text":"struct Name <: PNML.Annotation\n\ntext::String\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\n\nName is for display, possibly in a tool specific way.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.NupnTool","page":"Docstrings","title":"PNML.Labels.NupnTool","text":"struct NupnTool\n\nnplaces::Int64\nntransitions::Int64\nnarcs::Int64\nnunits::Int64\nroot::Symbol\nsafe::Bool\nunits::Vector{PNML.Labels.NupnUnit}\n\nNupnTool is <toolspecific> content. Will be attached to a ToolInfo. Wraps an AnyElement.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.PnmlLabel","page":"Docstrings","title":"PNML.Labels.PnmlLabel","text":"struct PnmlLabel{T, N<:AbstractPnmlNet} <: PNML.Annotation\n\ntag::Union{SubString{String}, String, Symbol}\nelements::Any\nnet::AbstractPnmlNet\n\nWrap a PNML Label as parsed by XMLDict. Use the XML tag as identifier.\n\nUsed for \"unclaimed\" labels that do not have, or we choose not to use, a dedicated parse method. Claimed labels will have a type/parser defined to make use of the structure defined by the pntd schema.\n\nSee also AnyElement which allows any well-formed XML, while PnmlLabel is restricted to PNML Labels.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Priority","page":"Docstrings","title":"PNML.Labels.Priority","text":"struct Priority{T<:PNML.Expressions.PnmlExpr, N<:AbstractPnmlNet} <: PNML.Annotation\n\ntext::Union{Nothing, String}\nterm::PNML.Expressions.PnmlExpr\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nnet::AbstractPnmlNet\n\nReal valued label. An expected use is as a static transition Priority. Expected XML: <priority> <text>0.3</text> </priority>.\n\nDynamic priority is a function with arguments of net marking and transition.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Rate","page":"Docstrings","title":"PNML.Labels.Rate","text":"struct Rate{T<:PNML.Expressions.PnmlExpr, N<:AbstractPnmlNet} <: PNML.Annotation\n\ntext::Union{Nothing, String}\nterm::PNML.Expressions.PnmlExpr\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nnet::AbstractPnmlNet\n\nReal valued label. An expected use is as a transition rate. Expected XML: <rate> <text>0.3</text> </rate>.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.SortType","page":"Docstrings","title":"PNML.Labels.SortType","text":"struct SortType{S<:AbstractSortRef, N<:AbstractPnmlNet} <: PNML.Annotation\n\ntext::Union{Nothing, String}\nsort_::AbstractSortRef\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nnet::AbstractPnmlNet\n\nA places's <type> label wraps a UserSortRef that holds a REFID to the sort of a place, hence use of sorttype. It is the type (or set) concept of the many-sorted algebra.\n\nFor high-level nets there will be a declaration section with a rich language of sorts using UserSortFRef, NamedSort, PartitionSort or ArbitrarySort defined in the xml input.\n\nFor other PnmlNet's they are used internally to allow common implementations.\n\ndefines the type by referring to some sort; by the fixed interpretation of built-in sorts,\n\nthis sort defines the type of the place.\n\nBy the fixed interpretation of sorts, this implicitly refers to a set, which is the type of that place.\n\n\"refers to set\" excludes multiset (as stated elsewhere in standard)\n\nthis is a sort, not a term, so no variables or operators.\n\nThe initial marking function M0 is defined by the label Marking of the places. ... this is a ground term of the corresponding multiset sort.\n\nGround terms have no variables and can be evaluated outside of a transition firing rule.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.TestTool","page":"Docstrings","title":"PNML.Labels.TestTool","text":"struct TestTool{T}\n\ninfo::PNML.AnyElement\n\nTestTool is <toolspecific> content. Will be attached to a ToolInfo. Wraps an AnyElement.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Time","page":"Docstrings","title":"PNML.Labels.Time","text":"struct Time{T<:PNML.Expressions.PnmlExpr, N<:AbstractPnmlNet} <: PNML.Annotation\n\ntext::Union{Nothing, String}\nterm::PNML.Expressions.PnmlExpr\ngraphics::Union{Nothing, PNML.Labels.PnmlGraphics.Graphics}\ntoolspecinfos::Union{Nothing, Vector{PNML.Labels.ToolInfo}}\nnet::AbstractPnmlNet\n\nReal valued label. An expected use is for a Time Petri net. Expected XML: <time> <text>0.3</text> </time>.\n\nDynamic time is a function with arguments of net marking and transition.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.TokenGraphics","page":"Docstrings","title":"PNML.Labels.TokenGraphics","text":"struct TokenGraphics\n\npositions::Vector{PNML.Coordinate}\n\nTokenGraphics is <toolspecific> content. Will be attached to a ToolInfo that also holds the tool name and version. Combines the <tokengraphics> and <tokenposition> elements.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.ToolInfo","page":"Docstrings","title":"PNML.Labels.ToolInfo","text":"struct ToolInfo{T, N<:AbstractPnmlNet}\n\ntoolname::String\nversion::String\ninfo::Any\nnet::AbstractPnmlNet\n\nA <toolspecific> tag holds well formed XML that is parsed into an AnyElement.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels._ci-Tuple{Any}","page":"Docstrings","title":"PNML.Labels._ci","text":"Map MathML constant string i to a Number. Supported: infty.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels._match","page":"Docstrings","title":"PNML.Labels._match","text":"_match(tx, namerex::Regex, versionrex::Regex) -> Bool\n\nReturn true if both toolname and version match. Default is any version. Applies to ToolInfo, ToolParser, and other objects with a name and version method.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Labels.def_sort_element-Tuple{PNML.Labels.SortType, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Labels.def_sort_element","text":"def_sort_element(x, net)\n\nReturn an arbitrary element of sort x. All sorts are expected to be iteratable and non-empty, so we return first. Uses include default inscription value and default initial marking value sorts.\n\nx can be anything with a sortelements(x, net) method that returns an iterator with length. See AbstractSort, SortType.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.default","page":"Docstrings","title":"PNML.Labels.default","text":"default(::Type{T<:AbstractLabel}, pntd::PnmlType, net::AbstractPnmlNet) -> T\n\nReturn a default instance of label T for pntd.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Labels.default-Tuple{Type{<:PNML.Labels.Marking}, PNML.PnmlTypes.PnmlType, PNML.Labels.SortType, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Labels.default","text":"default(\n    _::Type{<:PNML.Labels.Marking},\n    pntd::PNML.PnmlTypes.PnmlType,\n    placetype::PNML.Labels.SortType,\n    net::AbstractPnmlNet\n) -> PNML.Labels.Marking{T} where T<:(PNML.Expressions.Bag{S, _A, Int64} where {S<:AbstractSortRef, _A})\n\n\nReturn default marking value based on PnmlType. Has meaning of empty, as in zero. For high-level nets, the marking is an empty multiset whose basis matches placetype. Others have a marking that is a Number.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.default_typesort","page":"Docstrings","title":"PNML.Labels.default_typesort","text":"Return SortRef for default SortType of a PNTD.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Labels.delay_value-Tuple{Any}","page":"Docstrings","title":"PNML.Labels.delay_value","text":"delay_value(\n    t;\n    tag,\n    valtype,\n    content_parser,\n    default_value\n) -> Tuple{AbstractString, Float64, Union{Bool, Float64}}\n\n\nReturn delay label value as interval tuple: (\"closure-string\", left, right) Missing delay labels default to (\"closed\", 0.0, 0.0) a.k.a. zero.\n\nAll net types may have a delay value type. Expected label XML: see MathML. Only non-negative. static transition Supports\n\n(\"closed-open\", 0.0, ∞)  -> [0.0, ∞)\n(\"open-closed\", 2.0, 6.0 -> (2.0, 6.0]\n(\"open\", 2.0, 6.0)       -> (2.0, 6.0)\n(\"closed\", 2.0, 6.0)     -> [2.0, 6.0]\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.get_toolinfo-Tuple{Any, Any, Any}","page":"Docstrings","title":"PNML.Labels.get_toolinfo","text":"get_toolinfo(infos, toolname[, version]) -> Maybe{ToolInfo}\n\nCall get_toolinfos.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.get_toolinfos","page":"Docstrings","title":"PNML.Labels.get_toolinfos","text":"get_toolinfos(infos, toolname[, version]) -> Maybe{ToolInfo}\n\nReturn first toolinfo in iteratable collection infos having a matching toolname and version.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Labels.get_toolinfos-Tuple{Any, Regex, Regex}","page":"Docstrings","title":"PNML.Labels.get_toolinfos","text":"get_toolinfos(infos, toolname::Regex, version::Regex) -> Iterator\n\ninfos may be a ToolInfo or collection of ToolParser, both have  a name and version. Return iterator over infos matching toolname and version regular expressions.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.info-Tuple{PNML.Labels.ToolInfo}","page":"Docstrings","title":"PNML.Labels.info","text":"Content of a ToolInfo.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.label_value-Tuple{PNML.AbstractPnmlNode, Symbol, Any, Any}","page":"Docstrings","title":"PNML.Labels.label_value","text":"label_value(n::AbstractPnmlNode, tag::Symbol, type) -> x::type\n\nIf there is a label tag in n.extralabels, return its value, else return a default value of the correct Type type.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.priority_value-Tuple{Any}","page":"Docstrings","title":"PNML.Labels.priority_value","text":"priority_value(t) -> Real\n\nReturn value of a Priority label.  Missing priority labels are defaulted to one.\n\nExpected label XML: <priority> <text>0.3</text> </priority>\n\nArguments\n\n`t` is anything that supports `get_label(t, tag)`.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.rate_value-Tuple{Any}","page":"Docstrings","title":"PNML.Labels.rate_value","text":"rate_value(t) -> Real\n\nReturn value of a Rate label.  Missing rate labels are defaulted to zero.\n\nExpected label XML: <rate> <text>0.3</text> </rate>\n\nArguments\n\n`t` is anything that supports `get_label(t, tag)`.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.text-Tuple{PNML.AbstractLabel}","page":"Docstrings","title":"PNML.Labels.text","text":"Return text field. All labels are expected to have one that may be nothing or an empty string.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.time_value-Tuple{Any}","page":"Docstrings","title":"PNML.Labels.time_value","text":"time_value(t) -> Real\n\nReturn value of a Time label.  Missing time labels are defaulted to one.\n\nExpected label XML: <time> <text>0.3</text> </time>\n\nArguments\n\n`t` is anything that supports `get_label(t, tag)`.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.validate_toolinfos-Tuple{Any}","page":"Docstrings","title":"PNML.Labels.validate_toolinfos","text":"validate_toolinfos(infos, dd) -> Bool\n\nValidate each ToolInfo in the iterable infos collection.\n\nNote that each info will contain an AbstractDict representing well-formed XML.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.name-Tuple{PNML.Labels.ToolInfo}","page":"Docstrings","title":"PNML.name","text":"Name of tool for this tool specific information element.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser","page":"Docstrings","title":"PNML.Parser","text":"Parser module of PNML.\n\nSee LabelParser, (ToolParser)(@ref).\n\n\n\n\n\n","category":"module"},{"location":"library/#PNML.Parser.pnml_ns","page":"Docstrings","title":"PNML.Parser.pnml_ns","text":"Namespace expected for pnml XML.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.Parser.ParseInscriptionTerm","page":"Docstrings","title":"PNML.Parser.ParseInscriptionTerm","text":"ParseInscriptionTerm(placetype) -> Functor\n\nHolds parameters for parsing inscription. The sort of the inscription must match the place sorttype. Input arcs (source is a transition) and output arcs (source is a place) called as (pit::ParseInscriptionTerm)(::XMLNode, ::PnmlType)\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Parser.ParseMarkingTerm","page":"Docstrings","title":"PNML.Parser.ParseMarkingTerm","text":"ParseMarkingTerm(defsort) -> Functor\n\nHolds parameters for parsing when called as (f::T)(::XMLNode, ::PnmlType)\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Parser.TermJunk","page":"Docstrings","title":"PNML.Parser.TermJunk","text":"TermJunk\n\nparse_term returns a triple of: PnmlExpr, AbstractSortRef, NTuple{N,REFID}\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Parser.XMLNode","page":"Docstrings","title":"PNML.Parser.XMLNode","text":"Alias for EzXML.Node\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Parser.__parse_page!-Union{Tuple{T}, Tuple{AbstractPnmlNet, EzXML.Node, T, Symbol}} where T<:PNML.PnmlTypes.PnmlType","page":"Docstrings","title":"PNML.Parser.__parse_page!","text":"__parse_page!(net, node, pntd, pageid) -> Page\n\nReturn Page. pageid already parsed from node.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.add_label!-Tuple{AbstractDict{Symbol, Any}, EzXML.Node, Any, Any}","page":"Docstrings","title":"PNML.Parser.add_label!","text":"add_label!(collection, node, pntd) -> AbstractDict\n\nParse and add PnmlLabel to collection, return collection.\n\nSee AbstractPnmlObject for those XML entities that have labels. Any \"unknown\" XML is presumed to be a label.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.add_toolinfo!-Tuple{Vector{PNML.Labels.ToolInfo}, Any, Any, Any}","page":"Docstrings","title":"PNML.Parser.add_toolinfo!","text":"add_toolinfo!(collection, node, pntd, parse_contex) -> collection\n\nParse and add ToolInfo to infos collection, return infos.\n\nThe UML from the pnml primer (and schemas) use <toolspecific> as the tag name for instances of the type ToolInfo.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.add_toolinfo-Tuple{Union{Nothing, Vector{PNML.Labels.ToolInfo}}, EzXML.Node, Any, Any}","page":"Docstrings","title":"PNML.Parser.add_toolinfo","text":"add_toolinfo(infos::Maybe{collection}, node::XMLNode, pntd, parse_contex) -> collection\n\nAllocate storage for infos on first use. Then add to infos.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.allchildren","page":"Docstrings","title":"PNML.Parser.allchildren","text":"allchildren(node::XMLNode, tag::AbstractString) -> Vector{XMLNode}\n\nReturn vector of el's immediate children with tag.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.alldecendents","page":"Docstrings","title":"PNML.Parser.alldecendents","text":"alldecendents(node::XMLNode, tag::AbstractString) -> Vector{XMLNode}\n\nReturn vector of node's immediate children and decendents with tag.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.anyelement-Tuple{Symbol, EzXML.Node}","page":"Docstrings","title":"PNML.Parser.anyelement","text":"anyelement(tag::Symbol, node::EzXML.Node) -> PNML.AnyElement\n\n\nReturn AnyElement holding a well-formed XML node. See ToolInfo for one intended use-case.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.attribute","page":"Docstrings","title":"PNML.Parser.attribute","text":"attribute(node::EzXML.Node, key::AbstractString) -> String\nattribute(\n    node::EzXML.Node,\n    key::AbstractString,\n    msg::String\n) -> String\n\n\nReturn XML attribute value.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.fill_decl_dict!-Tuple{AbstractPnmlNet, EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.fill_decl_dict!","text":"fill_decl_dict!(net::AbstractPnmlNet, node::XMLNode, pntd::PnmlType) -> Nothing\n\nAdd a <declaration><structure><declarations> to DeclDict. <declaration> may be attached to <net> and <page> elements. Are network-level values even if attached to pages.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.find_toolinfos!-Tuple{Union{Nothing, Vector{PNML.Labels.ToolInfo}}, Any, Any, Any}","page":"Docstrings","title":"PNML.Parser.find_toolinfos!","text":"find_toolinfos!(toolspecinfos, node, pntd, net) -> toolinfos\n\nCalls add_toolinfo(toolspecinfos, info, pntd, net) for each info found. See Labels.get_toolinfos for accessing ToolInfos.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.firstchild","page":"Docstrings","title":"PNML.Parser.firstchild","text":"firstchild(\n    node::EzXML.Node,\n    tag::AbstractString\n) -> Union{Nothing, EzXML.Node}\nfirstchild(\n    node::EzXML.Node,\n    tag::AbstractString,\n    namespace::AbstractString\n) -> Union{Nothing, EzXML.Node}\n\n\nReturn up to 1 immediate child of el that is a tag.  ns is the default namespace. Invent a prefix to create an iterator of namespace prefix and URI pairs\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.kw!-Tuple{AbstractDict, EzXML.Node, AbstractString}","page":"Docstrings","title":"PNML.Parser.kw!","text":"Add XMLNode attribute, value pair to dictionary.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.nupn_content-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.nupn_content","text":"nupn_content(node::XMLNode, pntd::PnmlType) -> TokenGraphics\n\nParse ToolInfo content that is expected to be <toolspecific tool=\"nupn\" version=\".11\">.\n\n<size places=\"P\" transitions=\"T\" arcs=\"A\"/>    <structure units=\"U\" root=\"R\" safe=\"S\">         <unit id=\"I\">             <places>PL</places>             <subunits>UL</subunits>         </unit>    </structure>\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_arbitrarysort-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_arbitrarysort","text":"parse_arbitrarysort(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType;\n    net\n)\n\n\nReturns concrete AbstractSortRef wraping the REFID of a ArbitrarySort.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_arc!-Tuple{Any, Any, Any, Any, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.parse_arc!","text":"Fill arcset, arcdict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_arc-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.parse_arc","text":"parse_arc(node::XMLNode, pntd::PnmlType) -> Arc\n\nConstruct an Arc with labels specialized for the PnmlType.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_arctype-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_arctype","text":"parse_arctype(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType;\n    net,\n    parentid\n)\n\n\nReturn ArcType label holding <text> value. With optional <toolspecific> & <graphics> information.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_condition-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_condition","text":"parse_condition(::XMLNode, ::PnmlType; net::AbstractPnmlNet) -> Condition\n\nLabel of transition node. Used in the enabling function.\n\nDetails\n\nISO/IEC 15909-1:2019(E) Concept 15 (symmetric net) introduces Φ(transition), a guard or filter function, that is and'ed into the enabling function. 15909-2 maps this to <condition> expressions.\n\nLater concepts add filter functions that are also and'ed into the enabling function.\n\nConcept 28 (prioritized Petri net enabling rule)\nConcept 31 (time Petri net enabling rule)\n\nWe support PTNets having <condition> with same syntax as High-level nets. Condition has <text> and <structure> elements, with all meaning in the <structure> that holds an expression evaluating to a boolean value.\n\nOne field of a Condition holds a boolean expression, AbstractBoolExpr. Another field holds information on variables in the expression.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_condition_term-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_condition_term","text":"parse_condition_term(::XMLNode, ::PnmlType; net::AbstractPnmlNet) -> PnmlExpr, AbstractSortRef, Tuple\n\nUsed as termparser by parse_label_content for Condition label of a Transition; will have a structure element containing a term.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_declaration!","page":"Docstrings","title":"PNML.Parser.parse_declaration!","text":"Fill dd::[DeclDict](@ref) from one or more <declaration> labels.\n\nExpected format: <declaration> <structure> <declarations> <namedsort/> <namedsort/> ...\n\nAssume behavior with the meaning in a <structure> for all nets.\n\nNote the use of both declaration and declarations. We allow repeated declaration (without the s) here. All fill the same DeclDict. See fill_decl_dict!\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.parse_feconstants-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType, AbstractSortRef}","page":"Docstrings","title":"PNML.Parser.parse_feconstants","text":"parse_feconstants(::XMLNode, ::PnmlType, ::AbstractSortRef; net::AbstractPnmlNet) -> Vector{Symbol}\n\nPlace the constants into feconstants(net). Return vector of finite enumeration constant REFIDs.\n\nAccess as 0-ary operator indexed by REFID\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_fifoinitialMarking-Tuple{EzXML.Node, Union{Nothing, PNML.Labels.SortType}, PNML.PnmlTypes.AbstractHLCore}","page":"Docstrings","title":"PNML.Parser.parse_fifoinitialMarking","text":"parse_fifoinitialMarking(\n    node::EzXML.Node,\n    default_sorttype::Union{Nothing, PNML.Labels.SortType},\n    pntd::PNML.PnmlTypes.AbstractHLCore;\n    net,\n    parentid\n)\n\n\nFIFO initial marking labels are expected to have a <structure> child containing ground terms. Sort of marking term must be the same as placetype, the place's SortType.\n\nNB: Will coexist with hlinitialMarkings. See also parse_initialMarking, parse_hlinitialMarking.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_graphics-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_graphics","text":"parse_graphics(\n    node,\n    pntd\n) -> PNML.Labels.PnmlGraphics.Graphics{Float32}\n\n\nArcs, Annotations and Nodes have different graphics semantics. Return a Graphics holding the union of possibilities.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_graphics_coordinate-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_graphics_coordinate","text":"parse_graphics_coordinate(node, pntd) -> PNML.Coordinate\n\n\nReturn Coordinate. Sandard seems to only use integers, we also allow real numbers.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_graphics_fill-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_graphics_fill","text":"parse_graphics_fill(\n    node,\n    pntd\n) -> PNML.Labels.PnmlGraphics.Fill\n\n\nReturn Fill\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_graphics_font-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_graphics_font","text":"parse_graphics_font(\n    node,\n    pntd\n) -> PNML.Labels.PnmlGraphics.Font\n\n\nReturn Font.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_graphics_line-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_graphics_line","text":"parse_graphics_line(\n    node,\n    pntd\n) -> PNML.Labels.PnmlGraphics.Line\n\n\nReturn Line.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_hlinitialMarking-Tuple{EzXML.Node, Union{Nothing, PNML.Labels.SortType}, PNML.PnmlTypes.AbstractHLCore}","page":"Docstrings","title":"PNML.Parser.parse_hlinitialMarking","text":"parse_hlinitialMarking(\n    node::EzXML.Node,\n    default_sorttype::Union{Nothing, PNML.Labels.SortType},\n    pntd::PNML.PnmlTypes.AbstractHLCore;\n    net,\n    parentid\n)\n\n\nHigh-level initial marking labels are expected to have a <structure> child containing a ground term. Sort of marking term must be the same as placetype, the places SortType.\n\nNB: Used by PTNets that assume placetype is DotSort(). See also parse_initialMarking, parse_fifoinitialMarking.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_hlinscription-Tuple{EzXML.Node, Symbol, Symbol, PNML.PnmlTypes.AbstractHLCore}","page":"Docstrings","title":"PNML.Parser.parse_hlinscription","text":"parse_hlinscription(\n    node::EzXML.Node,\n    source::Symbol,\n    target::Symbol,\n    pntd::PNML.PnmlTypes.AbstractHLCore;\n    net,\n    parentid\n)\n\n\nhlinscriptions are expressions.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_initialMarking-Tuple{EzXML.Node, Union{Nothing, PNML.Labels.SortType}, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_initialMarking","text":"parse_initialMarking(\n    node::EzXML.Node,\n    placetype::Union{Nothing, PNML.Labels.SortType},\n    pntd::PNML.PnmlTypes.PnmlType;\n    net,\n    parentid\n)\n\n\nNon-high-level PnmlType initial marking parser. Most things are assumed to be Numbers. See also parse_hlinitialMarking, parse_fifoinitialMarking.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_inscription-Tuple{EzXML.Node, Symbol, Symbol, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_inscription","text":"parse_inscription(\n    node::EzXML.Node,\n    source::Symbol,\n    target::Symbol,\n    pntd::PNML.PnmlTypes.PnmlType;\n    net,\n    parentid\n)\n\n\nIgnore the source & target IDREF symbols.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_label_content-Union{Tuple{F}, Tuple{EzXML.Node, F, PNML.PnmlTypes.PnmlType}} where F","page":"Docstrings","title":"PNML.Parser.parse_label_content","text":"parse_label_content(node::XMLNode, termparser, pntd; net) -> NamedTuple\n\nParse top-level label  node using a termparser callable applied to a <structure> element Return named tuple of: text, exp, sort, graphics, toolspecinfos, vars\n\nTop-level labels are attached to nodes, such as: marking, inscription, condition. Each having a termparser.\n\nReturns vars, a tuple of PNML variable REFIDs. Used in the muti-sorted algebra of High-level nets.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_name-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_name","text":"parse_name(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType;\n    net,\n    parentid\n)\n\n\nReturn Name label holding <text> value. With optional <toolspecific> & <graphics> information.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_namedoperator-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_namedoperator","text":"parse_namedoperator(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType;\n    net\n)\n\n\nDeclaration of an operator expression in many-sorted algebra.\n\nAn operator of arity 0 is a constant (ground-term, literal). When arity > 0, the parameters are variables, using a NamedTuple for values.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_namedsort-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_namedsort","text":"parse_namedsort(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType;\n    net\n)\n\n\nDeclaration that wraps a Sort, adding an ID and name.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_net-Tuple{EzXML.Node}","page":"Docstrings","title":"PNML.Parser.parse_net","text":"parse_net(node::XMLNode[; options...]) -> PnmlNet\n\nPnmlNet created from an <net> XMLNode.\n\nArguments\n\npntd_override::Maybe{PnmlType}\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_nupn-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_nupn","text":"parse_nupn(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType\n) -> PNML.Labels.TokenGraphics\n\n\nParse place-transition net's (PTNet) toolspecific defined for nested unit petri nets.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_page!-Tuple{PnmlNet, Any, EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_page!","text":"parse_page!(net, page_idset, node, pntd) -> Nothing\n\nCall _parse_page! to create a page with its own netsets. Add created page to parent's page_idset and pagedict(net).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_partitionelement!-Tuple{Vector{PNML.Declarations.PartitionElement}, EzXML.Node, Symbol}","page":"Docstrings","title":"PNML.Parser.parse_partitionelement!","text":"parse_partitionelement!(elements::Vector{PartitionElement}, node::XMLNode rid::REFID; net::AbstractPnmlNet)\n\nParse <partitionelement>, add FEConstant refids to the element and append element to the vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_place!-Tuple{Any, Any, Any, Any, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.parse_place!","text":"Fill placeset, placedict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_place-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.parse_place","text":"parse_place(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType,\n    net::AbstractPnmlNet\n) -> Place\n\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_refPlace!-Tuple{Any, Any, Any, Any, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.parse_refPlace!","text":"Fill refplaceset, refplacedict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_refPlace-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.parse_refPlace","text":"parse_refPlace(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType,\n    net::AbstractPnmlNet\n) -> RefPlace\n\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_refTransition!-Tuple{Any, Any, Any, Any, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.parse_refTransition!","text":"Fill reftransitionset, reftransitiondict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_refTransition-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.parse_refTransition","text":"parse_refTransition(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType,\n    net::AbstractPnmlNet\n) -> RefTransition\n\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_sort","page":"Docstrings","title":"PNML.Parser.parse_sort","text":"parse_sort(node::XMLNode, pntd::PnmlType,\n            id::Maybe{REFID}=nothing, name::String=\"\";\n            net::AbstractPnmlNet)\nparse_sort(::Val{:tag}, node::XMLNode, pntd::PnmlType, id, name;\n            net::AbstractPnmlNet)\n\nWhere tag is the XML element tag name for a parser invoked using Val{:tag}.\n\nSee also parse_sorttype_term, parse_namedsort, parse_variabledecl.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.parse_sorttype-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_sorttype","text":"parse_sorttype(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType;\n    net,\n    parentid\n)\n\n\nAnnotation Label that defines the \"sort\" of tokens held by the place and semantics of the marking. NB: The \"type\" of a place from many-sorted algebra is different from the Petri Net \"type\" of a net or \"pntd\". Neither is directly a julia type. Nor a pnml sort.\n\nWe allow all pntd's places to have a <type> label. Non-high-level net places are expecting a numeric sort: eltype(sort) <: Number.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_sorttype_term-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_sorttype_term","text":"parse_sorttype_term(::XMLNode, ::PnmlType; net::AbstractPnmlNet) -> PnmlExpr, AbstractSortRef, Tuple\n\nThe PNML <type> of a <place> is a \"sort\" of the high-level many-sorted algebra. Because we are using the HL implementation with the other meta-models, we support it in all nets.\n\nThe term here is a concrete sort. It is possible to have an inlined concrete sort that is anonymous. We place all these concrete sorts in the decldict(net)` and pass around a AbstractSortRef.\n\nSee parse_sorttype for the rest of the AnnotationLabel structure.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_structure-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_structure","text":"parse_structure(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType;\n    net\n)\n\n\nFor future support of structure elements in non-High-Level nets.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_term-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_term","text":"parse_term(node::XMLNode, ::PnmlType; ddict) -> (PnmlExpr, sort, vars)\nparse_term(::Val{:tag}, node::XMLNode, ::PnmlType; ddict) -> (PnmlExpr, sort, vars)\n\nnode is a child of a <structure>, <subterm> or <def> element with a nodename of tag.\n\nAll terms have a sort, #TODO ... document this XXX\n\nWill be using TermInterface.jl to build an expression tree (AST) that can contain: operators, constants (as 0-arity operators), and variables.\n\nAST expressions are evaluated for:     - place initial marking vector,     - enabling rule and     - firing rule where condition and inscription expressions may contain non-ground terms (using variables).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_term-Tuple{Val{:gtp}, EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_term","text":"`<gtp>` Partition element greater than.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_term-Tuple{Val{:makelist}, EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_term","text":"`<makelist>` Make a List\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_term-Tuple{Val{:partitionelementof}, EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_term","text":"parse_partitionelementof(elements::Vector{PartitionElement}, node::XMLNode)\n\nParse <partitionelement refpartition=\"id\">, add FEConstant refids to the element and append element to the vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_text-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_text","text":"parse_text(\n    node::EzXML.Node,\n    _::PNML.PnmlTypes.PnmlType\n) -> String\n\n\nReturn the stripped string of <text> node's content.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_tokengraphics-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_tokengraphics","text":"parse_tokengraphics(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType\n) -> PNML.Labels.TokenGraphics\n\n\nParse place-transition net's (PTNet) toolspecific structure defined for token graphics. See Labels.TokenGraphics and parse_tokenposition.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_tokenposition-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_tokenposition","text":"parse_tokenposition(node, pntd) -> PNML.Coordinate\n\n\nReturn Cartesian Coordinate relative to containing element.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_toolspecific-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_toolspecific","text":"parse_toolspecific(node, pntd; net)\n\n\nReturn ToolInfo with tool & version attributes and content.\n\nThe content can be one or more well-formed xml elements.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_transition!-Tuple{Any, Any, Any, Any, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.parse_transition!","text":"Fill transitionset, transitiondict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_transition-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.parse_transition","text":"parse_transition(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType,\n    net::AbstractPnmlNet\n) -> Transition\n\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_unknowndecl-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_unknowndecl","text":"parse_unknowndecl(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType;\n    net\n)\n\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_usersort-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_usersort","text":"parse_usersort(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypes.PnmlType;\n    net\n)\n\n\nReturns concrete AbstractSortRef wraping the REFID of a NamedSort, ArbitrarySort. or PartitionSort.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_variabledecl-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_variabledecl","text":"parse_variabledecl(node::XMLNode, pntd::PnmlType; net::AbstractPnmlNet) -> VariableDeclaration\n\nVariable declarations associate an id, name and sort. Stored in DeclDict with key of id.\n\nVariable declarationss may appear in the definition of an operator as well as directly in a declaration.\n\n'<variabledecl>s' are referenced by '<variable>s' in terms.\n\nVariables are used during enabling/firing a transition to identify tokens removed from input place markings, added to output place markings.\n\nVariables are used to substitute tokens into expressions when evaluating terms.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.pnml_namespace-Tuple{EzXML.Node}","page":"Docstrings","title":"PNML.Parser.pnml_namespace","text":"pnml_namespace(\n    node::EzXML.Node;\n    missing_ns_fatal,\n    default_ns\n) -> String\n\n\nReturn namespace of node or default value pnml_ns with warning (or error).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.pnmlmodel","page":"Docstrings","title":"PNML.Parser.pnmlmodel","text":"Build a PnmlModel holding one or more PnmlNet from a file containing XML or a XMLNode.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.register_idof!-Tuple{PNML.IDRegistrys.IDRegistry, EzXML.Node}","page":"Docstrings","title":"PNML.Parser.register_idof!","text":"register_idof!(\n    registry::PNML.IDRegistrys.IDRegistry,\n    node::EzXML.Node\n) -> Symbol\n\n\nReturn registered symbol from id attribute of node. See IDRegistry.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.subterms-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.subterms","text":"subterms(node, pntd; vars) -> Vector{PnmlExpr}, Tuple{REFID}\n\nUnwrap each <subterm> and parse into a PnmlExpr term. Collect expressions in a Vector and accumulate variable REFIDs in a Tuple.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.to_sort-Tuple{AbstractSortRef, AbstractPnmlNet}","page":"Docstrings","title":"PNML.Parser.to_sort","text":"to_sort(sortref::AbstractSortRef, ddict::DeclDict) -> AbstractSort\n\nReturn concrete sort from net using the REFID in sortref,\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.tokengraphics_content-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.tokengraphics_content","text":"tokengraphics_content(node::XMLNode, pntd::PnmlType) -> TokenGraphics\n\nParse ToolInfo content that is expected to be <tokengraphics>.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.toolspecific_content_fallback-Tuple{EzXML.Node, PNML.PnmlTypes.PnmlType}","page":"Docstrings","title":"PNML.Parser.toolspecific_content_fallback","text":"toolspecific_content_fallback(node::XMLNode, pntd::PnmlType) -> AnyElement\n\nContent of a <toolspecific>nodeas parsed byxmldict`.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.unexpected_label!-Tuple{AbstractDict, EzXML.Node, Symbol, Any}","page":"Docstrings","title":"PNML.Parser.unexpected_label!","text":"unexpected_label!(extralabels, child, tag, pntd; net, parentid)\n\nApply a labelparser to child if one matches tag, otherwise call xmldict. Add to extralabels.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.unwrap_subterm-Tuple{EzXML.Node}","page":"Docstrings","title":"PNML.Parser.unwrap_subterm","text":"unwrap_subterm(st::XMLNode) -> XMLNode, Symbol\n\nUnwrap a <subterm> by returning tuple of child node and child's tag.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.xmldict-Tuple{EzXML.Node}","page":"Docstrings","title":"PNML.Parser.xmldict","text":"xmldict(node::XMLNode) -> Union{XmlDictType, String, SubString{String}}\n\nReturn well formed XML as parsed by XMLDict.xml_dict. Symbols for attribute key, strings for element/child keys and strings for value of leaf.\n\nSee: anyelement, AnyElement,PnmlLabel\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.xmlnode-Tuple{AbstractString}","page":"Docstrings","title":"PNML.Parser.xmlnode","text":"xmlnode(s::AbstractString) -> EzXML.Node\n\n\nParse string s into EzXML node.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.@xml_str-Tuple{Any}","page":"Docstrings","title":"PNML.Parser.@xml_str","text":"Parse string into EzXML node.\n\nSee xmlnode.\n\n\n\n\n\n","category":"macro"},{"location":"library/#PNML.Expressions","page":"Docstrings","title":"PNML.Expressions","text":"Expressions Module\n\n\n\n\n\n","category":"module"},{"location":"library/#PNML.Expressions.AbstractBoolExpr","page":"Docstrings","title":"PNML.Expressions.AbstractBoolExpr","text":"TermInterface boolean expression types.\n\nAll boolean expressions have a known sort :bool.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Expressions.AbstractOpExpr","page":"Docstrings","title":"PNML.Expressions.AbstractOpExpr","text":"TermInterface operator expression types.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Expressions.Bag","page":"Docstrings","title":"PNML.Expressions.Bag","text":"Bag: a TermInterface expression calling pnmlmultiset(basis, x, multi) to construct a PNML.PnmlMultiset.\n\nSee PNML.Operator for another TermInterface operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Expressions.BooleanEx","page":"Docstrings","title":"PNML.Expressions.BooleanEx","text":"BooleanEx\n\nTermInterface expression for a BooleanConstant.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Expressions.DotConstantEx","page":"Docstrings","title":"PNML.Expressions.DotConstantEx","text":"DotConstantEx\n\nTermInterface expression for a DotSort element.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Expressions.LiteralExpr","page":"Docstrings","title":"PNML.Expressions.LiteralExpr","text":"LiteralExpr(ex)\n\nLiterally ex, an Expr. toexpr on LiteralExpr recursively calls toexpr on any interpolated symbolic expressions.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Expressions.NumberEx","page":"Docstrings","title":"PNML.Expressions.NumberEx","text":"NumberEx\n\nTermInterface expression for a `<numberconstant>`.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Expressions.PnmlExpr","page":"Docstrings","title":"PNML.Expressions.PnmlExpr","text":"TermInterface expression types.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Expressions.PnmlTupleEx","page":"Docstrings","title":"PNML.Expressions.PnmlTupleEx","text":"PnmlTupleEx(args::Vector)\n\nPnmlTupleEx TermInterface expression object wraps an ordered collection of PnmlExpr objects. There is a related ProductSort: an ordered collection of sorts. Each tuple element will have the same sort as the corresponding product sort.\n\nNB: ISO 15909 Standard considers Tuple to be an Operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Expressions.expr_sortref","page":"Docstrings","title":"PNML.Expressions.expr_sortref","text":"expr_sortref(v::PnmlExpr, net) -> AbstractSortRef\n\nReturn concrete AbstractSortRef of PnmlExpr. Sometimes aliased to basis, sortref.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Expressions.substitute-Tuple{PNML.Expressions.PnmlExpr, NamedTuple}","page":"Docstrings","title":"PNML.Expressions.substitute","text":"substitute(expr, dict)\n\nRecursivly substitute a VariableEx with its the value from var. The values in var will be ground terms of a place's sorttype. These values are from the current marking vector. ```\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Expressions.toexpr","page":"Docstrings","title":"PNML.Expressions.toexpr","text":"toexpr(ex::PnmlExpr, varsubs::NamedTuple{Symbol,Any}, net) -> Expr\n\nReturn Expr constructed from ex. Call toexpr on any contained terms. varsubs used to replace variables in expressions.\n\n\n\n\n\n","category":"function"},{"location":"library/#TermInterface.maketerm","page":"Docstrings","title":"TermInterface.maketerm","text":"@matchable TermInterface expressions\n\n\n\n\n\n","category":"function"},{"location":"acknowledgments/#Acknowledgments","page":"Acknowledgments","title":"Acknowledgments","text":"","category":"section"},{"location":"acknowledgments/#MathML.jl","page":"Acknowledgments","title":"MathML.jl","text":"Its function map architecture was adopted and (permute|perverse|use)d in PNML.j.","category":"section"},{"location":"structure/pntd/#Petri-Net-Type-Definition","page":"Petri Net Type Definition","title":"Petri Net Type Definition","text":"","category":"section"},{"location":"structure/pntd/#pntd_map","page":"Petri Net Type Definition","title":"pntd_map","text":"using PNML; foreach(println, sort(collect(pairs(PNML.PnmlTypes.pntd_map)))) #hide","category":"section"},{"location":"structure/pntd/#pnmltype_map","page":"Petri Net Type Definition","title":"pnmltype_map","text":"using PNML; foreach(println, pairs(PNML.PnmlTypes.pnmltype_map)) #hide","category":"section"},{"location":"structure/pntd/#PNML.PnmlTypes.pntd_map-structure-pntd","page":"Petri Net Type Definition","title":"PNML.PnmlTypes.pntd_map","text":"Map from Petri Net Type Definition (pntd) URI to Symbol. Allows multiple strings to map to the same pntd.\n\nThere is a companion map pnmltype_map that takes the symbol to a type object.\n\nThe URI is a string and may be the full URL of a pntd schema, just the schema file name, or a placeholder for a future schema.\n\nFor readability, the 'pntd symbol' should match the name used in the URI with inconvinient characters removed or replaced. For example, '-' is replaced by '_'.\n\n\n\n\n\n","category":"constant"},{"location":"structure/pntd/#PNML.PnmlTypes.pnmltype_map-structure-pntd","page":"Petri Net Type Definition","title":"PNML.PnmlTypes.pnmltype_map","text":"The key Symbols are the supported kinds of Petri Nets. Maps to singletons.\n\n\n\n\n\n","category":"constant"},{"location":"structure/layers/","page":"Intermediate Representation","title":"Intermediate Representation","text":"note: Graphics are elided from this discussion\nEverywhere there are ToolInfos in this discussion one may assume that there is also an optional Graphics possible.While we parse graphics XML into \"containers of strings\" and Coordinates no further use is implemented or planned. And no discussion of use is present.","category":"section"},{"location":"structure/layers/#Core-Layer","page":"Intermediate Representation","title":"Core Layer","text":"An intermediate representation (IR) of the XML model usable to form networks. Many different flavors of Petri Nets are expected to be implemented using the IR.\n\nXML attribute names and child element tag names are used as keys. The pnml standard/schemas do not use colliding names.\n\nThe core is implemented under the assumption the the input pnml file is valid. All tags are assumed to be meaningful to the resulting network. The pnmlcore schema requires undefined tags on objects will be considered pnml labels.\n\nThe IR is capable of handling arbitrary labels.\n\nMany label tags from higherlevel pnml schemas are recognized by the IR core parser. They will be parsed for pnmlcore nets. Users are expected to use a meta-model if they want specific behavior.\n\nSome parts of pnml are complicated.\n\nThe crude structure required by the pnmlcore schema:\n\nPnmlModel\n\nNet\nPages\nPlaces, Marking, Toolinfos, unclaimed labels  [SortType] [Capacity]\nTransitions, Condition, Toolinfos, unclaimed labels [TransitionRate]\nArcs, Inscription, Toolinfos, unclaimed labels [ArcType]\nToolinfos [Labels.TokenGraphics]\nLabels unclaimed, [Declaration]\nSubpages\nName Label\nToolinfos\nLabels\n\nThis implementation will be a superset of what is in the standard.\n\nConcepts from High-Level Petri Nets will be present in the Core layer.","category":"section"},{"location":"structure/layers/#Declaration-Dictionaries","page":"Intermediate Representation","title":"Declaration Dictionaries","text":"The XML file format allows declarations to be declared in <net> and <page> elements.\n\nAll Declaration labels for a net share the same DeclDict. It is net-level data even when in a <page>.\n\nXML XPath is used to gather this information before parsing the rest of the elements. Allows using DeclDict while parsing.","category":"section"},{"location":"structure/layers/#Net-Data-Dictionaries","page":"Intermediate Representation","title":"Net Data Dictionaries","text":"This is where the graph node storage resides.\n\nPnmlNetData contains ordered collections of the graph node objects, indexed by REFID symbols.\n\nThe XML file format distributes a <net> over one or more <page>s. As the pages are parsed, the nodes are appended to a PnmlNetData dictionary and a PnmlNetKeys set.\n\nThe PnmlNetData dictionaries maintain insertion order.\n\nEach graph node may have labels attached. What labels depends on the PnmlTypes","category":"section"},{"location":"structure/layers/#ID-Sets","page":"Intermediate Representation","title":"ID Sets","text":"PnmlNetKeys contains ordered sets of REFID symbols.\n\nEach PnmlNetKeys set maintains insertion order.\n\nUses REFIDs to keep track of which page owns which graph nodes or sub-page. We always use the flatten_pages! version. Testing of non-flattened nets is very minimal.\n\nwarning: Warning\nAfter flatten_pages! the PnmlNetKeys of the only remaining page are assumed to be the same as the keys of corresponding PnmlNetData dictionary.","category":"section"},{"location":"structure/layers/#Diagram-of-memory-footprint","page":"Intermediate Representation","title":"Diagram of memory footprint","text":"(Image: alternative text)","category":"section"},{"location":"structure/layers/#PNML.DeclDict-structure-layers","page":"Intermediate Representation","title":"PNML.DeclDict","text":"struct DeclDict\n\nvariabledecls::Dict{Symbol, Any}:     Holds VariableDeclaration.     A Variable is used to locate the declaration's name and sort.\n\nnamedsorts::Dict{Symbol, Any}\narbitrarysorts::Dict{Symbol, Any}\npartitionsorts::Dict{Symbol, Any}\nmultisetsorts::Dict{Symbol, Any}\nproductsorts::Dict{Symbol, Any}\nnamedoperators::Dict{Symbol, Any}\narbitraryoperators::Dict{Symbol, Any}\npartitionops::Dict{Symbol, Any}\nfeconstants::Dict{Symbol, Any}\nuseroperators::Dict{Symbol, Any}\n\nCollection of dictionaries holding various kinds of PNML declarations. Each keyed by REFID symbols.\n\n\n\n\n\n","category":"type"},{"location":"structure/layers/#PNML.PnmlNetData-structure-layers","page":"Intermediate Representation","title":"PNML.PnmlNetData","text":"struct PnmlNetData\n\nplace_dict::OrderedCollections.OrderedDict{Symbol, Any}\ntransition_dict::OrderedCollections.OrderedDict{Symbol, Any}\narc_dict::OrderedCollections.OrderedDict{Symbol, Any}\nrefplace_dict::OrderedCollections.OrderedDict{Symbol, Any}\nreftransition_dict::OrderedCollections.OrderedDict{Symbol, Any}\n\nCollect each of the PnmlNodess & Arcs of a Petri Net Graph into one collection. Accessed via pnml ID key or iterate over values of an OrderedDict.\n\nIn the 'pnml' standard there is a Page structure that can be removed by flatten_pages!, removing some display-related information, leaving a functional Petri Net Graph as described in this structure. It is intended to be a per-PnmlNet database that is mutated as each page is parsed.\n\nSee PnmlNetKeys for page-level pnml ID of \"owners\" net data.\n\n\n\n\n\n","category":"type"},{"location":"structure/layers/#PNML.PnmlNetKeys-structure-layers","page":"Intermediate Representation","title":"PNML.PnmlNetKeys","text":"struct PnmlNetKeys\n\npage_set::OrderedCollections.OrderedSet{Symbol}\nplace_set::OrderedCollections.OrderedSet{Symbol}\ntransition_set::OrderedCollections.OrderedSet{Symbol}\narc_set::OrderedCollections.OrderedSet{Symbol}\nreftransition_set::OrderedCollections.OrderedSet{Symbol}\nrefplace_set::OrderedCollections.OrderedSet{Symbol}\n\nPer-page structure of OrderedSets of pnml IDs for each \"owned\" Page and other AbstractPnmlObject.\n\n\n\n\n\n","category":"type"},{"location":"structure/high_level/#","page":"High Level Concepts","title":"","text":"Based on a draft version of ISO/IEC 15909-1:2004 High-level Petri nets - Part 1: Concepts, definitions and graphical notation.\n\nUseful for setting the ontology.\n\nArc inscriptions are expressions that are evaluated.\n\nPlace markings are multisets of tokens of a sort/type.\n\nTransition conditions are boolean expressions that are evaluated. Used to determine if transition is enabled.\n\nExpressions in pnml can be many-sorted algebras. Declaration, Term, Sort, Multiset, Variable, are among the concepts used to define expressions.","category":"section"},{"location":"structure/high_level/#Terms","page":"High Level Concepts","title":"Terms","text":"Terms have sorts: the sort of the variable or the output sort of the operator.\n\nTerms can be buit from built-in operators and sorts, and user-defined variables. These are defined in variable declarations, a kind of annotation label attached to pages and nets.\n\nA transition can have a condition, a term of sort boolean, which imposes restrictions on when the transition may fire.","category":"section"},{"location":"structure/high_level/#Sorts","page":"High Level Concepts","title":"Sorts","text":"named sorts are constructed from existing sorts and given a new name.\n\narbitrary sort is not defined in core, is not allowed in Symmetric Nets. HLPNG adds arbitrary declarations, sorts of lists, strings, integers to Symmetric Nets.\n\nThe sort of a term is the sort of the variable or the output sort of the operator.","category":"section"},{"location":"structure/high_level/#Operators","page":"High Level Concepts","title":"Operators","text":"An operator can be: built-in constant, built-in operator, multiset operator or tuple operator.\n\nUser-defined operators, or named operators are abbreviations, built from existing operators and parameter variables.\n\nThere will be arbitrary operator declarations for High-Level Petri Net Graphs, but not for Symmetric Nets.\n\nOperators have a sequence of input sorts and a single output sort.","category":"section"},{"location":"structure/high_level/#Variables","page":"High Level Concepts","title":"Variables","text":"TBD","category":"section"},{"location":"structure/high_level/#Notes-on-Petri-Nets","page":"High Level Concepts","title":"Notes on Petri Nets","text":"","category":"section"},{"location":"structure/high_level/#Multiset-Rewriting-Systems","page":"High Level Concepts","title":"Multiset Rewriting Systems","text":"I. Cervesato: Petri Nets as Multiset Rewriting Systems in a Linear Framework\n\nThis addresses Place Transition Nets. High-level Petri nets explictily use multisets.\n\nfactor out the multiplicity of the elements of the underlying set. This is achieved by first defining the notion of singleton multisets and then by writing arbitrary multisets as linear combination of singleton multisets.\n\na rewrite rule can be viewed as a singleton multiset\n\nPetri nets are meant to represent evolving systems. To represent this dynamic flavor, we will rely on the notion of multiset rewriting systems.","category":"section"},{"location":"structure/high_level/#Continuous,-Open-and-Other-Petri-Nets","page":"High Level Concepts","title":"Continuous, Open and Other Petri Nets","text":"Allow marking, inscription, conditions to be floating point even when standard wants an integer. This allows continuous nets.\n\nSee Petri.jl and AlgebraicPetri.jl for some continuous Petri Net use-cases.\n\nTODO: Hybrid nets combining floating point/continuous and integer/discrete inscription/marking.","category":"section"},{"location":"evaluate/#Evaluate-possible-functors","page":"Add multisets","title":"Evaluate possible functors","text":"Things that are functors:\n\nMarking:\nInscription\nCondition\nTerm: return a sort's value type TBD","category":"section"},{"location":"evaluate/#Examples","page":"Add multisets","title":"Examples","text":"","category":"section"},{"location":"evaluate/#XMLDict-format-Terms","page":"Add multisets","title":"XMLDict format Terms","text":"XMLDict.jl\n\nXMLDict implements an Associative interface (get(), getindex(), haskey()) for reading XML elements and attributes.","category":"section"},{"location":"evaluate/#Operator-that-constructs-a-multiset-of-sort-dot.","page":"Add multisets","title":"Operator that constructs a multiset of sort dot.","text":"A marking is a multiset of a place's sorttype. The output sort of the operator must be of this sort (equatSorts is true and sortof(place) == sortof(marking)).\n\nThe output sort of numberof is the sort of the element in 2nd subterm.\n\npositive and dotconstant are builtin-constants.","category":"section"},{"location":"evaluate/#Tuple","page":"Add multisets","title":"Tuple","text":"","category":"section"},{"location":"evaluate/#Add-multisets","page":"Add multisets","title":"Add multisets","text":"<hlinitialMarking>\n    <text>1`3 ++ 1`2</text>\n    <structure>\n        <add>\n            <subterm>\n                <numberof>\n                <subterm><numberconstant value=\\\"1\\\"><positive/></numberconstant></subterm>\n                <subterm><numberconstant value=\\\"3\\\"><positive/></numberconstant></subterm>\n                </numberof>\n            </subterm>\n            <subterm>\n                <numberof>\n                <subterm><numberconstant value=\\\"1\\\"><positive/></numberconstant></subterm>\n                <subterm><numberconstant value=\\\"2\\\"><positive/></numberconstant></subterm>\n                </numberof>\n            </subterm>\n        </add>\n    </structure>\n</hlinitialMarking>\n\nConstructs an expression that adds 2 multisets. When all multiplicities are 1 and sortof subterm has an eltype the usual math applies. Output sort needs to match eltype of operation result.\n\n1`3 + 1`2 = 3 + 2 = 5\n2`3 + 1`2 = 3 + 3 + 2 = 8","category":"section"},{"location":"evaluate/#Zero","page":"Add multisets","title":"Zero","text":"","category":"section"},{"location":"structure/type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Overview of some type hierarchies.","category":"section"},{"location":"structure/type_hierarchies/#PnmlType-Petri-Net-Type-Definition-(PNTD)","page":"Type Hierarchies","title":"PnmlType - Petri Net Type Definition (PNTD)","text":"See PnmlTypes module page.\n\nThere are levels:  Core (Place-Transition), Continuous and High-Level PNG (HLPNG).\n\nPnmlCoreNet is a concrete subtype of PnmlType. PnmlCoreNet is used by some PNet.AbstractPetriNet concrete types (PNet.SimpleNet).\n\nContinuousNet is a concrete type of AbstractContinuousNet. ContinuousNet uses floating point marking and inscriptions. It is a nonstandard extension to the ISO standard.\n\nHLCoreNet is a concrete subtype of AbstractHLCore. HLCoreNet is used by some PNet.AbstractPetriNet concrete types (PNet.HLPetriNet). Think of it as a testable implementation of AbstractHLCore.\n\nTries to represent the model (all models) at a structural level. Tries to avoid imposing semantics. It is a toolkit with a wide range of behavior. Those semantics should be part of PNet.AbstractPetriNet. Yes, the PnmlType in use selects some semantics and affects the toolkit.\n\ntype_tree(PNML.PnmlTypes.PnmlType) # hide\n\nPnmlType Description\nPnmlCoreNet Core structure. Only defined label is <name>.\nPTNet Using <initialMarking>, <inscription> labels that have a <text> containing a number.\nHLCoreNet HL Petri Net Graphs structure. Using <hlinitialMarking>, <hlinscription> labels with <structure>. Multisorted algebra.\nPT-HLPNG Restrict sort to dot, condition always true.\nSymmetricNet Restrict sorts to finite, annotations have <structure>.\nHLNet Unrestricted, Arbitrary Sorts, Operators, Lists, Strings.\nStochastic Extended PNML. Use <rate> label\nTimed Extended PNML.\nOpen Extended PNML .\n\nTodo: Continuous Petri Net","category":"section"},{"location":"structure/type_hierarchies/#PNet.AbstractPetriNet","page":"Type Hierarchies","title":"PNet.AbstractPetriNet","text":"PNet.AbstractPetriNet uses the Intermediate Representation's PnmlNet and PnmlType to implement a Petri Net Graph (PNG).","category":"section"},{"location":"structure/type_hierarchies/#AbstractPnmlObject","page":"Type Hierarchies","title":"AbstractPnmlObject","text":"Page, Arc, Place, Transition define the graph of a PnmlNet.\n\ntype_tree(PNML.AbstractPnmlObject) # hide","category":"section"},{"location":"structure/type_hierarchies/#Structure","page":"Type Hierarchies","title":"Structure","text":"Fields expected of every subtype of AbstractPnmlObject:\n\nName Description\nid Symbol, see 'REFID\npntd <: PnmlType identifies the meta-model of a net.\nname Optional Name label.\nlabels Optional PnmlLabel collection of unclaimed labels.\ntoolspecinfos Optional ToolInfo collection of tool specific content.\n\nNote that subtypes may have additional fields. For example, Page has a subpages field.","category":"section"},{"location":"structure/type_hierarchies/#ADT","page":"Type Hierarchies","title":"ADT","text":"using Moshi.Data: @data\n\n@data NetNode{PNTD,} begin\n    Arc\n    Place\n    Transition\n    RefPlace\n    RefTransition\n    Page\nend","category":"section"},{"location":"structure/type_hierarchies/#AbstractLabel","page":"Type Hierarchies","title":"AbstractLabel","text":"AbstractLabels are attached to AbstractPnmlObjects. Kinds of label include: marking, inscription, condition and declarations, sort, and ad-hoc. Ad-hoc is where we assume any undefined element attached to a AbstractPnmlObject instance is a label and add it to a collection of 'other labels'. Some 'other labels' can be accessed using: rate_value, delay_value.\n\nSome Labels of Interest\n\nFull Name Node Label Description\nMarking Place Value is a number or ground term.\nInscription Arc Value is a number or ground term.\nCondition Transition Value is a boolean term.\nRate Transition Value is a floating point number.\nPriority Transition Firing order of enabled transitions.\nWeight Transition Firing tiebreaker.\n\nNote that Rate, Priority and Weight are not part of base standard. See Unclaimed Labels\n\ntype_tree(PNML.AbstractLabel) # hide\n\ninfo: Difference between Object and Label\nObjects have ids and Names.\nLabels are attached to Objects.\nSome Labels (attributes) do not have Graphics.\nLabels are extendable.\nLabels are named by the xml tag. Any \"unknown\" tag of an Object is presumed to be a label.","category":"section"},{"location":"structure/type_hierarchies/#PnmlException","page":"Type Hierarchies","title":"PnmlException","text":"type_tree(PNML.PnmlException) # hide","category":"section"},{"location":"structure/type_hierarchies/#Many-sorted-Algebra-Concepts","page":"Type Hierarchies","title":"Many-sorted Algebra Concepts","text":"The PNML Standard builds the High-level Petri Net Graph as a layer using a Core layer (PnmlCore). The main feature of the HL layer (HLCore) is to require all annotation labels to have <text> and <structure> elements. All meaning is required to reside in a single child of <structure>. With the <text> for human/documentation use.\n\nImplemented so that it is mostly part of the PnmlCore implementation. At which level, both <text> and <structure> are optional.\n\nThe <type> label of a Place is meant to be a sort of a many-sorted algebra. We call it sorttype to reduce the confusion.\n\nPNML.jl allows/requires all net type's places to have sorttype objects. Only high-level PNML input is expected to contain a <type> tag. For other nets we interpret the SortType to be IntegerSort or RealSort based on PNTD. And Marking values of non-high-level nets are interpreted as multisets with airity of 1. This allows more common implementation in the core layer.\n\nFor high-level nets the sorttype object is an SortType HLAnnotation subtype containing an AbstractSort.","category":"section"},{"location":"structure/type_hierarchies/#AbstractDeclaration","page":"Type Hierarchies","title":"AbstractDeclaration","text":"Labels attached to PnmlNet and/or Page. The Declarations contained in a <declarations> apply to the whole net even when attached to a Page.\n\ntype_tree(PNML.AbstractDeclaration) # hide","category":"section"},{"location":"structure/type_hierarchies/#AbstractSort","page":"Type Hierarchies","title":"AbstractSort","text":"Each Place has a sorttype containing an AbstractSort.\n\ntype_tree(PNML.AbstractSort) # hide","category":"section"},{"location":"structure/type_hierarchies/#AbstractTerm","page":"Type Hierarchies","title":"AbstractTerm","text":"Part of the many-sorted algebra of a High-level net. See AbstractOperator. Variable\n\ntype_tree(PNML.AbstractTerm) # hide","category":"section"},{"location":"structure/type_hierarchies/#PnmlExpr","page":"Type Hierarchies","title":"PnmlExpr","text":"Expressions of the many-sorted algebra are part of a petri net's dynamic behavior. PnmlExpr are TermInterface compatible. Used to do variable substitution before evaluation of mutisorted algebra expressions in enabling and firing rules. Ground terms contain no variables and therefore do not depend on the current marking of the net.\n\ntype_tree(PNML.PnmlExpr) # hide","category":"section"},{"location":"structure/interface/#Interface","page":"Interfaces","title":"Interface","text":"warning: Warning\nBeing a work in progress, there will be obsolete, optimistic or incoherent bits.Eventually this section will cover interfaces in a useful way.\n\nThe intermediate representation is used to implement networks expressed in a pnml model. The consumer of the IR is a network is most naturally a varity of Petri Net.\n\nWe start a description of the net IR here.","category":"section"},{"location":"structure/interface/#Dict-Type","page":"Interfaces","title":"Dict Type","text":"XmlDictType used by:\n\nAnyElement\nLabels.PnmlLabel\nLabels.SortType\nParser.xmldict","category":"section"},{"location":"structure/interface/#Top-Level:-Model,-Net,-Page","page":"Interfaces","title":"Top Level: Model, Net, Page","text":"At the top level[layers] a <pnml> model is one or more networks::PnmlNet, each described by a <net> tag and one or more <page> tags.\n\nPage  is a required element mostly present for visual presentation to humans. It contains AbstractPnmlObject types that implement the Petri Net Graph (PNG).\n\n[layers]: Page inside a PnmlNet inside a PNet.AbstractPetriNet. Where the Petri Net part is expressed as a Petri Net Type Definition XML schema file (.pntd) identified by a URI. Or would if our nonstandard extensions had schemas defined. Someday there will be such schemas.\n\nWhile Graphics is implemented it is not dicussed further (until someone extends/uses it).\n\nToolInfo used to attach well-formed XML almost anywhere in the PNG. TODO: document toolparser.\n\nParse pnml for input, worry about writing back out and interchange later (future extensions). Another future extension may be to use pages for distributed computing.\n\nThe pnml standard permits that multiple pages canto be flattened (by flatten_pages!) to a single Page before use. We do that.\n\nPNet.AbstractPetriNet subtypes wrap and extend PnmlNet. Note the Pnml to Petri.\n\nPnmlNet and its contents can be considered an intermediate representation (IR). A concrete PNet.AbstractPetriNet type uses the IR to produce higher-level behavior. This is the level at which flatten_pages! and deref! operate.\n\nPNet.AbstractPetriNet is the level of most Petri Net Graph semantics. One example is enforcing integer, non-negative, positive. One mechanism used is type parameters.\n\nRemember, the IR trys to be as promiscuous as possible.\n\nXML <net> tags are parsed by parse_net into a PnmlNet.\n\nXML <page> tags are parsed by parse_page! into a Page.","category":"section"},{"location":"structure/interface/#Places","page":"Interfaces","title":"Places","text":"Properties that various places may have one or more of:\n\ndiscrete\ncontinuous\ntimed","category":"section"},{"location":"structure/interface/#Transitions","page":"Interfaces","title":"Transitions","text":"Properties that various transitions may have one or more of:\n\ndiscrete\ncontinuous\nhybrid of discrete & continuous subnets\nstochastic\nimmediate\ndeterministically time delayed\nscheduled\n\nThe pnml schemas and primer only try to cover the discrete case as Place-Transition and High-Level Petri Nets.","category":"section"},{"location":"structure/interface/#Extensions-to-PNML","page":"Interfaces","title":"Extensions to PNML","text":"","category":"section"},{"location":"structure/interface/#Continuous-Values","page":"Interfaces","title":"Continuous Values","text":"Continous support is present where possible. For instance, when a number appers in the XML number_value is used to parse the string to Int or Float64. This is currently (2022) \"non-standard\" so such pnml files will not be generally interchangable with other tools.\n\n'Discrete, Continuous, and Hybrid Petri Nets' by Rene David and Hassane Alla\n\nVANESA\n\nSee rate_value for a use of non-standard labels. Implements a stochastic petri net as part of the first working use-case. Demonstrates the expressiveness of pnml.","category":"section"},{"location":"structure/interface/#Petri-Net-Graphs-and-Networks","page":"Interfaces","title":"Petri Net Graphs and Networks","text":"There are 3 top-level forms:\n\nPNet.AbstractPetriNet subtypes wraping a single PnmlNet.\nPnmlNet  maybe multiple pages.\nPage as the only page of the only net in a Abstractpetrinet.\n\nThe simplest arrangement is a pnml model with a single <net> element having a single <page>. Any <net> may be flatten to a single page.\n\nThe initial PNet.AbstractPetriNet subtypes are built using the assumption that multiple pages will be flattened to a single page.","category":"section"},{"location":"structure/interface/#Simple-Interface-Methods","page":"Interfaces","title":"Simple Interface Methods","text":"What makes a method simple? No other arguments besides the object it operates upon.","category":"section"},{"location":"structure/interface/#pid(x)-get-PNML-ID-symbol","page":"Interfaces","title":"pid(x) - get PNML ID symbol","text":"Many things within a pnml net have unique identifiers, which are used for referring to the object.\n\nPNML.pid\n\nmethods(PNML.pid) # hide","category":"section"},{"location":"structure/interface/#name(x)-get-name","page":"Interfaces","title":"name(x) - get name","text":"AbstractPnmlObjects and PnmlNets have a name label. PNML.Labels.Declarations have a name attribute. ToolInfos have a toolname attribute.\n\nPNML.name\n\nmethods(PNML.name) # hide","category":"section"},{"location":"structure/interface/#tag(x)-access-XML-tag-symbol","page":"Interfaces","title":"tag(x) - access XML tag symbol","text":"PNML.tag\n\nmethods(PNML.tag) # hide","category":"section"},{"location":"structure/interface/#nettype(x)-return-PnmlType-identifying-PNTD","page":"Interfaces","title":"nettype(x) - return PnmlType identifying PNTD","text":"PNML.nettype\n\nmethods(PNML.nettype) # hide","category":"section"},{"location":"structure/interface/#Nodes-of-Petri-Net-Graph","page":"Interfaces","title":"Nodes of Petri Net Graph","text":"Return vector of nodes.  Assumes flattened net so that the PnmlNet and Page refer to the same net-level AbstractDict data structure.","category":"section"},{"location":"structure/interface/#places","page":"Interfaces","title":"places","text":"PNML.places\n\nmethods(PNML.places) # hide","category":"section"},{"location":"structure/interface/#transitions","page":"Interfaces","title":"transitions","text":"PNML.transitions\n\nmethods(PNML.transitions) # hide","category":"section"},{"location":"structure/interface/#arcs","page":"Interfaces","title":"arcs","text":"PNML.arcs\n\nmethods(PNML.arcs) # hide","category":"section"},{"location":"structure/interface/#refplaces","page":"Interfaces","title":"refplaces","text":"PNML.refplaces\n\nmethods(PNML.refplaces)  # hide","category":"section"},{"location":"structure/interface/#reftransitions","page":"Interfaces","title":"reftransitions","text":"PNML.reftransitions\n\nmethods(PNML.reftransitions)  # hide","category":"section"},{"location":"structure/interface/#Node-Predicates-uses-PNML-ID","page":"Interfaces","title":"Node Predicates - uses PNML ID","text":"","category":"section"},{"location":"structure/interface/#has_place","page":"Interfaces","title":"has_place","text":"PNML.has_place\n\nmethods(PNML.has_place)  # hide","category":"section"},{"location":"structure/interface/#has_transition","page":"Interfaces","title":"has_transition","text":"PNML.has_place\n\nmethods(PNML.has_transition)  # hide","category":"section"},{"location":"structure/interface/#has_arc","page":"Interfaces","title":"has_arc","text":"PNML.has_arc\n\nmethods(PNML.has_arc) # hide","category":"section"},{"location":"structure/interface/#has_refplace","page":"Interfaces","title":"has_refplace","text":"PNML.has_refplace\n\nmethods(PNML.has_refplace)  # hide","category":"section"},{"location":"structure/interface/#has_reftransition","page":"Interfaces","title":"has_reftransition","text":"PNML.has_reftransition\n\nmethods(PNML.has_reftransition)  # hide","category":"section"},{"location":"structure/interface/#Node-Access-uses-PNML-ID","page":"Interfaces","title":"Node Access - uses PNML ID","text":"","category":"section"},{"location":"structure/interface/#place","page":"Interfaces","title":"place","text":"PNML.place\n\nmethods(PNML.place)  # hide","category":"section"},{"location":"structure/interface/#transition","page":"Interfaces","title":"transition","text":"PNML.transition\n\nmethods(PNML.transition) # hide","category":"section"},{"location":"structure/interface/#arc","page":"Interfaces","title":"arc","text":"PNML.arc\n\nmethods(PNML.arc)  # hide","category":"section"},{"location":"structure/interface/#refplace","page":"Interfaces","title":"refplace","text":"PNML.refplace\n\nmethods(PNML.refplace)  # hide","category":"section"},{"location":"structure/interface/#reftransition","page":"Interfaces","title":"reftransition","text":"PNML.reftransition\n\nmethods(PNML.reftransition)  # hide","category":"section"},{"location":"structure/interface/#Node-ID-Iteratables","page":"Interfaces","title":"Node ID Iteratables","text":"Better to iterate than allocate. Using a set abstraction that iterates consistently, perhaps in insertion order.","category":"section"},{"location":"structure/interface/#place_idset","page":"Interfaces","title":"place_idset","text":"Object Synopsis Comment\nPnmlNet keys(placedict(net)) Iterates PnmlNetData OrderedDict keys\nPage place_idset(netsets(page)) Iterates PnmlNetKeys OrderedSet\nPnmlNetKeys OrderedSet Iterates PnmlNetKeys OrderedSet\n\nBoth iterate over REFIDs that are indices into PnmlNetData., To access a Place in the PnmlNetData use place(refid).\n\nThe contents of PnmlKeySet are indices into PnmlNetData. When there is only one page, the keys of the placedict and place_set will be (must be) the same.\n\nFor the foreseeable future, there will be little use of multi-page APIs. It is expected that flattened PNML nets will be the fully supported, tested, thought-through API.\n\nThe discussion using place_idset also applies to other *_idsets.\n\nPNML.place_idset\n\nmethods(PNML.place_idset)  # hide","category":"section"},{"location":"structure/interface/#transition_idset","page":"Interfaces","title":"transition_idset","text":"PNML.transition_idset\n\nmethods(PNML.transition_idset)  # hide","category":"section"},{"location":"structure/interface/#arc_idset","page":"Interfaces","title":"arc_idset","text":"PNML.arc_idset\n\nmethods(PNML.arc_idset)  # hide","category":"section"},{"location":"structure/interface/#refplace_idset","page":"Interfaces","title":"refplace_idset","text":"PNML.refplace_idset\n\nmethods(PNML.refplace_idset)  # hide","category":"section"},{"location":"structure/interface/#reftransition_idset","page":"Interfaces","title":"reftransition_idset","text":"PNML.reftransition_idset\n\nmethods(PNML.reftransition_idset)  # hide","category":"section"},{"location":"structure/interface/#Arc-Related","page":"Interfaces","title":"Arc Related","text":"","category":"section"},{"location":"structure/interface/#all_arcs-source-or-target-is-PNML-ID","page":"Interfaces","title":"all_arcs - source or target is PNML ID","text":"PNML.all_arcs\n\nmethods(PNML.all_arcs)  # hide","category":"section"},{"location":"structure/interface/#src_arcs-source-is-PNML-ID","page":"Interfaces","title":"src_arcs - source is PNML ID","text":"PNML.src_arcs\n\nmethods(PNML.src_arcs)  # hide","category":"section"},{"location":"structure/interface/#tgt_arcs-target-is-PNML-ID","page":"Interfaces","title":"tgt_arcs - target is PNML ID","text":"tgt_arcs\n\nmethods(PNML.tgt_arcs)  # hide","category":"section"},{"location":"structure/interface/#inscription-evaluate-inscription-value-(or-return-default)","page":"Interfaces","title":"inscription - evaluate inscription value (or return default)","text":"inscription\n\nmethods(PNML.inscription)  # hide","category":"section"},{"location":"structure/interface/#deref!-dereference-all-references-of-flattened-net","page":"Interfaces","title":"deref! - dereference all references of flattened net","text":"deref!\n\nmethods(PNML.deref!)  # hide","category":"section"},{"location":"structure/interface/#deref_place-dereference-one-place","page":"Interfaces","title":"deref_place - dereference one place","text":"deref_place\n\nmethods(PNML.deref_place)  # hide","category":"section"},{"location":"structure/interface/#deref_transition-dereference-one-transition","page":"Interfaces","title":"deref_transition - dereference one transition","text":"deref_transition\n\nmethods(PNML.deref_transition)  # hide","category":"section"},{"location":"structure/interface/#Place-Related","page":"Interfaces","title":"Place Related","text":"","category":"section"},{"location":"structure/interface/#initial_marking-evaluate-marking-value-(or-return-default)","page":"Interfaces","title":"initial_marking - evaluate marking value (or return default)","text":"initial_marking\n\nmethods(PNML.initial_marking)  # hide","category":"section"},{"location":"structure/interface/#Transition-Related","page":"Interfaces","title":"Transition Related","text":"","category":"section"},{"location":"structure/interface/#conditions-collect-evaluated-conditions","page":"Interfaces","title":"conditions - collect evaluated conditions","text":"conditions\n\nmethods(PNML.conditions)  # hide","category":"section"},{"location":"structure/interface/#condition-evaluate-condition-of-one-transition","page":"Interfaces","title":"condition - evaluate condition of one transition","text":"condition\n\nmethods(PNML.condition)  # hide","category":"section"},{"location":"structure/interface/#Labels-Annotation-and-HLAnnotation","page":"Interfaces","title":"Labels - Annotation and HLAnnotation","text":"Both kinds (all labels) have Graphics and ToolInfo. Labels.HLAnnotation adds optional <text>, <structure>.","category":"section"},{"location":"structure/interface/#text","page":"Interfaces","title":"text","text":"text\n\nmethods(PNML.text) # hide","category":"section"},{"location":"structure/interface/#value","page":"Interfaces","title":"value","text":"value\n\nmethods(PNML.value) # hide","category":"section"},{"location":"structure/interface/#get_label-get-a-specific-label","page":"Interfaces","title":"get_label - get a specific label","text":"get_label\n\nmethods(PNML.get_label) # hide","category":"section"},{"location":"structure/interface/#ToolInfo","page":"Interfaces","title":"ToolInfo","text":"","category":"section"},{"location":"structure/interface/#get_toolinfo-get-a-specific-toolinfo-exist","page":"Interfaces","title":"get_toolinfo - get a specific toolinfo exist","text":"PNML.Labels.get_toolinfo\n\nmethods(PNML.Labels.get_toolinfo) # hide","category":"section"},{"location":"structure/interface/#Type-Lookup","page":"Interfaces","title":"Type Lookup","text":"Petri Net Graph Object Types are parameterized by Label Types. What labels are \"allowed\" (syntax vs. semantics vs. schema vs. standard) is parameterized on the PNTD (Petri Net Type Definition).\n\nSee PnmlNets & AbstractPnmlObjects, and  PnmlTypes for details of the singleton types used.","category":"section"},{"location":"structure/interface/#Value-Types","page":"Interfaces","title":"Value Types","text":"TBD\n\ninfo: parse_sorttype is different\nParser.parse_sorttype is used to parse an XML <type> element. It is not one of these look-up a type trait methods.","category":"section"},{"location":"structure/traits/#Traits","page":"Traits","title":"Traits","text":"Some of the traits used are based on the pntd. Each supported pntd has a singleton subtype of PnmlType.\n\n3 branches of pntd based on number system\n\ncore uses integers\nhigh-level uses terms of many-sorted algebra\ncontinuous/hybrid uses floating point\n\nDefault place markings and arc inscriptions are different for the three.","category":"section"},{"location":"structure/traits/#isdiscrete","page":"Traits","title":"isdiscrete","text":"list_type(PNML.isdiscrete)","category":"section"},{"location":"structure/traits/#iscontinuous","page":"Traits","title":"iscontinuous","text":"list_type(PNML.iscontinuous)","category":"section"},{"location":"structure/traits/#ishighlevel","page":"Traits","title":"ishighlevel","text":"list_type(PNML.ishighlevel)","category":"section"},{"location":"examples/","page":"-","title":"-","text":"Pages = [\"examples.md\"]\nDepth = 5","category":"section"},{"location":"examples/#Lotka-Volterra","page":"-","title":"Lotka-Volterra","text":"","category":"section"},{"location":"examples/#Petri.jl-Starting-Point","page":"-","title":"Petri.jl Starting Point","text":"https://github.com/mehalter/Petri.jl","category":"section"},{"location":"examples/#Example-2","page":"-","title":"Example 2","text":"","category":"section"},{"location":"examples/#Stuff-for-example-2","page":"-","title":"Stuff for example 2","text":"","category":"section"},{"location":"#PNML.jl","page":"Petri Net Markup Language","title":"PNML.jl","text":"Documentation for the GitHub PNML.jl repository. Which defines a Julia module named PNML. Which handles an XML markup language with the acronym 'PNML' – Petri Net Markup Language.\n\nusing Markdown, Pkg, Dates, InteractiveUtils\n\nfunction print_dep_version(depname)\n\tdeps = values(Pkg.dependencies())\n\tversion = first(d for d in deps if d.name == depname).version\n\t\"$depname: v$version\"\nend\n\nMarkdown.parse(\"\"\"\n\tThese docs were generated at $(now()) on $(gethostname()) using:\n\t\t- $(print_dep_version(\"PNML\"))\n   \"\"\")\n\nusing InteractiveUtils; # hide\nversioninfo()\n\nhttp://www.pnml.org\n\nhas publications and tutorials covering PNML at various points in its evolution.\nhas links to a series of ISO/IEC 15909 standards relating to PNML.\nis the cannonical site for the meta-models, RELAX-NG XML schemas that define the grammar of several Petri Net Type Defintions (pntd), including:\n\n  - PT Net (Place/Transition Net)\n  - Symmetric Net\n\nand more: examples, meta-models in EMF, java-based framework\n\nThere are 2 flavors currently covered by PNML meta-models:\n\ninteger-valued, where tokens have collective identities.\nHigh-level, where tokens have individual identities using a many-sorted algebra.\n\nThe people behind PNML, and as stated in 15909-2, are of the Model Driven Software Engineering camp and have chosen Java, Eclipse and its modeling framework (EMF).\n\nSee A primer on the Petri Net Markup Language and ISO/IEC 15909-2(pdf) for more details. The rest of this page will hopefully make more sense if you are familiar with the primer's contents. Use the RelaxNG Schema as definitive like the 'primer' counsels.\n\nSee Extending PNML Scope: a Framework to Combine Petri Nets Types for concepts relevant to ISO/IEC 15909-3.\n\nNote that the pnml XML file is the working intermediate representation of a suite of tools that use RelaxNG and Schematron for validation of the interchange file's content.","category":"section"},{"location":"#Interoperability","page":"Petri Net Markup Language","title":"Interoperability","text":"Petri Net Type Definition schema files (pntd) are defined using RELAX-NG XML Schema files (rng). Petri Net Markup Language files (pnml) are intended to be validated against a pntd schema.\n\nFor interchange of pnml between toolinfos it should be enough to support the same pntd schema.\n\nNote that ISO released part 3 of the PNML standard covering extensions and structuring mechanisms in 2021. And some http://www.pnml.org files address these extensions. Including Extending PNML Scope: a Framework to Combine Petri Nets Types.\n\nIt is possible to create a non-standard pntd. And more will be standardized, either formally or informally. Non-standard mostly means that the interchangibility is restricted.\n\nSince validation is not a goal of PNML.jl the uri is treated as a string. So non-standard pntds can be used for the URI of an XML net tag's type attribute. Notably pnmlcore and nonstandard are mapped to PnmlCoreNet.\n\nPnmlCoreNet is the minimum level of meaning that any pnml file can hold.\n\nFurther parsing of labels is specialized upon subtypes of PNet.AbstractPetriNet. See Traits for more details.\n\nIf you want interchangability of pnml models, you will have to stick to the standard pnml pntds. The High Level Petri Net, even when restricted to symmetricnet.pntd, is very expressive. Even the base pnmlcore.pntd is useful.","category":"section"},{"location":"#Why-no-Schema-Verification","page":"Petri Net Markup Language","title":"Why no Schema Verification","text":"Within PNML.jl no schema-level validation is done.\n\nNote that, depending on context, 'PNML' may refer to either the markup language or the Julia code in the following.\n\nIn is allowed by the PNML standard to omit validation with the presumption that some specialized, external tool can be applied, thus allowing the file format to be used for inter-tool communication with lower overhead in each tool.\n\nAlso omiting pntd validation allows \"duck typing\" of Petri Nets built upon the PNML intermediate representration.\n\nOf some note it that PNML.jl extends PNML. These, non-standard pntd do not (yet) have a schema written. See ContinuousNet.","category":"section"},{"location":"#References","page":"Petri Net Markup Language","title":"References","text":"www.pnml.org\n\nL.M. Hillah and E. Kindler and F. Kordon and L. Petrucci and N. Trèves: A primer on the Petri Net Markup Language and ISO/IEC 15909-2 Petri Net Newsletter 76:9–28, October 2009 (originally presented at the 10th International workshop on Practical Use of Colored Petri Nets and the CPN Tools – CPN'09).\n\nISO High-level Petri nets Standard in multiple parts:\n\nISO/IEC 15909-1:2019 — Part 1: Concepts, definitions and graphical notation\nISO/IEC 15909-2:2011 — Part 2: Transfer format\nISO/IEC 15909-2:2011/Cor 1:2013 — Part 2: Transfer format — TECHNICAL CORRIGENDUM 1\nISO/IEC 15909-3:2021 — Part 3: Extensions and structuring mechanisms\n\nTowards a Standard for Modular Petri Nets:A Formalisation expounds on structuring mechanism (modules and sort generators) in 15909-3. Might need to consult this to understand ISO 15909-3. From Proc. 30th Int. Conf. Application and Theory of Petri Nets (PetriNets’2009), Paris, France, June 2009, volume 5606 of Lecture Notes in Computer Science. Springer, 2009.\n\nExtending PNML Scope: a Framework to Combine Petri Nets Types L.M. Hillah and F. Kordon and C. Lakos and L. Petrucci, Transactions on Petri Nets and Other Models of Concurrency, Springer 2012, LNCS 7400 (VI), pp.46-70. Includes bits of UML2 for 2nd edition of ISO 15909-1 and 15909-3: priority nets, time nets (TPN), special arcs. Does not address FIFO Places, or structure/modules from part 3. Someday a 2nd edition of ISO 15909-2 will subsume this work and cover FIFO places and modular nets.\n\nOperational PNML (OPNML) Operational is an extension to PNML. Operational PNML: Towards a PNML Support for Model Construction and Modification Gomes, Luis, and Joao Paulo Barros. Operational PNML: Towards a PNML Support for Model Construction and Modification. 2004. Does not seem to still be available. http://gres.uninova.pt/opnml/index.html does not have any live links. Does not have ISO 15909 as a reference. Has references to papers from pre-ISO 15909 covering modular Petri nets.\n\nnLab a wiki for collaborative work on Mathematics, Physics, and Philosophy:\n\nmultisorted algebraic theories\nPetri net\n\nWell-formed Petri nets \"...only a limited set of operators are available (identify, broadcast, successor and predecessor functions are allowed on circular finite types)\". Restrictions that differentiates SymmetricNet and HLPNG.\n\nJohn Baez, Fabrizio Genovese, Jade Master, Michael Shulman, Categories of Nets, arXiv:2101.04238\n\nR.J. van Glabbeek (2005): The Individual and Collective Token Interpretations of Petri Nets. In M. Abadi & L. de Alfaro, editors: Proceedings 16th International Conference on Concurrency Theory, CONCUR’05, San Francisco, USA, LNCS 3653, Springer, pp. 323-337.\n\nPNML Framework \"... a free and open-source prototype implementation of ISO/IEC-15909, International Standard on Petri Nets\". The framework is an Eclipse/Java construction using Eclipse Public License 1.0. Uses 'Eclipse` Model-Driven Engineering EMF to provide generated APIs.\n\ngithub.com/lip6/pnmlframework hosts the source code of PNML Framework. See apidocs and XMLTestFilesRepository.\n\ngithub.com/loig/pinimili Go language.\n\ngithub.com/stackdump/gopetri Go language.\n\nPetri net visualisator written in Go. Go language. Non-standard pnml xml syntax.\n\nLTSmin \"a full (LTL/CTL/μ-calculus) model checker\". C/M4/C++ language.\n\ngithub.com/daemontus/pnml-parser Rust language.\n\nBrowsable PNML Grammar from Grammar Zoo  For Symmetric Nets.\n\nAutomated Code Optimization with E-Graphs: Alessandro Cheli's Thesis on Metatheory.jl.\n\nePNK a platform for developing Petri net tools based on the PNML transfer format is another Eclipse/Java EMF thing. Implements more complicated PNML than used in MCC. By some of the creators of PNML. github has the source, documentation, examples.\n\n\"The Model Checking Contest (MCC) has two different parts: the Call for Models, which gathers Petri net models proposed by the scientific community, and the Call for Tools, which benchmarks verification tools developed within the scientific community.\" Each year new models are added to the contest.\n\nNested-Unit Petri Nets (NUPN) an \"extension of P/T nets\" used by MCC:\n\nexistence of units has no effect on the transition firing rules\npartitions the set of places\nif a net is unit-safe, units express linear inequality invariants on reachable markings, and tools may take advantage of such invariants to perform logarithmic reductions in the size of marking encodings.\n\n\"Petri net model using AlgebraicPetri.jl Micah Halter, 2021-03-26\"\n\nJohn Baez, Xiaoyan Li, Sophie Libkind, Nathaniel D. Osgood and Eric Redekopp, A categorical framework for modeling with stock and flow diagrams, in Mathematics of Public Health: Mathematical Modelling from the Next Generation, eds. Jummy David and Jianhong Wu, Springer, 2023, pp. 175-207.\n\nLibkind, S., Baas, A., Halter, M., Patterson, E., Fairbanks, J.: An algebraic framework for structured epidemic modeling. Phil. Trans. R. Soc. A.3802021030920210309. (2022).\n\nPatterson, E., Lynch, O., Fairbanks, J.: Categorical data structures for technical computing. Compositionality 4(2) (2022). DOI 10.32408/compositionality-4-5.\n\nJoachim Kock. Whole-grain Petri nets and processes\n\nContexts.jl is not registered. C. Gutsche, S. Götz, V. Prokopets and U. Aßmann, \"Context-Role Oriented Programming in Julia: Advancing Swarm Programming,\" 2025 IEEE/ACM 20th Symposium on Software Engineering for Adaptive and Self-Managing Systems (SEAMS), Ottawa, ON, Canada, 2025, pp. 85-95, doi: 10.1109/SEAMS66627.2025.00017. keywords: {Performance evaluation;Surveillance;Collaboration;Programming;Software;Hardware;Multi-robot systems;Drones;Software engineering;Software development management;Roles;Teams;Contexts;Swarms;Drones;SelfAdaptive Systems;Julia}. Does not use an input file.\n\nDistributedWorkflows.jl Does not use a Petri net input file. Constructs one internally? Uses GPI-Space where Petri nets are represented in a XML format called XPNET that embedds C++ code fragments.\n\nBioSimulator.jl uses a simple internal species-reaction Petri net.\n\nDialectica Petri nets  Finally we would like to investigate whether we could code our nets using Catlab https://github.com/AlgebraicJulia/Catlab.jl. Linear Logic Flavoured Composition of Petri Nets.\n\nSnoopy\n\nPNML ⇒ QPN, QPNc\nPNML support, except export of QPNc in Snoopy to High-Level Petri Nets in PNML (upcomming)\nplace/transition Petri net - QPN\ncolored qualitative Petri net - QPNc\nextended Petri net (read / inhibitor / equal / reset / marking-dependent arcs) - XPN","category":"section"},{"location":"subpackages/#Sub-packages-of-PNML","page":"Sub-packages of PNML","title":"Sub-packages of PNML","text":"","category":"section"},{"location":"structure/parser/#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"structure/parser/#Initial-Markings","page":"Parser","title":"Initial Markings","text":"Parsed into PnmlExpr expressions in a Place. Place/Transition Petri net and Continuous net markings are treated as <numberconstant>. Allows same machanism to be used for all flavors of nets after parsing.\n\nMarking is a ground term and is used to give a Petri net marking vector an initial value.","category":"section"},{"location":"structure/parser/#Unclaimed-Labels","page":"Parser","title":"Unclaimed Labels","text":"XML tags that are not 'claimed' are recursively parsed into a XmlDictType by Parser.xmldict.\n\nSee AnyElement, Parser.anyelement, PnmlLabel","category":"section"},{"location":"structure/parser/#AnyElement","page":"Parser","title":"AnyElement","text":"Main use case if for ToolInfo content. The standard allows any well-formed XML. Only the intended tool needs to understand the content.\n\nTODO Implement a ToolInfo for PNML.jl extensions.","category":"section"},{"location":"structure/parser/#PnmlLabel","page":"Parser","title":"PnmlLabel","text":"Applies label semantics to a XmlDictType. Used for not-yet-implemented labels. Many of the labels used for high-level many-sorted algebra have not been implemented.\n\nSee rate_value for a use case.","category":"section"},{"location":"structure/parser/#Structure-of-High-level-Annotation","page":"Parser","title":"Structure of High-level Annotation","text":"Schematic of annotation label:\n\ntext\nstructure\nTerm\nsubterm\nTerm (its alternating subterm Term all the way down)\ntoolspecific\ngraphics","category":"section"}]
}

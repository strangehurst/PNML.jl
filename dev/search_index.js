var documenterSearchIndex = {"docs":
[{"location":"defaults/#Default-Values","page":"Default Values","title":"Default Values","text":"","category":"section"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"ISO/IEC 15909-2 defines the Petri Net Modeling Language (PNML) as integer based. There are many items in the XML that are permitted to be missing and a defaut value is assumed. Examples are place initial marking, arc inscription, transition condition, graphics data.","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"place initial marking is assumed to be empty, i. e. 0.\narc inscription is assumed to be 1.\ntransition condition is assumed to be true\ngraphics data, e.g. token position, line width, are chosen by application","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"The specification and the RelaxNG Schemas state 'natural numbers' and 'non-zero natural numbers'. I choose to also allow continuous values by trying to parse the XML string first as 'Int', and then as 'Float64'.  Allows for nonstandard continuous and hybrid valued Petri Nets. Makes generating default values more interesting.","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"There are multiple kinds of nets supported by PNML.jl differing by (among other properties) the kind on number they use:","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"discrete,\ncontinuous,\nand multi-sorted algebra","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"See PnmlType - Petri Net Type Definition for the full hierarchy.","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"This means there are at least 3 sets of default value types. We use the pntd","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"A consequence is that the default value's type ripples through the type system.","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"using AbstractTrees, PNML, InteractiveUtils, Markdown","category":"page"},{"location":"defaults/#Methods","page":"Default Values","title":"Methods","text":"","category":"section"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_marking","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"methods(PNML.default_marking) # hide","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_inscription","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"methods(PNML.default_inscription) # hide","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_condition","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"methods(PNML.default_condition) # hide","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_sort","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"methods(PNML.default_sort) # hide","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_term","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"methods(PNML.default_term) # hide","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_one_term","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"methods(PNML.default_one_term) # hide","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_zero_term","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"methods(PNML.default_zero_term) # hide","category":"page"},{"location":"defaults/#Examples","page":"Default Values","title":"Examples","text":"","category":"section"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_one_term, PNML.default_zero_term","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"julia> c = default_condition(PnmlCoreNet())\nCondition(nothing, true, )\n\njulia> c()\ntrue\n\njulia> c = default_condition(ContinuousNet())\nCondition(nothing, true, )\n\njulia> c = default_condition(HLCoreNet())\nCondition(nothing, Term(:empty, (value = true,)), )","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"julia> i = default_inscription(PnmlCoreNet())\nInscription(1, )\n\njulia> i = default_inscription(ContinuousNet())\nInscription(1.0, )\n\njulia> i = default_inscription(HLCoreNet())\nHLInscription(\"default\", Term(:empty, (value = 1,)), )\n\njulia> i()\n1","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"julia> m = default_marking(PnmlCoreNet())\nMarking(0, )\n\njulia> m()\n0\n\njulia> m = default_marking(ContinuousNet())\nMarking(0.0, )\n\njulia> m()\n0.0\n\njulia> m = default_marking(HLCoreNet())\nHLMarking(nothing, Term(:empty, (value = 0,)), )\n\njulia> m()\n0","category":"page"},{"location":"API/library/","page":"API","title":"API","text":"CurrentModule = PNML","category":"page"},{"location":"API/library/","page":"API","title":"API","text":"Pages = [\"library.md\"]\nDepth = 2","category":"page"},{"location":"API/library/#PNML-Reference","page":"API","title":"PNML Reference","text":"","category":"section"},{"location":"API/library/","page":"API","title":"API","text":"Modules = [PNML]","category":"page"},{"location":"API/library/#PNML.PNML","page":"API","title":"PNML.PNML","text":"PNML\n\nPetri Net Markup Language, is an XML-based format. PNML.jl reads a pnml model and emits an intermediate representation (IR).\n\nThe intermediate representation (IR) represents the XML tree via julia data structures: dictionaries, NamedTuples, LabelledArrays, strings, numbers, objects, vectors. The exact mixture changes as the project continues.\n\nThe tags of the XML are used as keys and names as much as possible.\n\nWhat is accepted as values is ~~often~~ usually a superset of what a given pntd schema specifies. This can be thought of as duck-typing. Conforming to the pntd is not the role of the IR. \n\nThe pnml specification has layers. The core layer is useful and extendable. The standard defines extensions of the core for place-transition petri nets (integers) and high-level petri net graphs (many-sorted algebra). This package family adds non-standard continuous net (float64) support.  Note that there is no RelaxNG schema file for these extensions \n\nOn top of the IR is (will be) implemented Petri Net adaptions and interpertations. This is the level that pntd conformance can be imposed. Adaption to julia packages for graphs, agents, and composing into the greater hive-mind. \n\nFeatures that have not been started:\n\nWrite pnml file\nUpdate pnml model\nCreate pnml model\nGraphs.jl\nSymbolics support for HLPNG (many-sorted algebra)\n\nFeatures that are not complete:\n\nHLPNG - many-sorted algebras are complex. Will build other infrastructure...\npntd specialize\ntoolspecific usage example\n\nFeatures that work (perhaps in need of attention as changes are made):\n\ncontinuous petri net (examples/lotka-volterra.jl)\npnml core: can read & print all Model Checking Contest (MCC) models\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)\n\nImports\n\nAbstractTrees\nAccessors\nAutoHashEquals\nBase\nCore\nDocStringExtensions\nEzXML\nFunctionWrappers\nLabelledArrays\nNamedTupleTools\nPNML.PnmlIDRegistrys\nPNML.PnmlTypeDefs\nPreferences\nPrettyPrinting\nReexport\nSnoopPrecompile\n\nExports\n\nAbstractContinuousNet\nAbstractHLCore\nAbstractPnmlCore\nCONFIG\nContinuousNet\nHLCoreNet\nHLPNG\nMalformedException\nMissingIDException\nOpenNet\nPTNet\nPT_HLPNG\nPnmlCoreNet\nPnmlException\nPnmlIDRegistry\nPnmlIDRegistrys\nPnmlType\nPnmlTypeDefs\nStochasticNet\nSymmetricNet\nTimedNet\niscontinuous\nisdiscrete\nishighlevel\nisregistered_id\nparse_file\nparse_node\nparse_pnml\nparse_str\npnmltype\npntd_symbol\nregister_id!\nregistry\n@xml_str\nxmlroot\n\n\n\n\n\n","category":"module"},{"location":"API/library/#PNML.CONFIG","page":"API","title":"PNML.CONFIG","text":"PNML.CONFIG\n\nOptions\n\nindent_width::Int: Indention of nested lines. Defaults to 4.\nwarn_on_namespace::Bool: There are pnml files that break the rules &\n\ndo not have an xml namespace. Initial state of toggle defaults to true.\n\ntext_element_optional::Bool: There are pnml files that break the rules & do not have <text> elements.\n\nInitial state of warning toggle defaults to true.\n\nwarn_on_fixup::Bool: When an missing value is replaced by a default value,\n\nissue a warning. Initial state of \"warnonfixup\" toggle defaults to false.\n\nwarn_on_unclaimed::Bool: Issue warning when PNML label does not have a parser defined.\n\nWhile allowed, there will be code required to do anything useful with the label. Initial state of \"warn\" toggle defaults to false.\n\nverbose::Bool: Print information as runs.  Initial state of \"verbose\" toggle.\n\nDefaults to false.\n\n\n\n\n\n","category":"constant"},{"location":"API/library/#PNML.Maybe","page":"API","title":"PNML.Maybe","text":"Alias for union of type T or Nothing.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.pnml_ns","page":"API","title":"PNML.pnml_ns","text":"Namespace expected for pnml XML.\n\n\n\n\n\n","category":"constant"},{"location":"API/library/#PNML.tagmap","page":"API","title":"PNML.tagmap","text":"Map XML <tag> names to parser functions named \"parse_tag\". Allows associative lookup of parser using ideas from Tim Holy's MathML package.\n\n\n\n\n\n","category":"constant"},{"location":"API/library/#PNML.AbstractDeclaration","page":"API","title":"PNML.AbstractDeclaration","text":"abstract type AbstractDeclaration <: PNML.HLAnnotation\n\nDeclarations are the core of high-level Petri Net. They define objects/names that are used for conditions, inscriptions, markings. They are attached to PNML nets and pages.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.AbstractLabel","page":"API","title":"PNML.AbstractLabel","text":"abstract type AbstractLabel\n\nLabels are attached to the Petri Net Graph objects. See AbstractPnmlObject.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.AbstractPetriNet","page":"API","title":"PNML.AbstractPetriNet","text":"abstract type AbstractPetriNet{PNTD<:PnmlType}\n\nTop-level of a single network in a pnml model that is some flavor of Petri Net. Note that pnml can represent nets that are not Petri Nets.\n\nHere is where specialization and restriction are applied to achive Proper Petri Behavior.\n\nSee PnmlModel, PnmlType.\n\nExtended\n\nAdditional constrants can be imposed. We want to run under the motto: \"syntax is not semantics, quack\".\n\nSince a PNML.Document model can contain multiple networks it is possible that a higher-level will create multiple AbstractPetriNet instances, each a different type.\n\nMultiple Pages can (are permitted to) be merged into one page by flatten_pages! without losing any Petri Net semantics.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.AbstractPnmlNode","page":"API","title":"PNML.AbstractPnmlNode","text":"abstract type AbstractPnmlNode{PNTD} <: PNML.AbstractPnmlObject{PNTD}\n\nPetri Net Graph nodes are Place, Transition. They are the source or target of an Arc\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.AbstractPnmlObject","page":"API","title":"PNML.AbstractPnmlObject","text":"abstract type AbstractPnmlObject{PNTD<:PnmlType}\n\nObjects of a Petri Net Graph are pages, arcs, nodes.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.AbstractPnmlTool","page":"API","title":"PNML.AbstractPnmlTool","text":"abstract type AbstractPnmlTool\n\nTool specific objects can be attached to AbstractPnmlObjects and AbstractLabels subtypes.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.AbstractTerm","page":"API","title":"PNML.AbstractTerm","text":"abstract type AbstractTerm\n\nTerms are part of the multi-sorted algebra that is part of High-Level Petri Net markings, inscriptions and conditions.\n\nTerm is an abstract type in the pnml specification, not having any matching XML element. Concrete Terms are found within the <structure> element of a HLAnnotation.\n\nSee also Declaration, SortType, AbstractDeclaration.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Annotation","page":"API","title":"PNML.Annotation","text":"abstract type Annotation <: PNML.AbstractLabel\n\nLabel that may be displayed. Differs from an Attribute Label by possibly having a Graphics field.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.AnyElement","page":"API","title":"PNML.AnyElement","text":"struct AnyElement\n\ntag::Symbol\nelements::NamedTuple\nxml::EzXML.Node\n\nWrap NamedTuple holding well-formed XML. See also ToolInfo and PnmlLabel.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Arc","page":"API","title":"PNML.Arc","text":"Edge of a Petri Net Markup Language graph that connects place and transition.\n\nmutable struct Arc{PNTD, I} <: PNML.AbstractPnmlObject{PNTD}\n\npntd::Any\nid::Symbol\nsource::Symbol\ntarget::Symbol\ninscription::Any\nname::Union{Nothing, PNML.Name}\ncom::PNML.ObjectCommon\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.BuiltInSort","page":"API","title":"PNML.BuiltInSort","text":"struct BuiltInSort <: PNML.AbstractSort\n\nWrap a AnyElement. Use until specialized/cooked.\n\nFrom the 'primer': built-in sorts of Symmetric Nets are the following:   Booleans, range of integers, finite enumerations, cyclic enumerations and dots\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Condition","page":"API","title":"PNML.Condition","text":"mutable struct Condition{PNTD, T} <: PNML.Annotation\n\npntd::Any\ntext::Union{Nothing, String}\nvalue::Any\ncom::PNML.ObjectCommon\n\nLabel of a Transition that determines when the transition fires.\n\nExamples\n\njulia> c = Condition(PnmlCoreNet())\nCondition(nothing, true, )\n\njulia> c()\ntrue\n\njulia> c = Condition(PnmlCoreNet(), false)\nCondition(nothing, false, )\n\njulia> c()\nfalse\n\njulia> c = Condition(PnmlCoreNet(), \"xx\", false)\nCondition(\"xx\", false, )\n\njulia> c()\nfalse\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Condition-Tuple{}","page":"API","title":"PNML.Condition","text":"Evaluate a Condition instance.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.Coordinate","page":"API","title":"PNML.Coordinate","text":"Cartesian Coordinate.\n\nstruct Coordinate{T}\n\nx::Any\ny::Any\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Declaration","page":"API","title":"PNML.Declaration","text":"struct Declaration <: PNML.Annotation\n\ndeclarations::Vector{Any}\ncom::PNML.ObjectCommon\nxml::Union{Nothing, EzXML.Node}\n\nLabel of a net or page that holds zero or more declarations. The declarations are used to define parts of the many-sorted algebra used by High-Level Petri Nets. Other PNTDs may introduce non-standard uses for declarations.\n\nNotes\n\ndeclarations is implemented as a collection of Any We can use infrastructure implemented for HL nets to provide nonstandard extensions.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Fill","page":"API","title":"PNML.Fill","text":"Fill attributes as strings.\n\nstruct Fill\n\ncolor::Union{Nothing, String}\nimage::Union{Nothing, String}\ngradient_color::Union{Nothing, String}\ngradient_rotation::Union{Nothing, String}\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Font","page":"API","title":"PNML.Font","text":"Font attributes as strings.\n\nstruct Font\n\nfamily::Union{Nothing, String}\nstyle::Union{Nothing, String}\nweight::Union{Nothing, String}\nsize::Union{Nothing, String}\nalign::Union{Nothing, String}\nrotation::Union{Nothing, String}\ndecoration::Union{Nothing, String}\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Graphics","page":"API","title":"PNML.Graphics","text":"PNML Graphics can be attached to many parts of PNML models.\n\nstruct Graphics{COORD}\n\ndimension::Any\nfill::Union{Nothing, PNML.Fill}\nfont::Union{Nothing, PNML.Font}\nline::Union{Nothing, PNML.Line}\noffset::Any\npositions::Vector\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.HLAnnotation","page":"API","title":"PNML.HLAnnotation","text":"abstract type HLAnnotation <: PNML.AbstractLabel\n\nAnnotation label that uses <text> and <structure>.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.HLInscription","page":"API","title":"PNML.HLInscription","text":"struct HLInscription{T<:PNML.Term} <: PNML.HLAnnotation\n\ntext::Union{Nothing, String}\nterm::PNML.Term\ncom::PNML.ObjectCommon\n\nLabels an Arc. The <structure> element is a term in a many-sorted algebra. The term field\n\nExamples\n\njulia> i2 = HLInscription(Term(:term, (; :value=>3)))\nHLInscription(nothing, Term(:term, (value = 3,)), )\n\njulia> i2()\n3\n\njulia> i3 = HLInscription(\"text\", Term())\nHLInscription(\"text\", Term(:empty, ()), )\n\njulia> i3()\n1\n\njulia> i4 = HLInscription(\"text\", Term(:term, (; :value=>3)))\nHLInscription(\"text\", Term(:term, (value = 3,)), )\n\njulia> i4()\n3\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.HLInscription-Tuple{}","page":"API","title":"PNML.HLInscription","text":"Evaluate a HLInscription. Returns a value of the same sort as TBD.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.HLLabel","page":"API","title":"PNML.HLLabel","text":"struct HLLabel{PNTD} <: PNML.HLAnnotation\n\ntext::Union{Nothing, String}\nstructure::Union{Nothing, PNML.AnyElement}\ncom::PNML.ObjectCommon\nxml::EzXML.Node\n\nHigh-level pnml labels are expected to have <text> and <structure> elements. This concrete type is for \"unclaimed\" labels in a high-level petri net.\n\nSome \"claimed\" HLAnnotation labels are Condition, Declaration, HLMarking, HLInscription.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.HLMarking","page":"API","title":"PNML.HLMarking","text":"Label of a Place in a High-level Petri Net Graph. See AbstractHLCore, Term.\n\nMultisets of a sort.\n\nstruct HLMarking{T<:PNML.Term} <: PNML.HLAnnotation\n\ntext::Union{Nothing, String}\nterm::PNML.Term\ncom::PNML.ObjectCommon\n\nExamples\n\njulia> m = HLMarking(\"the text\", Term(:term, (; :value => 3)))\nHLMarking(\"the text\", Term(:term, (value = 3,)), )\n\njulia> m()\n3\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.HLMarking-Tuple{}","page":"API","title":"PNML.HLMarking","text":"HLMarking()\n\n\nEvaluate a HLMarking instance by returning its term.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.HLPetriNet","page":"API","title":"PNML.HLPetriNet","text":"Wrap a single pnml net. Presumes that the net does not need to be flattened as all content is in first page.\n\nstruct HLPetriNet{PNTD} <: PNML.AbstractPetriNet{PNTD}\n\nnet::PNML.PnmlNet{PNTD} where PNTD\n\nDetails\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.HLPetriNet-Tuple{AbstractString}","page":"API","title":"PNML.HLPetriNet","text":"Construct from string of valid pnml XML, using the first network in model.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.HarvestAny","page":"API","title":"PNML.HarvestAny","text":"Wrap a function and two of its arguments.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Inscription","page":"API","title":"PNML.Inscription","text":"struct Inscription{T<:Union{Float64, Int64}} <: PNML.Annotation\n\nvalue::Union{Float64, Int64}\ncom::PNML.ObjectCommon\n\nLabels an Arc.\n\nExamples\n\njulia> i = Inscription(3)\nInscription(3, )\n\njulia> i()\n3\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Inscription-Tuple{}","page":"API","title":"PNML.Inscription","text":"Evaluate an Inscription's value.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.Line","page":"API","title":"PNML.Line","text":"Line attributes as strings.\n\nstruct Line\n\ncolor::Union{Nothing, String}\nshape::Union{Nothing, String}\nstyle::Union{Nothing, String}\nwidth::Union{Nothing, String}\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.MalformedException","page":"API","title":"PNML.MalformedException","text":"struct MalformedException <: PnmlException\n\nmsg::String\nnode::EzXML.Node\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Marking","page":"API","title":"PNML.Marking","text":"Number-valued label of Place. See PTNet, ContinuousNet.\n\nIs a functor that returns the value.\n\nstruct Marking{N<:Union{Float64, Int64}} <: PNML.Annotation\n\nvalue::Union{Float64, Int64}\ncom::PNML.ObjectCommon\n\nExamples\n\njulia> m = Marking()\nMarking(0, )\n\njulia> m()\n0\n\njulia> m = Marking(1)\nMarking(1, )\n\njulia> m()\n1\n\njulia> m = Marking(12.34)\nMarking(12.34, )\n\njulia> m()\n12.34\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Marking-Tuple{}","page":"API","title":"PNML.Marking","text":"Marking() -> PNML.Marking{Int64}\n\n\nEvaluate a Marking instance by returning its value.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.MissingIDException","page":"API","title":"PNML.MissingIDException","text":"struct MissingIDException <: PnmlException\n\nmsg::String\nnode::EzXML.Node\n\nUse exception to allow dispatch and additional data presentation to user.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.MultisetSort","page":"API","title":"PNML.MultisetSort","text":"struct MultisetSort <: PNML.AbstractSort\n\nWrap a AnyElement. Use until specialized/cooked.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Name","page":"API","title":"PNML.Name","text":"struct Name <: PNML.Annotation\n\ntext::String\ngraphics::Union{Nothing, PNML.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\n\nName is for display, possibly in a tool specific way.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.NamedOperator","page":"API","title":"PNML.NamedOperator","text":"struct NamedOperator{V, T} <: PNML.OperatorDeclaration\n\nid::Symbol\nname::String\nparameter::Vector\ndef::Any\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.NamedSort","page":"API","title":"PNML.NamedSort","text":"struct NamedSort{S} <: PNML.SortDeclaration\n\nid::Symbol\nname::String\ndef::Any\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.ObjectCommon","page":"API","title":"PNML.ObjectCommon","text":"struct ObjectCommon\n\ngraphics::Union{Nothing, PNML.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\nlabels::Union{Nothing, Vector{PNML.PnmlLabel}}\n\nCommon infrastructure shared by PNML objects and labels. Some optional incidental bits are shared by most PNML objects are also collected here.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Page","page":"API","title":"PNML.Page","text":"mutable struct Page{PNTD<:PnmlType, M, I, C, S} <: PNML.AbstractPnmlObject{PNTD<:PnmlType}\n\npntd::PnmlType\nid::Symbol\ndeclaration::PNML.Declaration\nname::Union{Nothing, PNML.Name}\ncom::PNML.ObjectCommon\npagedict::OrderedCollections.OrderedDict{Symbol, PNML.Page{PNTD}} where PNTD<:PnmlType\nnetdata::PNML.PnmlNetData\nnetsets::PNML.PnmlNetKeys\n\nContain all places, transitions & arcs. Pages are for visual presentation. There must be at least 1 Page for a valid pnml model.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Partition","page":"API","title":"PNML.Partition","text":"struct Partition{S, PE} <: PNML.SortDeclaration\n\nid::Symbol\nname::String\ndef::Any\nelement::Any\n\nUser-declared sort.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Place","page":"API","title":"PNML.Place","text":"struct Place{PNTD, M, S} <: PNML.AbstractPnmlNode{PNTD}\n\npntd::Any\nid::Symbol\nmarking::Any\ninitialMarking::Any\nsorttype::Any\nname::Union{Nothing, PNML.Name}\ncom::PNML.ObjectCommon\n\nPlace node of a Petri Net Markup Language graph.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlException","page":"API","title":"PNML.PnmlException","text":"abstract type PnmlException <: Exception\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlLabel","page":"API","title":"PNML.PnmlLabel","text":"struct PnmlLabel <: PNML.Annotation\n\ntag::Symbol\nelements::NamedTuple\nxml::EzXML.Node\n\nWrap a NamedTuple holding as a pnml label. Use the XML tag as identifier.\n\nUsed for \"unclaimed\" labels that do not have, or we choose not to use, a dedicated parse method. Claimed labels will have a type/parser defined to make use of the structure defined by the pntd schema.\n\nSee also AnyElement. The difference is that AnyElement allows any well-formed XML, while PnmlLabel is restricted to PNML Labels (with extensions in PNML.jl).\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlModel","page":"API","title":"PNML.PnmlModel","text":"struct PnmlModel\n\nnets::Tuple{Vararg{PNML.PnmlNet}}\nnamespace::String\nreg::PnmlIDRegistry\nxml::EzXML.Node\n\nOne or more Petri Nets and an ID Registry shared by all nets.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlNet","page":"API","title":"PNML.PnmlNet","text":"mutable struct PnmlNet{PNTD<:PnmlType, M, I, C, S}\n\ntype::PnmlType\nid::Symbol\npagedict::OrderedCollections.OrderedDict{Symbol, PNML.Page{PNTD, M, I, C, S}} where {PNTD<:PnmlType, M, I, C, S}\nnetdata::PNML.PnmlNetData\npage_set::OrderedCollections.OrderedSet{Symbol}\ndeclaration::PNML.Declaration\nname::Union{Nothing, PNML.Name}\ncom::PNML.ObjectCommon\nxml::EzXML.Node\n\nOne Petri Net of a PNML model.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlNetData","page":"API","title":"PNML.PnmlNetData","text":"Collect each of the PnmlNodess & Arcs of a Petri Net Graph into one collection. Accessed via pnml ID key or iterate over values of an OrderedDict.\n\nIn the 'pnml' specification there is a Page structure that can be removed by flatten_pages!, removing some display-related information, leaving a functional Petri Net Graph as described in this structure. It is intended to be a per-PnmlNet database that is mutated as each page is parsed.\n\nSee PnmlNetKeys for page-level pnml ID of \"owners\" net data.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlNetKeys","page":"API","title":"PNML.PnmlNetKeys","text":"ID sets for pages, places, arcs, et al. start as empty sets.\n\nThere is one collection of Pages for each PnmlNet that is not part of PnmlNetData: pagedict. It is accompanied by a tree of ordered sets of page ID symbols: page_set.\n\n1st wave: The PnmlNet and each Page use these key sets to represent their page-tree children.\n\nEach Page \"owns\" the objects it places into the PnmlNetData database. Allows for interactive display (NOT IMPLEMENTD) and testing.\n\nAccess to subtrees may be useful, so the page-tree-node becomes a per-page structure of OrderedSets of pnml IDs for each \"owned\" AbstractPnmlObject\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.ProductSort","page":"API","title":"PNML.ProductSort","text":"struct ProductSort <: PNML.AbstractSort\n\nWrap a AnyElement. Use until specialized/cooked. Should contain an ordered collection of sorts.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.RefPlace","page":"API","title":"PNML.RefPlace","text":"Reference Place node of a Petri Net Markup Language graph. For connections between pages.\n\nstruct RefPlace{PNTD} <: PNML.ReferenceNode{PNTD}\n\npntd::Any\nid::Symbol\nref::Symbol\nname::Union{Nothing, PNML.Name}\ncom::PNML.ObjectCommon\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.RefTransition","page":"API","title":"PNML.RefTransition","text":"Refrence Transition node of a Petri Net Markup Language graph. For connections between pages.\n\nstruct RefTransition{PNTD} <: PNML.ReferenceNode{PNTD}\n\npntd::Any\nid::Symbol\nref::Symbol\nname::Union{Nothing, PNML.Name}\ncom::PNML.ObjectCommon\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.ReferenceNode","page":"API","title":"PNML.ReferenceNode","text":"abstract type ReferenceNode{PNTD} <: PNML.AbstractPnmlNode{PNTD}\n\nFor common behavior shared by RefPlace, RefTransition used to connect Page together. Adds a ref field to a node.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.SimpleNet","page":"API","title":"PNML.SimpleNet","text":"struct SimpleNet{PNTD} <: PNML.AbstractPetriNet{PNTD}\n\nid::Symbol\nnet::PNML.PnmlNet{PNTD} where PNTD\n\nTODO: Rename SimpleNet to TBD\n\nSimpleNet is a concrete AbstractPetriNet wrapping a PnmlNet.\n\nUses a flattened net to avoid the page level of the pnml hierarchy.\n\nA multi-page petri net can always be flattened by removing referenceTransitions & referencePlaces, and merging pages into the first page.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.SortType","page":"API","title":"PNML.SortType","text":"struct SortType{T<:PNML.Term} <: PNML.HLAnnotation\n\ntext::Union{Nothing, String}\nsort::PNML.Term\ncom::PNML.ObjectCommon\n\nPart of the many-sorted algebra of a High-level Petri Net Graph. A label whose <structure> element holds an AbstractSort term.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Structure","page":"API","title":"PNML.Structure","text":"struct Structure{T}\n\ntag::Symbol\nel::Any\nxml::EzXML.Node\n\nHigh-level Annotation Labels place meaning in <structure>.\n\nIs an abstract syntax tree (ast) expressed in XML. Note the structural similarity to PnmlLabel and AnyElement\n\nExtra\n\nThere are various defined structure ast variants:\n\nSort of a Place type [builtin, multi, product, user]\nTerm of Place HLMarking  [variable, operator]\nTerm of Transition Condition  [variable, operator]\nTerm of Arc Inscription [variable, operator]\nDeclarations of Declaration * [sort, variable, operator]\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Term","page":"API","title":"PNML.Term","text":"Evaluate a term by returning the ':value' in elements or a default value.\n\nDefault term value defaults to 1. Use the default argument to specify a default.\n\nExamples\n\njulia> t = Term()\nTerm(:empty, ())\n\njulia> t()\n1\n\njulia> t(0)\n0\n\njulia> t(2.3)\n2.3\n\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Term-2","page":"API","title":"PNML.Term","text":"struct Term <: PNML.AbstractTerm\n\ntag::Symbol\nelements::NamedTuple\n\nPart of the many-sorted algebra attached to nodes on a Petri Net Graph, Terms are contained within the <structure> element of a HLAnnotation.\n\n#! Note that Term is is an abstract element in the specification with no PNML tag.\n\nShould conform to the HLAnnotation interface. Namely <text>, <structure>, where <structure> contains one element.  The element tag name is paired with its content: a NamedTuple{Tag, Content} of children elements.\n\nNote that 'structure' is not present in tag or tuple. This can be done for a HLAnnotation. For more general well-formed-XML handling see AnyElement.\n\nast variants:\n\nvariable\noperator\n\njulia> t = Term()\nTerm(:empty, ())\n\njulia> t()\n1\n\n#! Term as functor requires a default value for missing values.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.TokenGraphics","page":"API","title":"PNML.TokenGraphics","text":"struct TokenGraphics <: PNML.AbstractPnmlTool\n\npositions::Vector{PNML.Coordinate}\n\nTokenGraphics is <toolspecific> content. Combines the <tokengraphics> and <tokenposition> elements.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.ToolInfo","page":"API","title":"PNML.ToolInfo","text":"struct ToolInfo\n\ntoolname::String\nversion::String\ninfos::Vector{PNML.AnyElement}\nxml::EzXML.Node\n\nToolInfo holds a <toolspecific> tag.\n\nIt wraps a vector of well formed elements parsed into AnyElements. for use by anything that understands toolname, version toolspecifics.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Transition","page":"API","title":"PNML.Transition","text":"Transition node of a Petri Net Markup Language graph.\n\nstruct Transition{PNTD, C} <: PNML.AbstractPnmlNode{PNTD}\n\npntd::Any\nid::Symbol\ncondition::Any\nname::Union{Nothing, PNML.Name}\ncom::PNML.ObjectCommon\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.UnknownDeclaration","page":"API","title":"PNML.UnknownDeclaration","text":"struct UnknownDeclaration <: PNML.AbstractDeclaration\n\nid::Symbol\nname::String\nnodename::String\ncontent::Vector{Any}\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.UserOperator","page":"API","title":"PNML.UserOperator","text":"struct UserOperator <: PNML.AbstractOperator\n\ndeclaration::Symbol: Identity of operators's declaration.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.UserSort","page":"API","title":"PNML.UserSort","text":"struct UserSort <: PNML.AbstractSort\n\nWrap a AnyElement. Use until specialized/cooked.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.Variable","page":"API","title":"PNML.Variable","text":"struct Variable <: PNML.AbstractTerm\n\nvariableDecl::Symbol\n\nExample input: <variable refvariable=\"varx\"/>\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.VariableDeclaration","page":"API","title":"PNML.VariableDeclaration","text":"struct VariableDeclaration{S} <: PNML.AbstractDeclaration\n\nid::Symbol\nname::String\nsort::Any\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.XMLNode","page":"API","title":"PNML.XMLNode","text":"Alias for EzXML.Node\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML._anyelement_content!-Tuple{Vector{Pair{Symbol, Any}}, Vector{EzXML.Node}, PNML.HarvestAny}","page":"API","title":"PNML._anyelement_content!","text":"_anyelement_content!(\n    vec::Vector{Pair{Symbol, Any}},\n    nodes::Vector{EzXML.Node},\n    ha!::PNML.HarvestAny\n)\n\n\nApply ha! to each node in nodes. Return pairs Symbol => values that are vectors when there are multiple instances of a tag in nodes and scalar otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML._evaluate","page":"API","title":"PNML._evaluate","text":"_evaluate(x) -> identity(x)\n_evaluate(x::Base.Callable) -> (x)()\n\nReturn the value of \"x\", defaults to identity.\n\nExamples\n\nSince High-level PNML schemas are based on Natural numbers and booleans, it seems reasonable to assume Number, which includes Bool, for the non-callable type. A functor is expected as the callable type allowing expressions in the many-sorted algebra to be evaluated to a Number.     _evaluate(value(c))\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML._harvest_any!-Tuple{EzXML.Node, PNML.HarvestAny}","page":"API","title":"PNML._harvest_any!","text":"_harvest_any!(\n    node::EzXML.Node,\n    ha!::PNML.HarvestAny\n) -> NamedTuple\n\n\nReturn NamedTuple holding a well-formed XML node.\n\nIf element node has any children, each is placed in the dictonary with the child's tag name symbol as the key, repeated tags produce a vector as the value. Any XML attributes found are added as as key,value pairs.\n\nDescend the well-formed XML using parser on child nodes.\n\nNote the assumption that \"children\" and \"content\" are mutually exclusive. Content is always a leaf element. However XML attributes can be anywhere in the hierarchy. And neither children nor content nor attribute may be present.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML._match","page":"API","title":"PNML._match","text":"_match(ti::ToolInfo, name::AbstractString)\n_match(ti::ToolInfo, name::String, version::String)\n_match(ti::ToolInfo, namerex::Regex, versionrex::Regex)\n\nMatch toolname and version. Default is any version.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML._parse_decl_structure-Union{Tuple{T}, Tuple{EzXML.Node, T, Any}} where T<:PnmlType","page":"API","title":"PNML._parse_decl_structure","text":"Assumes high-level semantics until someone specializes. See decl_structure.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML._parse_inscription-Union{Tuple{T}, Tuple{EzXML.Node, T, PnmlIDRegistry}} where T<:PnmlType","page":"API","title":"PNML._parse_inscription","text":"Specialize arc inscription label parsing.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.add_label!-Tuple{NamedTuple, EzXML.Node, Any, Any}","page":"API","title":"PNML.add_label!","text":"add_label!(\n    tup::NamedTuple,\n    node::EzXML.Node,\n    pntd,\n    reg\n) -> Any\n\n\nAdd node to d[:labels], a vector of PnmlLabel. Return updated d[:labels].\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.add_toolinfo!-NTuple{4, Any}","page":"API","title":"PNML.add_toolinfo!","text":"add_toolinfo!(tup, node, pntd, reg)\n\n\nAdd ToolInfo to tuple. Return updated tuple.\n\nThe UML from the pnml primer (and schemas) use <toolspecific> as the tag name for instances of the type ToolInfo.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.all_arcs","page":"API","title":"PNML.all_arcs","text":"Return vector of arcs that have a source or target of transition id.\n\nSee also src_arcs, tgt_arcs.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.allchildren","page":"API","title":"PNML.allchildren","text":"allchildren(\n    tag::AbstractString,\n    el::EzXML.Node\n) -> Vector{EzXML.Node}\nallchildren(\n    tag::AbstractString,\n    el::EzXML.Node,\n    ns::AbstractString\n) -> Vector{EzXML.Node}\n\n\nReturn vector of el's immediate children with tag.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.anyelement","page":"API","title":"PNML.anyelement","text":"Return AnyElement wraping a tag symbol and tuple holding a well-formed XML node. See ToolInfo for one intended use-case.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.append_page!-Tuple{PNML.Page, PNML.Page}","page":"API","title":"PNML.append_page!","text":"Append selected fields of r to fields of l. Some, like Names and xml, are omitted because they are scalar values, not collections.\n\npagedict & netdata (holding the arc and pnml nodes) are per-net data that is not modified here. netsets hold pnml IDs \"owned\"\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.arc","page":"API","title":"PNML.arc","text":"Return arc with id if found, otherwise nothing.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.arc_idset","page":"API","title":"PNML.arc_idset","text":"Return vector of all arc ids.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.arcs","page":"API","title":"PNML.arcs","text":"Return set arc ids.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.condition","page":"API","title":"PNML.condition","text":"Return condition value of transition.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.conditions","page":"API","title":"PNML.conditions","text":"Return a labelled vector of condition values.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.currentMarkings-Tuple{PNML.PnmlNet}","page":"API","title":"PNML.currentMarkings","text":"currentMarkings(net) -> LVector{marking_value_type(n)}\n\nLVector labelled with place id and holding marking's value.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.decl_structure-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.decl_structure","text":"Return vector of \n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.default_bool_term-Tuple{AbstractHLCore}","page":"API","title":"PNML.default_bool_term","text":"Boolean termdefaultoneterm(defaultoneterm(\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.default_condition","page":"API","title":"PNML.default_condition","text":"Return default condition based on PNTD. Has meaning of true or always. ```\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.default_inscription","page":"API","title":"PNML.default_inscription","text":"Return default inscription value based on PNTD. Has meaning of unity, as in one.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.default_marking","page":"API","title":"PNML.default_marking","text":"Return default marking value based on PNTD. Has meaning of empty, as in zero.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.default_one_term","page":"API","title":"PNML.default_one_term","text":"One as integer, float, or empty term with a value of one.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.default_sort","page":"API","title":"PNML.default_sort","text":"Return instance of default sort based on PNTD. Has meaning of empty, as in zero.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.default_term","page":"API","title":"PNML.default_term","text":"Return default empty Term of a High-Level Net based on PNTD. Forwards to default_one_term meaning multiplicative identity or 1. See default_zero_term for additive identity or 0. Markings default to zero and inscriptions default to 1\n\nExamples\n\njulia> m = default_one_term(HLCoreNet())\nTerm(:empty, (value = 1,))\n\njulia> m()\n1\n\njulia> m = default_zero_term(HLCoreNet())\nTerm(:empty, (value = 0,))\n\njulia> m()\n0\n\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.default_zero_term","page":"API","title":"PNML.default_zero_term","text":"Zero as integer, float, or empty term with a value of zero.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.deref!-Tuple{PNML.PnmlNet}","page":"API","title":"PNML.deref!","text":"deref!(net::PNML.PnmlNet) -> PNML.PnmlNet\n\n\nRemove reference nodes from arcs.\n\nOperates on the PnmlNetData at the net level. Expects that the PnmlNetKeys of the firstpage will have to be cleaned as part of flatten_pages!,\n\nAxiomsof\n\nAll ids in a network are unique in that they only have one instance in the XML.\nA chain of reference Places or Transitions always ends at a Place or Transition.\nAll ids are valid.\nNo cycles.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.deref_place-Tuple{PNML.PnmlNet, Symbol}","page":"API","title":"PNML.deref_place","text":"deref_place(net, id) -> Symbol\n\nReturn id of referenced place.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.deref_transition-Tuple{PNML.PnmlNet, Symbol}","page":"API","title":"PNML.deref_transition","text":"deref_transition(net::PNML.PnmlNet, id::Symbol) -> Symbol\n\n\nReturn id of referenced transition.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.find_net","page":"API","title":"PNML.find_net","text":"Return PnmlNet having id or nothing`.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.find_nets","page":"API","title":"PNML.find_nets","text":"Return nets matching pntd type given as string, symbol or pnmltype singleton.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.first_net-Tuple{Any}","page":"API","title":"PNML.first_net","text":"first_net(model) -> PNML.PnmlNet\n\n\nReturn first net contained by doc.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.firstchild","page":"API","title":"PNML.firstchild","text":"firstchild(\n    tag::AbstractString,\n    node::EzXML.Node\n) -> Union{Nothing, EzXML.Node}\nfirstchild(\n    tag::AbstractString,\n    node::EzXML.Node,\n    ns::AbstractString\n) -> Union{Nothing, EzXML.Node}\n\n\nReturn up to 1 immediate child of el that is a tag.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.firstpage-Tuple{PNML.PnmlNet}","page":"API","title":"PNML.firstpage","text":"Usually the only interesting page.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.flatten_pages!","page":"API","title":"PNML.flatten_pages!","text":"Merge page content into the 1st page of each pnml net.\n\nNote that refrence nodes are still present. They can be removed later with deref!.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.get_label","page":"API","title":"PNML.get_label","text":"get_label(x, tag::Symbol) -> PnmlLabel\n\nReturn first label of x with a matching tagvalue.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.get_toolinfo","page":"API","title":"PNML.get_toolinfo","text":"Return first toolinfo having a matching toolname and version.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.getfirst","page":"API","title":"PNML.getfirst","text":"getfirst(\n    tag::AbstractString,\n    el::EzXML.Node\n) -> Union{Nothing, EzXML.Node}\ngetfirst(\n    tag::AbstractString,\n    el::EzXML.Node,\n    ns::AbstractString\n) -> Union{Nothing, EzXML.Node}\n\n\nReturn first child with tag or nothing.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.getfirst-Union{Tuple{F}, Tuple{F, Any}} where F","page":"API","title":"PNML.getfirst","text":"Return first true f of v or nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.has_arc","page":"API","title":"PNML.has_arc","text":"\n\nReturn true if any arc has id.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.has_label","page":"API","title":"PNML.has_label","text":"has_label(x, tag::Symbol) -> Bool\n\nDoes x have any label have a matching tagvalue.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.has_labels","page":"API","title":"PNML.has_labels","text":"has_labels(x) -> Bool\n\nDoes x have any labels.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.has_name","page":"API","title":"PNML.has_name","text":"has_name(x) -> Bool\n\nReturn true if there is a name.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.has_place","page":"API","title":"PNML.has_place","text":"Return true if there is any place with id?\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.has_refP","page":"API","title":"PNML.has_refP","text":"\n\n\n\n","category":"function"},{"location":"API/library/#PNML.has_refT","page":"API","title":"PNML.has_refT","text":"\n\n\n\n","category":"function"},{"location":"API/library/#PNML.has_structure-Tuple{PNML.AbstractLabel}","page":"API","title":"PNML.has_structure","text":"Return true if label has a structure field.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.has_text-Tuple{PNML.AbstractLabel}","page":"API","title":"PNML.has_text","text":"Return true if label has text field.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.has_toolinfo","page":"API","title":"PNML.has_toolinfo","text":"Does any toolinfo attached to d have a matching toolname.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.has_transition","page":"API","title":"PNML.has_transition","text":"Is there a transition with id?\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.has_xml","page":"API","title":"PNML.has_xml","text":"has_xml(x) -> Bool\n\nReturn true if x has XML attached. Defaults to false.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.in_out","page":"API","title":"PNML.in_out","text":"Return tuple of input, output labelled vectors with key of place ids and value of arc inscription's value for use as a transition function. #TODO When do these get called \"pre\" and \"post\"?\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.inc_indent-Tuple{IO}","page":"API","title":"PNML.inc_indent","text":"Increment the :indent value by indent_width.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.indent-Tuple{IO}","page":"API","title":"PNML.indent","text":"Return string of current indent size in io.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.initialMarking","page":"API","title":"PNML.initialMarking","text":"Return a labelled vector with key of place id and value of its marking. Marking value is evaluated to be a number (Int or Float64). High-level nets evaluate a Term of the many-sorted algebra to an Int.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.ins-Tuple{Any, Symbol}","page":"API","title":"PNML.ins","text":"ins(p, transition_id::Symbol) -> LabelledArrays.LArray\n\n\nReturn labeled vector of arcs of p that have transition_id as the target.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.inscription","page":"API","title":"PNML.inscription","text":"Return incription value of arc.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.inscriptiontype","page":"API","title":"PNML.inscriptiontype","text":"Use PNML type as trait to select type of inscription.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.inscriptionvaluetype","page":"API","title":"PNML.inscriptionvaluetype","text":"Use PNML type as trait to select type of inscription.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.ispid-Tuple{Symbol}","page":"API","title":"PNML.ispid","text":"ispid(x::Symbol) -> Base.Fix2{typeof(===), Symbol}\n\n\nReturn function to be used like: any(ispid(sym), iteratewithpid)\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.labels-Tuple{Any}","page":"API","title":"PNML.labels","text":"labels(x) -> Vector\n\nReturn vector of labels attached to x.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.marking","page":"API","title":"PNML.marking","text":"Return marking value of a place.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.marking_type","page":"API","title":"PNML.marking_type","text":"Use PNML type as trait to select type of marking.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.marking_value_type","page":"API","title":"PNML.marking_value_type","text":"Use PNML type as trait to select valuetype of marking.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.name","page":"API","title":"PNML.name","text":"name(x) -> String\n\nReturn name String. Default to empty string.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.nets-Tuple{PNML.PnmlModel}","page":"API","title":"PNML.nets","text":"nets(model::PNML.PnmlModel) -> Tuple{Vararg{PNML.PnmlNet}}\n\n\nReturn all nets of model.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.nettype","page":"API","title":"PNML.nettype","text":"Return the PnmlType subtype representing the flavor (or pntd) of this kind of Petri Net Graph.\n\nSee also pnmltype\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.number_value-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T<:Number","page":"API","title":"PNML.number_value","text":"Parse string as a number. First try integer then float.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.outs-Tuple{Any, Symbol}","page":"API","title":"PNML.outs","text":"outs(p, transition_id::Symbol) -> LabelledArrays.LArray\n\n\nReturn labeled vector of arcs of p that have transition_id as the source.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.pages","page":"API","title":"PNML.pages","text":"Return vector of all pages.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.pages-Tuple{PNML.PnmlNet}","page":"API","title":"PNML.pages","text":"Return iterator of Pages directly owned by net.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_and-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_and","text":"parse_and(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_arbitraryoperator-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_arbitraryoperator","text":"parse_arbitraryoperator(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_arbitrarysort-Tuple{Any, Any, Any}","page":"API","title":"PNML.parse_arbitrarysort","text":"parse_arbitrarysort(node, pntd, reg) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_arc-Tuple{Any, Any, PnmlIDRegistry}","page":"API","title":"PNML.parse_arc","text":"parse_arc(node::XMLNode, pntd::PnmlType, idregistry) -> Arc{typeof(pntd), typeof(inscription)}\n\nConstruct an Arc with labels specialized for the PnmlType.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_bool-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_bool","text":"parse_bool(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_booleanconstant-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_booleanconstant","text":"parse_booleanconstant(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_condition-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_condition","text":"parse_condition(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> PNML.Condition\n\n\nLabel of transition nodes.\n\nDetails\n\nCondition is defined by the ISO Specification as a High-level Annotation, meaning it has <text> and <structure> elements. With all meaning in the element that the <structure> holds evaluating to a boolean value. We extend this to anything that evaluates to a boolean value when treated as a functor.\n\nA Condition should evaluate to a boolean. See AbstractTerm.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_declaration-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_declaration","text":"parse_declaration(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.Declaration\n\n\nReturn Declaration label of 'net' and 'page' nodes. Assume behavior of a High-level Net label in that the meaning is in a <struct>.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_equality-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_equality","text":"parse_equality(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_file-Tuple{AbstractString}","page":"API","title":"PNML.parse_file","text":"parse_file(fname::AbstractString) -> PNML.PnmlModel\n\n\nBuild a PnmlModel from a file containing XML. See parse_str and parse_pnml.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_graphics-Tuple{Any, Any, Any}","page":"API","title":"PNML.parse_graphics","text":"parse_graphics(node, pntd, reg) -> PNML.Graphics\n\n\nArcs, Annotations and Nodes have different graphics semantics. Return a Graphics holding the union of possibilities.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_graphics_coordinate-Tuple{Any, Any, Any}","page":"API","title":"PNML.parse_graphics_coordinate","text":"parse_graphics_coordinate(\n    node,\n    pntd,\n    reg\n) -> Union{PNML.Coordinate{Float64}, PNML.Coordinate{Int64}}\n\n\nReturn Coordinate. Specification seems to only use integers, we also allow real numbers.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_graphics_fill-Tuple{Any, Any, Any}","page":"API","title":"PNML.parse_graphics_fill","text":"parse_graphics_fill(node, pntd, reg) -> PNML.Fill\n\n\nReturn Fill\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_graphics_font-Tuple{Any, Any, Any}","page":"API","title":"PNML.parse_graphics_font","text":"parse_graphics_font(node, pntd, reg) -> PNML.Font\n\n\nReturn Font.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_graphics_line-Tuple{Any, Any, Any}","page":"API","title":"PNML.parse_graphics_line","text":"parse_graphics_line(node, pntd, reg) -> PNML.Line\n\n\nReturn Line.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_hlinitialMarking-Tuple{EzXML.Node, AbstractHLCore, PnmlIDRegistry}","page":"API","title":"PNML.parse_hlinitialMarking","text":"parse_hlinitialMarking(\n    node::EzXML.Node,\n    pntd::AbstractHLCore,\n    idregistry::PnmlIDRegistry\n) -> PNML.HLMarking{PNML.Term}\n\n\nHigh-level initial marking labels are expected to have a Term in the <structure> child. We extend the pnml standard by allowing node content to be numeric: parsed to Int and Float64.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_hlinscription-Tuple{EzXML.Node, AbstractHLCore, PnmlIDRegistry}","page":"API","title":"PNML.parse_hlinscription","text":"parse_hlinscription(\n    node::EzXML.Node,\n    pntd::AbstractHLCore,\n    idregistry::PnmlIDRegistry\n) -> PNML.HLInscription{PNML.Term}\n\n\nhlinscriptions are expressions.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_imply-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_imply","text":"parse_imply(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_inequality-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_inequality","text":"parse_inequality(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_initialMarking-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_initialMarking","text":"parse_initialMarking(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> PNML.Marking\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_inscription-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_inscription","text":"parse_inscription(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> PNML.Inscription\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_label-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_label","text":"parse_label(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> NamedTuple{(:tag, :xml), Tuple{Symbol, EzXML.Node}}\n\n\nShould not often have a '<label>' tag, this will bark if one is found. Return NamedTuple (tag,node), to defer parsing the xml.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_mulitsetsort-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_mulitsetsort","text":"parse_mulitsetsort(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_name-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_name","text":"parse_name(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> PNML.Name\n\n\nReturn Name label holding text value and optional tool & GUI information.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_namedoperator-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_namedoperator","text":"parse_namedoperator(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.NamedOperator{_A, PNML.AnyElement} where _A\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_namedsort-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_namedsort","text":"parse_namedsort(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.NamedSort{PNML.AnyElement}\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_net","page":"API","title":"PNML.parse_net","text":"parse_net(\n    node::EzXML.Node,\n    idregistry::PnmlIDRegistry\n) -> PNML.PnmlNet\nparse_net(\n    node::EzXML.Node,\n    idregistry::PnmlIDRegistry,\n    pntd_override::Union{Nothing, PnmlType}\n) -> PNML.PnmlNet\n\n\nReturn a PnmlNet`.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.parse_net_1-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_net_1","text":"Parse net with a defined PnmlType. The PNTD is used to set the marking, inscription, condition and sort type parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_net_2!","page":"API","title":"PNML.parse_net_2!","text":"parse_net_2!(d, node, pntd, idregistry)\n\nSpecialize on pntd. Go through children of node looking for expected tags, delegating common tags and labels.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.parse_net_page!-Tuple{NamedTuple, EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_net_page!","text":"See also parse_subpage!.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_node-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_node","text":"parse_node(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> Any\n\n\nCall any method matching xml node's tagin [tagmap](@ref), otherwise parse as [unclaimed_label](@ref) wrapped in a [PnmlLabel`](@ref). All uses are expected to be pnml labels attached to pnml graph nodes, arcs, nets, pages, that are excluded from this parsing pathway.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_not-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_not","text":"parse_not(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_or-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_or","text":"parse_or(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_page!-Union{Tuple{T}, Tuple{NamedTuple, EzXML.Node, T, PnmlIDRegistry}} where T<:PnmlType","page":"API","title":"PNML.parse_page!","text":"parse_page!(tup, node, pntd, idregistry) -> Page\n\nPlace Page in pagedict using id as the key.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_place-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_place","text":"parse_place(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> PNML.Place\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_place_labels!-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_place_labels!","text":"place label parsing updates tuple.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_pnml-Tuple{EzXML.Node, PnmlIDRegistry}","page":"API","title":"PNML.parse_pnml","text":"parse_pnml(xmlnode, idregistry) -> PnmlModel\n\nStart parse from the root node of a well formed pnml XML document. Return a PnmlModel holding one or more PnmlNet.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_pnml_label_common-Tuple{NamedTuple, Any, Any, Any}","page":"API","title":"PNML.parse_pnml_label_common","text":"parse_pnml_label_common(\n    tup::NamedTuple,\n    node,\n    pntd,\n    reg\n) -> Any\n\n\nUpdate tuple with label of a pnml object.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_pnml_object_common-Tuple{NamedTuple, EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_pnml_object_common","text":"parse_pnml_object_common(\n    tup0::NamedTuple,\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idreg::PnmlIDRegistry\n) -> Any\n\n\nReturn updated tuple accumulating pnml object labels.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_productsort-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_productsort","text":"parse_productsort(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_refPlace-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_refPlace","text":"parse_refPlace(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> PNML.RefPlace\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_refTransition-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_refTransition","text":"parse_refTransition(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> PNML.RefTransition\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_sort-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_sort","text":"parse_sort(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.AnyElement\n\n\nSorts are found within a <structure> element.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_str-Tuple{AbstractString}","page":"API","title":"PNML.parse_str","text":"parse_str(str::AbstractString) -> PNML.PnmlModel\n\n\nBuild a PnmlModel from a string containing XML. See parse_file and parse_pnml.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_structure-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_structure","text":"parse_structure(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> PNML.Structure\n\n\nReturn Structure wrapping an unclaimed_label holding a <structure>. Should be inside of an label. A \"claimed\" label usually elids the <structure> level (does not call this method).\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_subpage!-Tuple{NamedTuple, EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_subpage!","text":"See also parsenetpage!\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_term-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_term","text":"parse_term(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.Term\n\n\nThere will be no node <term>. Instead it is the interpertation of the child of some <structure> elements. The PNML specification describes Terms and Sorts as abstract types for the <structure> element of some HLAnnotation.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_text-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_text","text":"parse_text(\n    node::EzXML.Node,\n    _::PnmlType,\n    _::PnmlIDRegistry\n) -> String\n\n\nReturn the stripped string of node's content.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_tokengraphics-Tuple{EzXML.Node, PnmlType, Any}","page":"API","title":"PNML.parse_tokengraphics","text":"parse_tokengraphics(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg\n) -> PNML.TokenGraphics\n\n\nHigh-level place-transition nets (HL-PTNet) have a toolspecific structure defined for token graphics. Contains <tokenposition> tags.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_tokenposition-Tuple{Any, Any, Any}","page":"API","title":"PNML.parse_tokenposition","text":"parse_tokenposition(\n    node,\n    pntd,\n    reg\n) -> Union{PNML.Coordinate{Float64}, PNML.Coordinate{Int64}}\n\n\nCartesian coordinate relative to containing element.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_toolspecific-Tuple{Any, Any, Any}","page":"API","title":"PNML.parse_toolspecific","text":"parse_toolspecific(node, pntd, reg) -> PNML.ToolInfo\n\n\nReturn ToolInfo with tool & version attributes and content.\n\nThe content can be one or more well-formed xml elements. Each are wrapped in a PnmlLabel.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_transition-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_transition","text":"parse_transition(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> PNML.Transition\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_tuple-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_tuple","text":"parse_tuple(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_type","page":"API","title":"PNML.parse_type","text":"Defines the \"sort\" of tokens held by the place and semantics of the marking. NB: The \"type\" of a place from many-sorted algebra is different from the Petri Net \"type\" of a net or \"pntd\". Neither is directly a julia type.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.parse_unknowndecl-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_unknowndecl","text":"parse_unknowndecl(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.UnknownDeclaration\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_unparsed-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_unparsed","text":"parse_unparsed(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.PnmlLabel\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_useroperator-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_useroperator","text":"parse_useroperator(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.UserOperator\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_usersort-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_usersort","text":"parse_usersort(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.UserSort\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_variable-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_variable","text":"parse_variable(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.Variable\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.parse_variabledecl-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.parse_variabledecl","text":"parse_variabledecl(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    reg::PnmlIDRegistry\n) -> PNML.VariableDeclaration{PNML.AnyElement}\n\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.pid","page":"API","title":"PNML.pid","text":"pid(x) -> Symbol\n\nReturn pnml id symbol.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.place","page":"API","title":"PNML.place","text":"Return the place with id.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.place_idset","page":"API","title":"PNML.place_idset","text":"Return vector of all place IDs.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.places","page":"API","title":"PNML.places","text":"Return vector of all places.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.pnml_common_defaults-Tuple{}","page":"API","title":"PNML.pnml_common_defaults","text":"pnml_common_defaults(\n\n) -> NamedTuple{(:graphics, :tools, :labels), Tuple{Nothing, Nothing, Nothing}}\n\n\nReturn tags common to both pnml nodes and pnml labels. See also: pnml_label_defaults, pnml_node_defaults.x\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.pnml_label_defaults-Tuple","page":"API","title":"PNML.pnml_label_defaults","text":"pnml_label_defaults(xs...) -> Any\n\n\nMerge xs with default common keys and annotation label keys text and structure'. See also [pnmlnodedefaults](@ref), [pnmlcommondefaults`](@ref).\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.pnml_namespace-Tuple{EzXML.Node}","page":"API","title":"PNML.pnml_namespace","text":"pnml_namespace(\n    node::EzXML.Node;\n    missing_ns_fatal,\n    default_ns\n) -> String\n\n\nReturn namespace. When node does not have a namespace return default value pnml_ns and warn or throw an error.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.pnml_node_defaults-Tuple","page":"API","title":"PNML.pnml_node_defaults","text":"pnml_node_defaults(xs...) -> Any\n\n\nMerge xs with default pnml node tags. See also: pnml_label_defaults, pnml_common_defaults.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.rate-Tuple{Any}","page":"API","title":"PNML.rate","text":"rate(transition) -> Float64\n\n\nReturn rate value of transition.  Missing rate labels are defaulted to 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.rates","page":"API","title":"PNML.rates","text":"Return a transition-id labelled vector of rate values for transitions of net.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.refid-Tuple{PNML.ReferenceNode}","page":"API","title":"PNML.refid","text":"Return the id of the referenced node.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.refplace","page":"API","title":"PNML.refplace","text":"Return reference place matching id.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.refplace_idset","page":"API","title":"PNML.refplace_idset","text":"refplace_idset(x) -> Vector{Symbol} #TODO iterator?\n\nReturn reference place pnml ids.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.refplaces","page":"API","title":"PNML.refplaces","text":"Return vector of all reference places.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.reftransition","page":"API","title":"PNML.reftransition","text":"Return reference transition matching id.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.reftransition_idset","page":"API","title":"PNML.reftransition_idset","text":"reftransition_idset(x) -> Vector{Symbol} #TODO iterator?\n\nReturn reference transition pnml ids.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.reftransitions","page":"API","title":"PNML.reftransitions","text":"Return vector of all reference transitions.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.save_config!","page":"API","title":"PNML.save_config!","text":"save_config!(config::PnmlConfig=CONFIG)\n\nSave a PNML.jl configuration config (by default, PNML) to your LocalPreferences.toml file using Preferences.jl.\n\nThe saved preferences will be automatically loaded next time you using PNML\n\nExamples\n\njulia> using PNML\n\njulia> PNML.CONFIG.verbose = true\ntrue\n\njulia> PNML.CONFIG.warn_on_unclaimed = true     # Customize some defaults\ntrue\n\njulia> PNML.save_config!(PNML.CONFIG) # Will be automatically read next time you `using PNML`\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.source-Tuple{Any}","page":"API","title":"PNML.source","text":"source(arc) -> Symbol\n\n\nReturn symbol of source of arc.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.src_arcs","page":"API","title":"PNML.src_arcs","text":"Return vector of arcs that have a source of transition id.\n\nSee also all_arcs, tgt_arcs.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.structure-Tuple{PNML.AbstractLabel}","page":"API","title":"PNML.structure","text":"Return structure field.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.tag","page":"API","title":"PNML.tag","text":"tag(x) -> Symbol\n\nReturn tag symbol.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.target-Tuple{Any}","page":"API","title":"PNML.target","text":"target(arc) -> Symbol\n\n\nReturn symbol of target of arc.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.text-Tuple{PNML.AbstractLabel}","page":"API","title":"PNML.text","text":"Return text field\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.tgt_arcs","page":"API","title":"PNML.tgt_arcs","text":"Return vector of arcs that have a target of transition id.\n\nSee also all_arcs, src_arcs.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.transition","page":"API","title":"PNML.transition","text":"\n\n\n\n","category":"function"},{"location":"API/library/#PNML.transition_function","page":"API","title":"PNML.transition_function","text":"Transition function of a Petri Net. Each transition has an input vector and an output vector. Each labelled vector is indexed by the place on the other end of the arc. Values are inscriptions of the arc.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.transition_idset","page":"API","title":"PNML.transition_idset","text":"\n\n\n\n","category":"function"},{"location":"API/library/#PNML.transitions","page":"API","title":"PNML.transitions","text":"Return vector of all transitions.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.unclaimed_label-Tuple{EzXML.Node, PnmlType, PnmlIDRegistry}","page":"API","title":"PNML.unclaimed_label","text":"unclaimed_label(\n    node::EzXML.Node,\n    pntd::PnmlType,\n    idregistry::PnmlIDRegistry\n) -> Pair{Symbol}\n\n\nReturn tag => tuple holding a pnml label and its children.\n\nThe main use-case is to be wrapped in a PnmlLabel, AnyElement, Term or other specialized label.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.xmlnode","page":"API","title":"PNML.xmlnode","text":"xmlnode(x) -> XMLNode\n\nReturn attached xml node.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.xmlroot-Tuple{AbstractString}","page":"API","title":"PNML.xmlroot","text":"xmlroot(s::AbstractString) -> EzXML.Node\n\n\nParse string s into EzXML node.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.@xml_str-Tuple{Any}","page":"API","title":"PNML.@xml_str","text":"Parse string into EzXML node.\n\nSee xmlroot.\n\n\n\n\n\n","category":"macro"},{"location":"API/library/#PnmlTypeDefs-Reference","page":"API","title":"PnmlTypeDefs Reference","text":"","category":"section"},{"location":"API/library/","page":"API","title":"API","text":"Modules = [PnmlTypeDefs]","category":"page"},{"location":"API/library/#PNML.PnmlTypeDefs","page":"API","title":"PNML.PnmlTypeDefs","text":"Petri Net Type Definition (pntd) URI mapped to PnmlType subtype singleton.\n\n\n\n\n\n","category":"module"},{"location":"API/library/#PNML.PnmlTypeDefs.default_pntd_map","page":"API","title":"PNML.PnmlTypeDefs.default_pntd_map","text":"Map from Petri Net Type Definition (pntd) URI to Symbol. Allows multiple strings to map to the same pntd.\n\nThere is a companion map pnmltype_map that takes the symbol to a type object.\n\nThe URI is a string and may be the full URL of a pntd schema, just the schema file name, or a placeholder for a future schema.\n\nFor readability, the 'pntd symbol' should match the name used in the URI with inconvinient characters removed or replaced. For example, '-' is replaced by '_'.\n\n\n\n\n\n","category":"constant"},{"location":"API/library/#PNML.PnmlTypeDefs.pnmltype_map","page":"API","title":"PNML.PnmlTypeDefs.pnmltype_map","text":"The key Symbols are the supported kinds of Petri Nets.\n\n\n\n\n\n","category":"constant"},{"location":"API/library/#PNML.PnmlTypeDefs.AbstractContinuousNet","page":"API","title":"PNML.PnmlTypeDefs.AbstractContinuousNet","text":"abstract type AbstractContinuousNet <: PnmlType\n\nUses floating point numbers for markings, inscriptions. Most of the functionality is shared with AbstractPnmlCore. This seperates the\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.AbstractHLCore","page":"API","title":"PNML.PnmlTypeDefs.AbstractHLCore","text":"abstract type AbstractHLCore <: PnmlType\n\nBase of High Level Petri Net pntds which add large extensions to PNML core. hlinitialMarking, hlinscription, and defined label structures.\n\nSee HLCoreNet, SymmetricNet, PT_HLPNG and others.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.AbstractPnmlCore","page":"API","title":"PNML.PnmlTypeDefs.AbstractPnmlCore","text":"abstract type AbstractPnmlCore <: PnmlType\n\nBase of token/integer-based Petri Net pntds.\n\nSee PnmlCoreNet, PTNet and others.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.ContinuousNet","page":"API","title":"PNML.PnmlTypeDefs.ContinuousNet","text":"struct ContinuousNet <: AbstractContinuousNet\n\nTODO: Continuous Petri Net\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.HLCoreNet","page":"API","title":"PNML.PnmlTypeDefs.HLCoreNet","text":"struct HLCoreNet <: AbstractHLCore\n\nHLCoreNet can be used for generic high-level nets. We try to implement and test all function at `PnmlCoreNet level, but expect to find use for a concrete type at this level for testing high-level extensions.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.HLPNG","page":"API","title":"PNML.PnmlTypeDefs.HLPNG","text":"struct HLPNG <: AbstractHLCore\n\nHigh-Level Petri Net Graphs (HLPNGs) are the most intricate High-Level Petri Net schema. It extends SymmetricNet, including with\n\ndeclarations for sorts and functions (ArbitraryDeclarations)\nsorts for Integer, String, and List\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.OpenNet","page":"API","title":"PNML.PnmlTypeDefs.OpenNet","text":"struct OpenNet <: AbstractContinuousNet\n\nTODO: Open Petri Net\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.PTNet","page":"API","title":"PNML.PnmlTypeDefs.PTNet","text":"struct PTNet <: AbstractPnmlCore\n\nPlace-Transition Petri Nets add small extensions to core PNML. Integer-valued initialMarking and inscription.\n\nThe grammer file is ptnet.pnml so we name it PTNet. Note that 'PT' is often the prefix for XML tags specialized for this net type.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.PT_HLPNG","page":"API","title":"PNML.PnmlTypeDefs.PT_HLPNG","text":"struct PT_HLPNG <: AbstractHLCore\n\nPlace-Transition Net in HLCoreNet notation.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.PnmlCoreNet","page":"API","title":"PNML.PnmlTypeDefs.PnmlCoreNet","text":"struct PnmlCoreNet <: AbstractPnmlCore\n\nThe most minimal concrete Petri Net.\n\nUsed to implement and test the core PNML support. Covers the complete graph infrastructure including labels attached to nodes and arcs.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.PnmlType","page":"API","title":"PNML.PnmlTypeDefs.PnmlType","text":"abstract type PnmlType\n\nAbstract root of a dispatch type based on Petri Net Type Definition (pntd).\n\nEach Petri Net Markup Language (PNML) network element will have a single pntd URI as a required 'type' XML attribute. That URI should refer to a RelaxNG schema defining the syntax and semantics of the XML model.\n\nSelected abbreviations, URIs that do not resolve to a valid schema file, are also allowed.\n\nRefer to pntd_symbol and pnmltype for how to get from the URI to a singleton.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.StochasticNet","page":"API","title":"PNML.PnmlTypeDefs.StochasticNet","text":"struct StochasticNet <: AbstractHLCore\n\nTODO: Stochastic Petri Net\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.SymmetricNet","page":"API","title":"PNML.PnmlTypeDefs.SymmetricNet","text":"struct SymmetricNet <: AbstractHLCore\n\nSymmetric Petri Net is the best-worked use case in the primer and ISO specification part 2.\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.TimedNet","page":"API","title":"PNML.PnmlTypeDefs.TimedNet","text":"struct TimedNet <: AbstractHLCore\n\nTODO: Timed Petri Net\n\n\n\n\n\n","category":"type"},{"location":"API/library/#PNML.PnmlTypeDefs.add_nettype!-Tuple{AbstractDict, Symbol, PnmlType}","page":"API","title":"PNML.PnmlTypeDefs.add_nettype!","text":"add_nettype!(\n    elements::AbstractDict,\n    s::Symbol,\n    pntd::PnmlType\n) -> PnmlType\n\n\nAdd or replace mapping from symbol s to nettype dispatch singleton t.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.PnmlTypeDefs.iscontinuous","page":"API","title":"PNML.PnmlTypeDefs.iscontinuous","text":"Values are floating point.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.PnmlTypeDefs.isdiscrete","page":"API","title":"PNML.PnmlTypeDefs.isdiscrete","text":"Values are integers.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.PnmlTypeDefs.ishighlevel","page":"API","title":"PNML.PnmlTypeDefs.ishighlevel","text":"Values are many-sorted.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.PnmlTypeDefs.pnmltype","page":"API","title":"PNML.PnmlTypeDefs.pnmltype","text":"pnmltype(pntd::T, reg)\npnmltype(uri::AbstractString, reg)\npnmltype(s::Symbol; pnmltype_map=pnmltype_map, reg)\n\nMap either a text string or a symbol to a dispatch type singlton.\n\nWhile that string may be a URI for a pntd, we treat it as a simple string without parsing. The PnmlTypeDefs.pnmltype_map and PnmlTypeDefs.default_pntd_map are both assumed to be correct here.\n\nUnknown or empty uri will map to symbol :pnmlcore. Unknown symbol throws a DomainError exception.\n\nExamples\n\njulia> pnmltype(PnmlCoreNet())\nPnmlCoreNet()\n\njulia> pnmltype(\"nonstandard\")\nPnmlCoreNet()\n\njulia> pnmltype(:symmetric)\nSymmetricNet()\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.PnmlTypeDefs.pntd_symbol-Tuple{AbstractString}","page":"API","title":"PNML.PnmlTypeDefs.pntd_symbol","text":"pntd_symbol(s::AbstractString) -> Symbol\n\n\nMap string s to a pntd symbol using default_pntd_map. Any unknown s is mapped to :pnmlcore. Returned symbol is suitable for pnmltype to use to index into pnmltype_map.\n\nExamples\n\njulia> PnmlTypeDefs.pntd_symbol(\"foo\")\n:pnmlcore\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PnmlIDRegistrys-Reference","page":"API","title":"PnmlIDRegistrys Reference","text":"","category":"section"},{"location":"API/library/","page":"API","title":"API","text":"Modules = [PnmlIDRegistrys]","category":"page"},{"location":"API/library/#PNML.PnmlIDRegistrys","page":"API","title":"PNML.PnmlIDRegistrys","text":"Petri Net Markup Language identifier registry.\n\n\n\n\n\n","category":"module"},{"location":"API/library/#PNML.PnmlIDRegistrys.PnmlIDRegistry","page":"API","title":"PNML.PnmlIDRegistrys.PnmlIDRegistry","text":"Holds a set of pnml id symbols and a lock to allow safe reentrancy.\n\nstruct PnmlIDRegistry{L<:Base.AbstractLock}\n\nids::Set{Symbol}\nlk::Base.AbstractLock\n\n\n\n\n\n","category":"type"},{"location":"API/library/#Base.isempty-Tuple{PnmlIDRegistry}","page":"API","title":"Base.isempty","text":"isempty(idregistry::PnmlIDRegistry) -> Bool\n\n\nIs the set of id symbols empty?\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.PnmlIDRegistrys.isregistered_id-Tuple{PnmlIDRegistry, AbstractString}","page":"API","title":"PNML.PnmlIDRegistrys.isregistered_id","text":"isregistered_id(\n    reg::PnmlIDRegistry,\n    s::AbstractString\n) -> Bool\n\n\nReturn true if s is registered in reg.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.PnmlIDRegistrys.register_id!-Tuple{PnmlIDRegistry, AbstractString}","page":"API","title":"PNML.PnmlIDRegistrys.register_id!","text":"register_id!(\n    idregistry::PnmlIDRegistry,\n    s::AbstractString\n) -> Symbol\n\n\nRegister id symbol and return the symbol.\n\n\n\n\n\n","category":"method"},{"location":"API/library/#PNML.PnmlIDRegistrys.registry","page":"API","title":"PNML.PnmlIDRegistrys.registry","text":"registry([lock]) -> PnmlIDRegistry\n\nConstruct a PNML ID registry using the supplied lock or a ReentrantLock`.\n\n\n\n\n\n","category":"function"},{"location":"API/library/#PNML.PnmlIDRegistrys.reset!-Tuple{PnmlIDRegistry}","page":"API","title":"PNML.PnmlIDRegistrys.reset!","text":"reset!(idregistry::PnmlIDRegistry) -> Any\n\n\nEmpty the set of id symbols. Use case is unit tests. In normal use it should never be needed.\n\n\n\n\n\n","category":"method"},{"location":"status/","page":"Status","title":"Status","text":"High-level nets are not completely implemented (as of November 2022). Supporting continuous/hybrid high-level nets may not be possible. We currently do not try.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"CurrentModule = PNML","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Overview of some type hierarchies.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"using AbstractTrees, PNML, InteractiveUtils, Markdown\n#, GraphRecipes,Plots\n\nAbstractTrees.children(x::Type) = subtypes(x)\ntype_tree(t) = println(AbstractTrees.repr_tree(t))","category":"page"},{"location":"type_hierarchies/#PnmlType-Petri-Net-Type-Definition","page":"Type Hierarchies","title":"PnmlType - Petri Net Type Definition","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"See PnmlTypeDefs module page.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"There are levels:  Core (Place-Transition), Continuous and High-Level PNG (HLPNG).","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"PnmlCoreNet is a concrete subtype of PnmlType. PnmlCoreNet is used by some AbstractPetriNet concrete types (SimpleNet).","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"ContinuousNet is a concrete type of AbstractContinuousNet. ContinuousNet uses floating point marking and inscriptions. It is a nonstandard extension to the ISO specification.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"HLCoreNet is a concrete subtype of AbstractHLCore. HLCoreNet is used by some AbstractPetriNet concrete types (HLPetriNet). Think of it as a testable implementation of AbstractHLCore.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"The IR does not try to impose semantics on the model. Those semantics should be part of AbstractPetriNet.  The IR tries to represent the model (all models) at a structural level. It may paramertize types to facilitate specilization.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.PnmlTypeDefs.PnmlType) # hide","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"PnmlType Place Trans Arc Description\nPnmlCoreNet    <name> is only defined label\nPTNet PTM none PTI <initialMarking>, <inscription> labels only have <text>\nHLCoreNet HLM Cond HLI support structure used by all HL Petri Net Graphs\nPT-HLPNG HLM Cond HLI restrict sort to dot, condition always true\nSymmetricNet HLM Cond HLI restrict sorts to finite, annotations have <structure>\nHLNet HLM Cond HLI extend symmetric with arbitrary sorts\nStochastic  Rate  continuous or discrete\nTimed    continuous or discrete\nOpen    continuous or discrete","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Todo: Continuous Petri Net","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Abbreviation Full Name Node Label Description\nPTM Marking Place \nPTI Inscription Arc \nHLM HLMarking Place \nHLI HLInscription Arc \nCond Condition Transition \nRate Rate Transition random variable or function of marking, firing rate\nPri Priority Transition firing order of enabled transitions\nWe Weight Transition firing tiebreaker\n   ","category":"page"},{"location":"type_hierarchies/#AbstractPetriNet","page":"Type Hierarchies","title":"AbstractPetriNet","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"AbstractPetriNet uses the Intermediate Representation and PnmlType to implement a petri Net Graph.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractPetriNet) # hide","category":"page"},{"location":"type_hierarchies/#AbstractPnmlObject","page":"Type Hierarchies","title":"AbstractPnmlObject","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Page, Arc, Place, Transition define the graph of a petri net.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractPnmlObject) # hide","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Fields expected of every subtype of AbstractPnmlObject:","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Name Type\nid Symbol\npntd <: PnmlType\nname Maybe{Name}\ncom ObjectCommon","category":"page"},{"location":"type_hierarchies/#AbstractLabel","page":"Type Hierarchies","title":"AbstractLabel","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Labels are attached to AbstractPnmlObjects. Kinds of label include: marking, inscription, condition and declarations of sorts, operators, and variables.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractLabel) # hide","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"info: Difference between Object and Label\nObjects have ids and Names.\nLabels are attached to Objects.\nSome Labels (attributes) do not have Graphics.\nLabels are extendable.\nLabels are named by the xml tag. Any \"unknown\" tag is presumed to be a label.","category":"page"},{"location":"type_hierarchies/#AbstractPnmlTool","page":"Type Hierarchies","title":"AbstractPnmlTool","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"See ToolInfo.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractPnmlTool) # hide","category":"page"},{"location":"type_hierarchies/#PnmlException","page":"Type Hierarchies","title":"PnmlException","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.PnmlException) # hide","category":"page"},{"location":"type_hierarchies/#Many-sorted-Algebra-Concepts","page":"Type Hierarchies","title":"Many-sorted Algebra Concepts","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"The PNML Specification builds the High-level Petri Net Graph as a layer using a Core layer (PnmlCore). The main feature of the HL layer (HLCore) is to require all annotation labels to have <text> and <structure> elements. All meaning is required to reside in a single child of <structure>. With the <text> for human/documentation use.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Implemented loosely so that it is mostly part of the PnmlCore implementation. Both <text> and <structure> are optional. Presumption is that the consumer will have good tests and defenses. TODO: Seems like a layer boundary in the degign.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"And we allow all net types to have probably-nonstandard julia declaration, sort-type objects.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"The <type> label is meant to be a sort of a many-sorted algebra. We call it sort-type to reduce the confusion.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"For nets other than high-level nets we implemented the sort-type object to be one(Int64) or one(Float64). Whereas for high-level nets the sort-type object is an HLAnnotation.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"The sort-type HLAnnotation label's <structure> will be parsed into a SortType. Unsurprisingly, <text> is parsed to String.","category":"page"},{"location":"type_hierarchies/#AbstractDeclaration","page":"Type Hierarchies","title":"AbstractDeclaration","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Labels attached to PnmlNet and/or Page.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractDeclaration) # hide","category":"page"},{"location":"type_hierarchies/#AbstractSort","page":"Type Hierarchies","title":"AbstractSort","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"High-level net's Place has a sort.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractSort) # hide","category":"page"},{"location":"type_hierarchies/#AbstractTerm","page":"Type Hierarchies","title":"AbstractTerm","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Part of the many-sorted algebra of a High-level net.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractTerm) # hide","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"CurrentModule = PNML","category":"page"},{"location":"IR/#Intermediate-Representation","page":"Intermediate Representation","title":"Intermediate Representation","text":"","category":"section"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"The intermediate representation (IR) is between the XML model and a \"usable\" network. Many different flavors of Petri Nets are expected to be implemented using the IR.","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"The IR is constructed by traversing the XML and using tag names as dictonary keys.","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"In the first part of parsing, a named tuple is filled with appropriate initial values for each xml tag. Then optional child keys have values bound as they are parsed.","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"The second part of parsing instantiates objects using the named tuple as input.","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"The structure of the IR follows the tree structure of a well-formed XML document and the PNML specification.","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"XML attribute names and child element tag names are used for keys of the same dictonary. The pnml specification/schemas do not use colliding names. However, the <toolspecific> tag's content is not required to be valid pnml, just well-formed XML. We assume nobody would use colliding names intentionally.","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"The crude structure required by the pnmlcore schema: PnmlModel","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"Net\nPage\n- Places, Marking\n- Transitions, Condition\n- Arcs, Inscription\n- Toolinfos\n- Labels\n- Subpages\nName","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"- Toolinfos\n- Labels","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"The IR is implemented under the assumption the the input pnml file is valid. All tags are assumed to be meaningful to the resulting network. The pnmlcore schema requires undefined tags will be considered pnml labels. The IR is capable of handling arbitrary labels. Many label tags from higherlevel pnml schemas are recognized by the IR parsers.","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"While the Petri Net Type Definition (pntd) is present in every valid net, it was not necessary to consult the type during creation of the IR. It is expected that conforming to pntd will be done at a higher level.","category":"page"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"Some parts of pnml are complicated. Not yet completed bits may be implemented as wrappers holdind unparsed XML. In fact, parts of pnml are specified as holding any well-formed XML.","category":"page"},{"location":"IR/#History-of-this-IR","page":"Intermediate Representation","title":"History of this IR","text":"","category":"section"},{"location":"IR/","page":"Intermediate Representation","title":"Intermediate Representation","text":"As experience with building & using more complicated pnml network models, more of the IR will be implemented or changed.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"CurrentModule = PNML","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Pages = [\"interface.md\"]\nDepth = 5","category":"page"},{"location":"interface/#Interface","page":"Interfaces","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"warning: Warning\nBeing a work in progress, there will be obsolete, optimistic or incoherent bits.Eventually this section will cover interfaces in a useful way.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The intermediate representation is used to implement networks expressed in a pnml model. The consumer of the IR is a network, most naturally a varity of Petri Net.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"High-Level Petri Net Graphs (HLPNG) can be expressed in a pnml model.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"We start a description of the net IR here.","category":"page"},{"location":"interface/#PnmlDict-or-NamedTuple","page":"Interfaces","title":"PnmlDict or NamedTuple","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Switch from PnmlDict, a dictionary over {Symbol,Any} to NamedTuples. There are pnml IDs and XML element tag names are used as names.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Each XML tag is first parsed (recursivly) into a named tuple, with tags as the names, then tuple is used to create higher-level types.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Wraps a NamedTuple:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"AnyElement\nPnmlLabel\nSortType\nTerm","category":"page"},{"location":"interface/#Top-Level:-Model,-Net,-Page","page":"Interfaces","title":"Top Level: Model, Net, Page","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"At the top level[layers] a <pnml> model is one or more networks::PnmlNet, each described by a <net> tag and one or more <page> tags.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Page  is a required element mostly present for visual presentation to humans. It contains AbstractPnmlObject types that implement the Petri Net Graph (PNG).","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"[layers]: Page inside a PnmlNet inside a AbstractPetriNet. Where the Petri Net part is expressed as a Petri Net Type Definition XML schema file (.pntd) identified by a URI. Or would if our nonstandard extensions had schemas defined. Someday there will be such schemas.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"ObjectCommon is a field of most types. This allows Graphics and ToolInfo to appear almost anywhere in the PNG.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"While Graphics is implemented as part of ObjectCommon it is not dicussed further (until someone extends/uses it).","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"ObjectCommon  also has ToolInfo used to attach well-formed XML. TODO: Need way to parse <toolspecific> that is flexible/extendable.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Parse pnml for input, worry about writing back out and interchange later (future extensions). Another future extension may be to use pages for distributed computing.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The pnml specification permits that multiple pages to be flattened (by flatten_pages!) to a single Page before use. Using them unflattened is not supposed to be impossible, but is not the arena or the initial use cases (in no paticular order): adapting to use graph tools, agent based modeling, sciml, etc.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"AbstractPetriNet subtypes wrap and extend PnmlNet. Note the Pnml to Petri.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PnmlNet and its contents can be considered an intermediate representation (IR). A concrete AbstractPetriNet type uses the IR to produce higher-level behavior. This is the level at which flatten_pages! and deref! operate.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"AbstractPetriNet is the level of most Petri Net Graph semantics. One example is enforcing integer, non-negative, positive. One mechanism used is type parameters.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Remember, the IR trys to be as promiscuous as possible.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"XML <net> tags are 1st parsed into NamedTuple which is used by parse_net to construct a PnmlNet:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"key value description\ntag XML tag symbol :net\nid unique ID\nname text name, optional\ntools list of tool specific - possibly empty\nlabels list of generic \"pnml labels\" - possible empty\ntype PnmlType defines schema the XML should meet\ndeclarations defines high-level semantics of a net\npages list of pages - not empty","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"XML <page> tags are also 1st parsed by parse_page! into NamedTuple which is used to construct a Page:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"key value description\ntag XML tag symbol :page\nid unique ID\nname text name, optional\ntools list of tool specific - possibly empty\nlabels list of generic \"pnml labels\" - possible empty\nplaces list of places\ntrans list of transitions\narcs list of arcs\nrefP references to place on different page\nrefT references to transition on different page\ndeclarations only net & page tags have declarations\npages pages can be nested","category":"page"},{"location":"interface/#Places","page":"Interfaces","title":"Places","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Properties that various places may have one or more of:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"discrete\ncontinuous\ntimed","category":"page"},{"location":"interface/#Transitions","page":"Interfaces","title":"Transitions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Properties that various transitions may have one or more of:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"discrete\ncontinuous\nhybrid of discrete & continuous subnets\nstochastic\nimmediate\ndeterministically time delayed\nscheduled","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The pnml schemas and primer only try to cover the discrete case as Place-Transition and High-Level Petri Nets. With a lot of multi-sorted algebra to make High-Level Nets complicated enough to be challenging.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Continous support is present where possible. For instance, when a number appers in the XML number_value is used to parse the string to Int or Float64. This is currently (2022) \"non-standard\" so such pnml files will not be generally interchangable with other tools.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"'Discrete, Continuous, and Hybrid Petri Nets' by Rene David and Hassane Alla","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"VANESA","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"See rate for a use of non-standard labels by SimpleNet. Implements a continuous petri net as part of the first working use-case. Demonstrates the expressiveness of pnml.","category":"page"},{"location":"interface/#Petri-Net-Graphs-and-Networks","page":"Interfaces","title":"Petri Net Graphs and Networks","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"There are 3 top-level forms:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"AbstractPetriNet subtypes wraping a single PnmlNet.\nPnmlNet  maybe multiple pages.\nPage when the only page of the only net in a Abstractpetrinet.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The simplest arrangement is a pnml model with a single <net> element having a single page. Any <net> may be flatten to a single page.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The initial AbstractPetriNet subtypes are built using the assumption that multiple pages will be flattened to a single page.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"using AbstractTrees, PNML, InteractiveUtils, Markdown","category":"page"},{"location":"interface/#Simple-Interface-Methods","page":"Interfaces","title":"Simple Interface Methods","text":"","category":"section"},{"location":"interface/#pid-get-PNML-ID-symbol","page":"Interfaces","title":"pid - get PNML ID symbol","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Objects within a pnml graph have unique identifiers, which are used for referring to the object. This includes: AbstractPnmlObject subtypes, PnmlNet.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.pid","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.pid) # hide","category":"page"},{"location":"interface/#name-get-name","page":"Interfaces","title":"name - get name","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"AbstractPnmlObjects and PnmlNets have a name label. Declarations have a name attribute. ToolInfos have a toolname attribute.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.name","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.name) # hide","category":"page"},{"location":"interface/#tag-access-XML-tag-symbol","page":"Interfaces","title":"tag - access XML tag symbol","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.tag","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.tag) # hide","category":"page"},{"location":"interface/#has_xml-is-xml-attached","page":"Interfaces","title":"has_xml - is xml attached","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_xml","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_xml) # hide","category":"page"},{"location":"interface/#xmlnode-access-xml","page":"Interfaces","title":"xmlnode - access xml","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.xmlnode","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.xmlnode) # hide","category":"page"},{"location":"interface/#nettype-return-PnmlType-identifying-PNTD","page":"Interfaces","title":"nettype - return PnmlType identifying PNTD","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.nettype","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.nettype) # hide","category":"page"},{"location":"interface/#Nodes-of-Petri-Net-Graph","page":"Interfaces","title":"Nodes of Petri Net Graph","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Return vector of nodes.","category":"page"},{"location":"interface/#places","page":"Interfaces","title":"places","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.places","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.places) # hide","category":"page"},{"location":"interface/#transitions","page":"Interfaces","title":"transitions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.transitions","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.transitions) # hide","category":"page"},{"location":"interface/#arcs","page":"Interfaces","title":"arcs","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.arcs","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.arcs) # hide","category":"page"},{"location":"interface/#refplaces","page":"Interfaces","title":"refplaces","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.refplaces","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.refplaces)  # hide","category":"page"},{"location":"interface/#reftransitions","page":"Interfaces","title":"reftransitions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.reftransitions","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.reftransitions)  # hide","category":"page"},{"location":"interface/#Node-Predicates-uses-PNML-ID","page":"Interfaces","title":"Node Predicates - uses PNML ID","text":"","category":"section"},{"location":"interface/#has_place","page":"Interfaces","title":"has_place","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_place","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_place)  # hide","category":"page"},{"location":"interface/#has_transition","page":"Interfaces","title":"has_transition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_place","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_transition)  # hide","category":"page"},{"location":"interface/#has_arc","page":"Interfaces","title":"has_arc","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_arc","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_arc) # hide","category":"page"},{"location":"interface/#has_refP","page":"Interfaces","title":"has_refP","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_refP","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_refP)  # hide","category":"page"},{"location":"interface/#has_refT","page":"Interfaces","title":"has_refT","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_refT","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_refT)  # hide","category":"page"},{"location":"interface/#Node-Access-uses-PNML-ID","page":"Interfaces","title":"Node Access - uses PNML ID","text":"","category":"section"},{"location":"interface/#place","page":"Interfaces","title":"place","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.place","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.place)  # hide","category":"page"},{"location":"interface/#transition","page":"Interfaces","title":"transition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.transition","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.transition) # hide","category":"page"},{"location":"interface/#arc","page":"Interfaces","title":"arc","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.arc","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.arc)  # hide","category":"page"},{"location":"interface/#refplace","page":"Interfaces","title":"refplace","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.refplace","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.refplace)  # hide","category":"page"},{"location":"interface/#reftransition","page":"Interfaces","title":"reftransition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.reftransition","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.reftransition)  # hide","category":"page"},{"location":"interface/#Node-ID-Vector","page":"Interfaces","title":"Node ID Vector","text":"","category":"section"},{"location":"interface/#place_ids","page":"Interfaces","title":"place_ids","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.place_ids","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.place_ids)  # hide","category":"page"},{"location":"interface/#transition_ids","page":"Interfaces","title":"transition_ids","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.transition_ids","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.transition_ids)  # hide","category":"page"},{"location":"interface/#arc_ids","page":"Interfaces","title":"arc_ids","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.arc_ids","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.arc_ids)  # hide","category":"page"},{"location":"interface/#refplace_ids","page":"Interfaces","title":"refplace_ids","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.refplace_ids","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.refplace_ids)  # hide","category":"page"},{"location":"interface/#reftransition_ids","page":"Interfaces","title":"reftransition_ids","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.reftransition_ids","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.reftransition_ids)  # hide","category":"page"},{"location":"interface/#Arc-Related","page":"Interfaces","title":"Arc Related","text":"","category":"section"},{"location":"interface/#all_arcs-source-or-target-is-PNML-ID","page":"Interfaces","title":"all_arcs - source or target is PNML ID","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.all_arcs","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.all_arcs)  # hide","category":"page"},{"location":"interface/#src_arcs-source-is-PNML-ID","page":"Interfaces","title":"src_arcs - source is PNML ID","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.src_arcs","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.src_arcs)  # hide","category":"page"},{"location":"interface/#tgt_arcs-target-is-PNML-ID","page":"Interfaces","title":"tgt_arcs - target is PNML ID","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"tgt_arcs","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.tgt_arcs)  # hide","category":"page"},{"location":"interface/#inscription-evaluate-inscription-value-(or-return-default)","page":"Interfaces","title":"inscription - evaluate inscription value (or return default)","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"inscription","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.inscription)  # hide","category":"page"},{"location":"interface/#deref!-dereference-all-references-of-flattened-net","page":"Interfaces","title":"deref! - dereference all references of flattened net","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"deref!","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.deref!)  # hide","category":"page"},{"location":"interface/#deref_place-dereference-one-place","page":"Interfaces","title":"deref_place - dereference one place","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"deref_place","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.deref_place)  # hide","category":"page"},{"location":"interface/#deref_transition-dereference-one-transition","page":"Interfaces","title":"deref_transition - dereference one transition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"deref_transition","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.deref_transition)  # hide","category":"page"},{"location":"interface/#Place-Related","page":"Interfaces","title":"Place Related","text":"","category":"section"},{"location":"interface/#marking-evaluate-marking-value-(or-return-default)","page":"Interfaces","title":"marking - evaluate marking value (or return default)","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"marking","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.marking)  # hide","category":"page"},{"location":"interface/#initialMarking","page":"Interfaces","title":"initialMarking -","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"initialMarking","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.initialMarking)  # hide","category":"page"},{"location":"interface/#Transition-Related","page":"Interfaces","title":"Transition Related","text":"","category":"section"},{"location":"interface/#conditions-collect-evaluated-conditions","page":"Interfaces","title":"conditions - collect evaluated conditions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"conditions","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.conditions)  # hide","category":"page"},{"location":"interface/#condition-evaluate-condition-of-one-transition","page":"Interfaces","title":"condition - evaluate condition of one transition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"condition","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.condition)  # hide","category":"page"},{"location":"interface/#transition_function-return-LVector-of-in_out-for-all-transitions","page":"Interfaces","title":"transition_function - return LVector of in_out for all transitions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"transition_function","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.transition_function)  # hide","category":"page"},{"location":"interface/#in_out-tuple-of-ins,-outs-of-one-transition","page":"Interfaces","title":"in_out - tuple of ins, outs of one transition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"in_out","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.in_out)  # hide","category":"page"},{"location":"interface/#ins-LVector-of-source-arc-evaluated-inscriptions.","page":"Interfaces","title":"ins - LVector of source arc evaluated inscriptions.","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"ins","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.ins)  # hide","category":"page"},{"location":"interface/#outs-LVector-of-target-arc-evaluated-inscriptions.","page":"Interfaces","title":"outs - LVector of target arc evaluated inscriptions.","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"outs","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.outs)  # hide","category":"page"},{"location":"interface/#Labels-Annotation-and-HLAnnotation","page":"Interfaces","title":"Labels - Annotation and HLAnnotation","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Both have ObjectCommon. HLAnnotation adds optional <text>, <structure>.","category":"page"},{"location":"interface/#has_text","page":"Interfaces","title":"has_text","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"has_text","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_text) # hide","category":"page"},{"location":"interface/#has_structure","page":"Interfaces","title":"has_structure","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"has_structure","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_structure) # hide","category":"page"},{"location":"interface/#text","page":"Interfaces","title":"text","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"text","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.text) # hide","category":"page"},{"location":"interface/#structure","page":"Interfaces","title":"structure","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"structure","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.structure) # hide","category":"page"},{"location":"interface/#has_labels-do-any-exist","page":"Interfaces","title":"has_labels - do any exist","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"has_labels","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_labels) # hide","category":"page"},{"location":"interface/#has_label-does-a-specific-label-exist","page":"Interfaces","title":"has_label - does a specific label exist","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"has_label","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_label) # hide","category":"page"},{"location":"interface/#get_label-get-a-specific-label","page":"Interfaces","title":"get_label - get a specific label","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"get_label","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.get_label) # hide","category":"page"},{"location":"interface/#ToolInfo","page":"Interfaces","title":"ToolInfo","text":"","category":"section"},{"location":"interface/#has_toolinfo-does-a-specific-toolinfo-exist","page":"Interfaces","title":"has_toolinfo - does a specific toolinfo exist","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"has_toolinfo","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_toolinfo) # hide","category":"page"},{"location":"interface/#get_toolinfo-get-a-specific-toolinfo-exist","page":"Interfaces","title":"get_toolinfo - get a specific toolinfo exist","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"get_toolinfo","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.get_toolinfo) # hide","category":"page"},{"location":"interface/#PnmlType-traits","page":"Interfaces","title":"PnmlType traits","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"See PnmlTypeDefs for details of the module.","category":"page"},{"location":"interface/#_evaluate,-functors,-markings,-inscriptions","page":"Interfaces","title":"_evaluate, functors, markings,  inscriptions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"_evaluate","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML._evaluate) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"default_marking","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.default_marking) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"default_inscription","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.default_inscription) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"default_condition","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.default_condition) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"default_one_term","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.default_one_term) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Things that are functors:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Marking: return Int, Float64, or Term\nInscription: return Int, Float64, or Term\nCondition: return Int, Float64, or Term\nTerm: return a sort's value","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Defaults","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"markings: return zero(Int), zero(Float64), or defaultzeroterm\ninscription: return one(Int), one(Float64), or defaultoneterm\ncondition: return true, or boolean sort's true value\nTerm: return boolean sort's true value","category":"page"},{"location":"acknowledgments/#Acknowledgments","page":"Acknowledgments","title":"Acknowledgments","text":"","category":"section"},{"location":"acknowledgments/#MathML.jl","page":"Acknowledgments","title":"MathML.jl","text":"","category":"section"},{"location":"acknowledgments/","page":"Acknowledgments","title":"Acknowledgments","text":"Its function map architecture was adopted and (permute|perverse|use)d in PNML.j.","category":"page"},{"location":"traits/#Traits","page":"Traits","title":"Traits","text":"","category":"section"},{"location":"traits/","page":"Traits","title":"Traits","text":"Some of the traits used are based on the pntd. Each supported pntd has a singleton subtype of PnmlType.","category":"page"},{"location":"traits/","page":"Traits","title":"Traits","text":"3 branches of pntd based on number system","category":"page"},{"location":"traits/","page":"Traits","title":"Traits","text":"core uses integers\nhigh-level uses terms of many-sorted algebra\ncontinuous/hybrid uses floating point","category":"page"},{"location":"traits/","page":"Traits","title":"Traits","text":"Default place markings and arc inscriptions are different for the three.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"CurrentModule = PNML","category":"page"},{"location":"pnml/#PNML.jl","page":"Petri Net Markup Language","title":"PNML.jl","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Documentation for the GitHub PNML.jl repository. Which defines a Julia module named PNML. Which handles an XML markup language with the acronym 'PNML' – Petri Net Markup Language.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"using Markdown\nusing Pkg\nusing Dates\nusing InteractiveUtils\n\nfunction print_dep_version(depname)\n    deps = Pkg.dependencies()\n    version = first(d for d in deps if d.second.name == depname).second.version\n\n    \"$depname: v$version\"\nend\n\nMarkdown.parse(\"\"\"\n\tThese docs were autogenerated at $(now()) on $(gethostname()) using:\n        - $(print_dep_version(\"PNML\"))\n\t    - $(print_dep_version(\"EzXML\"))\n   \"\"\")","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"using InteractiveUtils; # hide\nversioninfo()","category":"page"},{"location":"pnml/#www.pnml.org","page":"Petri Net Markup Language","title":"www.pnml.org","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"In this section 'PNML' refers to the markup language, its specification and schemas, not this software.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"http://www.pnml.org","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"has publications and tutorials covering PNML at various points in its evolution.\nhas links to a series of ISO/IEC 15909 standards relating to PNML. They cost money.\nis the cannonical site for the RELAX-NG XML schemas that define the grammer of several Petri Net Type Defintions (pntd), including:\nPT Net (Place/Transition Net)\nHigh-level Place/Transition Net\nSymmetric Net","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"There are 2 flavors currently covered by PNML: Discrete intger-valued & High-level many-sorted algebra. The ISO/IEC 15909-2 specification explicitly restricts the many-sorted algebra to use integers.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"It seems the people behind PNML are of the Model Driven Engineering (MDE) camp and have chosen Java, Eclipse and its modeling framework (EMF). They provide such EMF files on this site.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"There is GUI focus in the core pnml. Most of the Petri Net components, including the annotation lables, may have graphical presentation data attached. The page driven structure should be useful for at least GUIs.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"The high-level marking, inscription, condition and declaration are where the hard work waits.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"See A primer on the Petri Net Markup Language and ISO/IEC 15909-2(pdf) for more details. The rest of this page will hopefully make more sense if you are familiar with the primer's contents.","category":"page"},{"location":"pnml/#Interoperability","page":"Petri Net Markup Language","title":"Interoperability","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Petri Net Type Definition schema files (pntd) are defined using RELAX-NG XML Schema files. Petri Net Markup Language files (pnml) are intended to be validated against a pntd schema.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"For interchange of pnml between tools it should be enough to support the same pntd schema.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Note that ISO is working on part 3 of the PNML standard covering pntd (as of October 2021).","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"It is possible to create a non-standard pntd. And more will be standardized, either formally or informally. Non-standard mostly means that the interchangibility is restricted.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Since validation is not a goal of PNML.jl, non-standard pntds can be used for the URI of an XML net tag's type attribute. Notably pnmlcore and nonstandard are mapped to PnmlCoreNet.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"PnmlCoreNet is the minimum level of meaning that any pnml file can hold. PNML.jl should be able to create a valid intermediate representation using PnmlCoreNet since all the higher-level meaning is expressed as pnml labels, restrictions, and required XML tag names.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Further parsing of labels is specialized upon subtypes of PNML.AbstractPetriNet. See Traits for more details.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"If you want interchangability of pnml models, you will have to stick to the standard pnml pntds. The High Level Petri Net, even when restricted to symmetricnet.pntd, is very expressive. Even the base pnmlcore.pntd is useful.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Note that the official pntd schema files are in the grammer directory.","category":"page"},{"location":"pnml/#Why-no-Schema-Verification","page":"Petri Net Markup Language","title":"Why no Schema Verification","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Within PNML.jl no schema-level validation is done.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Note that, depending on context, 'PNML' may refer to either the markup language or the Julia code.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"In is allowed by the PNML specification to omit validation with the presumption that some specialized, external tool can be applied, thus allowing the file format to be used for inter-tool communication with lower overhead in each tool.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Also omiting pntd validation allows \"duck typing\" of Petri Nets built upon the PNML intermediate representration.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Of some note it that PNML.jl extends PNML. These, non-standard pntd do not (yet) have a schema written. See ContinuousNet.","category":"page"},{"location":"pnml/#PNTD-Maps","page":"Petri Net Markup Language","title":"PNTD Maps","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Defaut PNTD to Symbol map (URI string to pntd symbol):","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"using PNML; foreach(println, sort(collect(pairs(PnmlTypeDefs.default_pntd_map)))) #hide","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"PnmlType map (pntd symbol to singleton):","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"using PNML; foreach(println, pairs(PnmlTypeDefs.pnmltype_map)) #hide","category":"page"},{"location":"pnml/#Handling-Labels","page":"Petri Net Markup Language","title":"Handling Labels","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"The implementation of Labels supports annotation and attribute format labels.","category":"page"},{"location":"pnml/#Annotation-Labels","page":"Petri Net Markup Language","title":"Annotation Labels","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"annotation format labels are expected to have either a <text> element, a <structure> element or both. Often the <text> is a human-readable representation of of the <structure> element. Graphics and ToolInfo elements may be present.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"For PTNet (and pnmlcore) only the Name label with a <text> element (and no <structure> element) is defined.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Labels defined in High-Level pntds, specifically 'Symmetric Nets', \"require\" all meaning to reside in the <structure>.","category":"page"},{"location":"pnml/#Attribute-Labels","page":"Petri Net Markup Language","title":"Attribute Labels","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"attribute format labels are present in the UML model of pnml. They differ from annotation by omitting the Graphics element, but retain the ToolInfo element. Unless an optimization is identified, both attribute and annotation will share the same implementation.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"A standard-conforming pnml model would not have any Graphics element so that field would be nothing.","category":"page"},{"location":"pnml/#High-level-Petri-Net-Concepts","page":"Petri Net Markup Language","title":"High-level Petri Net Concepts","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"From a draft version of ISO/IEC 15909-1:2004 High-level Petri nets - Part 1: Concepts, definitions and graphical notation.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Useful for setting the ontology.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Arc inscriptions are expressions that are evaluated.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Place markings are multisets of tokens of a sort/type.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Transition conditions are boolean expressions that are evaluated. Used to determine if transition is enabled.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Expressions in pnml can be many-sorted algebras. Declaration, Term, Sort, Multiset, Variable, are among the concepts used to define expressions.","category":"page"},{"location":"pnml/#Terms","page":"Petri Net Markup Language","title":"Terms","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Terms have sorts: the sort of the variable or the output sort of the operator.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Terms can be buit from built-in operators and sorts, and user-defined variables. These are defined in variable declarations, a kind of annotation label attached to pages and nets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"A transition can have a condition, a term of sort boolean, which imposes restrictions on when the transition may fire.","category":"page"},{"location":"pnml/#Sorts","page":"Petri Net Markup Language","title":"Sorts","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"named sorts are constructed from existing sorts and given a new name.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"arbitrary sort is not defined in core, is not allowed in Symmetric Nets. HLPNG adds arbitrary declarations, sorts of lists, strings, integers to Symmetric Nets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"The sort of a term is the sort of the variable or the output sort of the operator.","category":"page"},{"location":"pnml/#Operators","page":"Petri Net Markup Language","title":"Operators","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"An operator can be: built-in constant, built-in operator, multiset operator or tuple operator.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"User-defined operators, or named operators are abbreviations, built from existing operators and parameter variables.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"There will be arbitrary operator declarations for High-Level Petri Net Graphs, but not for Symmetric Nets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Operators have a sequence of input sorts and a single output sort.","category":"page"},{"location":"pnml/#Variables","page":"Petri Net Markup Language","title":"Variables","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"TBD","category":"page"},{"location":"pnml/#Continuous,-Open-and-Other-Petri-Nets","page":"Petri Net Markup Language","title":"Continuous, Open and Other Petri Nets","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Allow marking, inscription, conditions to be floating point even when specification wants an integer. This allows continuous nets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"See Petri.jl and AlgebraicPetri.jl for some continuous use-cases.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"TODO: Hybrid nets combining floating point/continuous and integer/discrete inscription/marking.","category":"page"},{"location":"pnml/#References","page":"Petri Net Markup Language","title":"References","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"www.pnml.org","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"A primer on the Petri Net Markup Language and ISO/IEC 15909-2","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"ISO/IEC: Software and Systems Engineering – High-level Petri Nets, Part 1: Concepts Definitions and Graphical Notation, International Standard ISO/IEC 15909 (2004)","category":"page"},{"location":"parser/#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"parser/#Type-Map","page":"Parser","title":"Type Map","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"using PNML; using PNML: tagmap\nfor t in keys(tagmap)\n    println(t)\nend","category":"page"},{"location":"evaluate/#Evaluate-possible-functors","page":"Evaluate","title":"Evaluate possible functors","text":"","category":"section"},{"location":"evaluate/#Examples","page":"Evaluate","title":"Examples","text":"","category":"section"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"julia> _evaluate(1)\n1\n\njulia> _evaluate(true)\ntrue\n\njulia> _evaluate(Term(:term, (value = 3,))())\n3","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = PNML","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 5","category":"page"},{"location":"examples/#Lotka-Volterra","page":"Examples","title":"Lotka-Volterra","text":"","category":"section"},{"location":"examples/#Petri.jl-Starting-Point","page":"Examples","title":"Petri.jl Starting Point","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"https://github.com/mehalter/Petri.jl","category":"page"},{"location":"examples/#Example-2","page":"Examples","title":"Example 2","text":"","category":"section"},{"location":"examples/#Stuff-for-example-2","page":"Examples","title":"Stuff for example 2","text":"","category":"section"},{"location":"#PNML-has-High-Level","page":"Index","title":"PNML has High Level","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [PNML]","category":"page"},{"location":"#PnmlTypeDefs","page":"Index","title":"PnmlTypeDefs","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [PnmlTypeDefs]","category":"page"},{"location":"#PnmlIDRegistries","page":"Index","title":"PnmlIDRegistries","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [PnmlIDRegistrys]","category":"page"},{"location":"subpackages/#Sub-packages-of-PNML","page":"Subpackages","title":"Sub-packages of PNML","text":"","category":"section"},{"location":"subpackages/#PnmlTypeDefs","page":"Subpackages","title":"PnmlTypeDefs","text":"","category":"section"},{"location":"subpackages/","page":"Subpackages","title":"Subpackages","text":"See PnmlTypeDefs","category":"page"},{"location":"subpackages/#PnmlIDRegistrys","page":"Subpackages","title":"PnmlIDRegistrys","text":"","category":"section"},{"location":"subpackages/","page":"Subpackages","title":"Subpackages","text":"See PnmlIDRegistrys","category":"page"}]
}

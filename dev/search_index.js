var documenterSearchIndex = {"docs":
[{"location":"defaults/","page":"Default Values","title":"Default Values","text":"CurrentModule = PNML","category":"page"},{"location":"defaults/#Default-Values","page":"Default Values","title":"Default Values","text":"","category":"section"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"Varies by PNTD. Possibilitie include:","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"markings: return zero(Int), zero(Float64), or empty multiset of same sort as adjacent place's sorttype.\ninscription: return one(Int), one(Float64), or singleton multiset of same sort as adjacent place's sorttype with value of first(elements(sort)).\ncondition: return true, or BooleanConstant(true)","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"The ISO/IEC 15909-2 specification and the RelaxNG Schemas state 'natural numbers' and 'non-zero natural numbers'. I choose to also allow continuous values to support nonstandard continuous and hybrid valued Petri Nets. Makes generating default values more interesting.","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"Determine type of Number to parse with number_value by using pntd on:","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"condition_value_type\ninscription_value_type\nmarking_value_type\ncoordinate_value_type\nremoved termvaluetype\nrate_value_type","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"There are many items in the XML that are permitted to be missing and a defaut value is assumed. Examples are place initial marking, arc inscription, transition condition, graphics data.","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"place initial marking is assumed to be empty, i. e. 0.\narc inscription is assumed to be 1.\ntransition condition is assumed to be true\ngraphics data, e.g. token position, line width, are TBD","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"There are multiple kinds of nets supported by PNML.jl differing by (among other properties) the kind on number they use:","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"discrete,\ncontinuous,\nand multi-sorted algebra","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"See PnmlType - Petri Net Type Definition for the full hierarchy.","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"This means there are at least 3 sets of default value types. We use the pntd PnmlType as a trait to determine the default types/values.","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"A consequence is that the default value's type ripples through the type system.","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"using AbstractTrees, PNML, InteractiveUtils, Markdown\nusing PNML: default_condition\nusing PNML: default_inscription, default_hlinscription\nusing PNML: default_marking, default_hlmarking\nusing PNML: SortType, UserSort, IntegerSort, DotSort,\n            PnmlCoreNet, ContinuousNet, HLCoreNet,\n            NumberConstant, DotConstant\n\nlist_type(f) = for pntd in values(PNML.PnmlTypeDefs.pnmltype_map)\n    println(rpad(pntd, 15), \" -> \", f(pntd))\nend","category":"page"},{"location":"defaults/#Methods","page":"Default Values","title":"Methods","text":"","category":"section"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_marking","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"methods(PNML.default_marking) # hide","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_inscription","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"methods(PNML.default_inscription) # hide","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"PNML.default_condition","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"methods(PNML.default_condition) # hide","category":"page"},{"location":"defaults/#Examples","page":"Default Values","title":"Examples","text":"","category":"section"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"DocTestSetup = quote\n    using Base.ScopedValues\n    using PNML\n    using PNML: default_condition\n    using PNML: default_inscription, default_hlinscription\n    using PNML: default_marking, default_hlmarking\n    using PNML: SortType, UserSort, IntegerSort, DotSort,\n                PnmlCoreNet, ContinuousNet, HLCoreNet,\n                NumberConstant, DotConstant\n end","category":"page"},{"location":"defaults/","page":"Default Values","title":"Default Values","text":"julia> c = @with PNML.DECLDICT => PNML.DeclDict() default_condition(PnmlCoreNet())\nCondition(\"\", BooleanEx(PNML.BooleanConstant(true)))\n\njulia> c()\ntrue\n\njulia> c = @with PNML.DECLDICT => PNML.DeclDict() default_condition(ContinuousNet())\nCondition(\"\", BooleanEx(PNML.BooleanConstant(true)))\n\njulia> c = @with PNML.DECLDICT => PNML.DeclDict() default_condition(HLCoreNet())\nCondition(\"\", BooleanEx(PNML.BooleanConstant(true)))","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"High-level nets are not completely implemented. This statement will remain true as incremental progress is slowly made. It is safe to state this will be one of the last feature to near completion.","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"(as of November 2022). Supporting continuous/hybrid high-level nets may not be possible. We currently do not try. Note this is a extension to what the specifiction covers: natural numbers.","category":"page"},{"location":"status/#Roadmap","page":"Status","title":"Roadmap","text":"","category":"section"},{"location":"status/","page":"Status","title":"Status","text":"https://www.pnml.org/tools.php lists two expected features of a \"PNML supporting tool\":","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"create PNML files conforming to a PNTD meta-model\nload PNML files and use PNTD meta-models to \"make\" a Petri Net","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"with the presumption that one does something useful.","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"Have not considered any part of creating or writing out a Petri Net model. This package, PNML.jl, aims to provide infrastructure to interact with other Julia packages, including graphs, category theory, SciML, agents. All focus has been on the \"load\" part of the expected behavior. The meta-models are encoded in the structure of PNML.jl, notably in the type system. Doing \"something useful\" is mostly aspriational until adequate function is present.","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"The first useful things will be trivial and obvious:","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"display the PNML Model\nanalyze the PNML Model\nconstruct a Petri.jl Model to solve an ODE.  # maybe not trivial or obvious :)","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"Next will be to interface with graph-theoretical packages. Enhancing the display and analysis features.","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"Editing petri net models is not planned, so writing the model is trivial","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"Checkpointing and writing in some \"non-PNML\" format is another anticipated feature.","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"Features mentioned in ISO/IEC 15909-3:2021 Part 3: Extensions and Structuring Mechanisms","category":"page"},{"location":"status/","page":"Status","title":"Status","text":"special arcs: inhibitor, read, reset\ncapacity place: maximum multiset of tokens a place can hold\nFIFO queue place (queues in general)\nsort generator: sorts and operators from signatures","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"CurrentModule = PNML","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Overview of some type hierarchies.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"using AbstractTrees, PNML, InteractiveUtils, Markdown\n#, GraphRecipes,Plots\n\nAbstractTrees.children(x::Type) = subtypes(x)\ntype_tree(t) = println(AbstractTrees.repr_tree(t))","category":"page"},{"location":"type_hierarchies/#PnmlType-Petri-Net-Type-Definition","page":"Type Hierarchies","title":"PnmlType - Petri Net Type Definition","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"See PnmlTypeDefs module page.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"There are levels:  Core (Place-Transition), Continuous and High-Level PNG (HLPNG).","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"PnmlCoreNet is a concrete subtype of PnmlType. PnmlCoreNet is used by some AbstractPetriNet concrete types (SimpleNet).","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"ContinuousNet is a concrete type of AbstractContinuousNet. ContinuousNet uses floating point marking and inscriptions. It is a nonstandard extension to the ISO specification.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"HLCoreNet is a concrete subtype of AbstractHLCore. HLCoreNet is used by some AbstractPetriNet concrete types (HLPetriNet). Think of it as a testable implementation of AbstractHLCore.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"The IR does not try to impose semantics on the model. Those semantics should be part of AbstractPetriNet.  The IR tries to represent the model (all models) at a structural level. It may paramertize types to facilitate specilization.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.PnmlTypeDefs.PnmlType) # hide","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"PnmlType Description\nPnmlCoreNet <name> is only defined label\nPTNet <initialMarking>, <inscription> labels only have <text>\nHLCoreNet support structure used by all HL Petri Net Graphs\nPT-HLPNG restrict sort to dot, condition always true\nSymmetricNet restrict sorts to finite, annotations have <structure>\nHLNet extend symmetric with arbitrary sorts\nStochastic continuous or discrete\nTimed continuous or discrete\nOpen continuous or discrete","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Todo: Continuous Petri Net","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Full Name Node Label Description\nMarking Place \nInscription Arc \nHLMarking Place \nHLInscription Arc \nCondition Transition \nRate Transition random variable or function of marking, firing rate\nPriority Transition firing order of enabled transitions\nWeight Transition firing tiebreaker","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Note that Rate, Priority and Weight are not part of base specification. See Unclaimed Labels","category":"page"},{"location":"type_hierarchies/#AbstractPetriNet","page":"Type Hierarchies","title":"AbstractPetriNet","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"AbstractPetriNet uses the Intermediate Representation's PnmlNet and PnmlType to implement a Petri Net Graph (PNG).","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractPetriNet) # hide","category":"page"},{"location":"type_hierarchies/#AbstractPnmlObject","page":"Type Hierarchies","title":"AbstractPnmlObject","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Page, Arc, Place, Transition define the graph of a PnmlNet.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractPnmlObject) # hide","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Fields expected of every subtype of AbstractPnmlObject:","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Name Type\nid Symbol\npntd <: PnmlType\nname Maybe{Name}\nlabels PnmlLabel\ntools ToolInfo","category":"page"},{"location":"type_hierarchies/#AbstractLabel","page":"Type Hierarchies","title":"AbstractLabel","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"AbstractLabels are attached to AbstractPnmlObjects. Kinds of label include: marking, inscription, condition and declarations, sort, and ad-hoc. Ad-hoc is where we assume any undefined element attached to a AbstractPnmlObject instance is a label and add it to a collection of 'other labels'. Some 'other labels' can be accessed using: rate, delay.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractLabel) # hide","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"info: Difference between Object and Label\nObjects have ids and Names.\nLabels are attached to Objects.\nSome Labels (attributes) do not have Graphics.\nLabels are extendable.\nLabels are named by the xml tag. Any \"unknown\" tag of an Object is presumed to be a label.","category":"page"},{"location":"type_hierarchies/#AbstractPnmlTool","page":"Type Hierarchies","title":"AbstractPnmlTool","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"See ToolInfo.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractPnmlTool) # hide","category":"page"},{"location":"type_hierarchies/#PnmlException","page":"Type Hierarchies","title":"PnmlException","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.PnmlException) # hide","category":"page"},{"location":"type_hierarchies/#Many-sorted-Algebra-Concepts","page":"Type Hierarchies","title":"Many-sorted Algebra Concepts","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"The PNML Specification builds the High-level Petri Net Graph as a layer using a Core layer (PnmlCore). The main feature of the HL layer (HLCore) is to require all annotation labels to have <text> and <structure> elements. All meaning is required to reside in a single child of <structure>. With the <text> for human/documentation use.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Implemented so that it is mostly part of the PnmlCore implementation. At which level, both <text> and <structure> are optional.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"The <type> label of a Place is meant to be a sort of a many-sorted algebra. We call it sorttype to reduce the confusion.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"PNML.jl allows/requires all net type's places to have sorttype objects. Only high-level PNML input is expected to contain a <type> tag. For other nets we interpret the SortType to be IntegerSort or RealSort based on PNTD. And Marking values of non-high-level nets are interpreted as multisets with airity of 1. This allows more common implementation in the core layer.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"For high-level nets the sorttype object is an SortType HLAnnotation subtype containing an AbstractSort.","category":"page"},{"location":"type_hierarchies/#AbstractDeclaration","page":"Type Hierarchies","title":"AbstractDeclaration","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Labels attached to PnmlNet and/or Page. The Declarations contained in a <declarations> apply to the whole net even when attached to a Page.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractDeclaration) # hide","category":"page"},{"location":"type_hierarchies/#AbstractSort","page":"Type Hierarchies","title":"AbstractSort","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Each Place has a sorttype containing an AbstractSort.","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractSort) # hide","category":"page"},{"location":"type_hierarchies/#AbstractTerm","page":"Type Hierarchies","title":"AbstractTerm","text":"","category":"section"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"Part of the many-sorted algebra of a High-level net. See AbstractOperator. Variable","category":"page"},{"location":"type_hierarchies/","page":"Type Hierarchies","title":"Type Hierarchies","text":"type_tree(PNML.AbstractTerm) # hide","category":"page"},{"location":"IR/","page":"-","title":"-","text":"CurrentModule = PNML","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"CurrentModule = PNML","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Pages = [\"interface.md\"]\nDepth = 5","category":"page"},{"location":"interface/#Interface","page":"Interfaces","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"warning: Warning\nBeing a work in progress, there will be obsolete, optimistic or incoherent bits.Eventually this section will cover interfaces in a useful way.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The intermediate representation is used to implement networks expressed in a pnml model. The consumer of the IR is a network is most naturally a varity of Petri Net.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"We start a description of the net IR here.","category":"page"},{"location":"interface/#DictType","page":"Interfaces","title":"DictType","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Used by:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"AnyElement\nLabels.PnmlLabel\nLabels.SortType","category":"page"},{"location":"interface/#Top-Level:-Model,-Net,-Page","page":"Interfaces","title":"Top Level: Model, Net, Page","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"At the top level[layers] a <pnml> model is one or more networks::PnmlNet, each described by a <net> tag and one or more <page> tags.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Page  is a required element mostly present for visual presentation to humans. It contains AbstractPnmlObject types that implement the Petri Net Graph (PNG).","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"[layers]: Page inside a PnmlNet inside a AbstractPetriNet. Where the Petri Net part is expressed as a Petri Net Type Definition XML schema file (.pntd) identified by a URI. Or would if our nonstandard extensions had schemas defined. Someday there will be such schemas.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"While Graphics is implemented it is not dicussed further (until someone extends/uses it).","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"ToolInfo used to attach well-formed XML almost anywhere in the PNG. TODO: Need way to parse <toolspecific> that is flexible/extendable.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Parse pnml for input, worry about writing back out and interchange later (future extensions). Another future extension may be to use pages for distributed computing.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The pnml specification permits that multiple pages to be flattened (by flatten_pages!) to a single Page before use. Using them unflattened is not supposed to be impossible, but is not the arena or the initial use cases (in no paticular order): adapting to use graph tools, agent based modeling, sciml, etc.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"AbstractPetriNet subtypes wrap and extend PnmlNet. Note the Pnml to Petri.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PnmlNet and its contents can be considered an intermediate representation (IR). A concrete AbstractPetriNet type uses the IR to produce higher-level behavior. This is the level at which flatten_pages! and deref! operate.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"AbstractPetriNet is the level of most Petri Net Graph semantics. One example is enforcing integer, non-negative, positive. One mechanism used is type parameters.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Remember, the IR trys to be as promiscuous as possible.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"XML <net> tags are parsed by parse_net into a PnmlNet.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"XML <page> tags are parsed by parse_page! into a Page.","category":"page"},{"location":"interface/#Places","page":"Interfaces","title":"Places","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Properties that various places may have one or more of:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"discrete\ncontinuous\ntimed","category":"page"},{"location":"interface/#Transitions","page":"Interfaces","title":"Transitions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Properties that various transitions may have one or more of:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"discrete\ncontinuous\nhybrid of discrete & continuous subnets\nstochastic\nimmediate\ndeterministically time delayed\nscheduled","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The pnml schemas and primer only try to cover the discrete case as Place-Transition and High-Level Petri Nets.","category":"page"},{"location":"interface/#Extensions-to-PNML","page":"Interfaces","title":"Extensions to PNML","text":"","category":"section"},{"location":"interface/#Continuous-Values","page":"Interfaces","title":"Continuous Values","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Continous support is present where possible. For instance, when a number appers in the XML number_value is used to parse the string to Int or Float64. This is currently (2022) \"non-standard\" so such pnml files will not be generally interchangable with other tools.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"'Discrete, Continuous, and Hybrid Petri Nets' by Rene David and Hassane Alla","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"VANESA","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"See rate for a use of non-standard labels by SimpleNet. Implements a continuous petri net as part of the first working use-case. Demonstrates the expressiveness of pnml.","category":"page"},{"location":"interface/#Petri-Net-Graphs-and-Networks","page":"Interfaces","title":"Petri Net Graphs and Networks","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"There are 3 top-level forms:","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"AbstractPetriNet subtypes wraping a single PnmlNet.\nPnmlNet  maybe multiple pages.\nPage when the only page of the only net in a Abstractpetrinet.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The simplest arrangement is a pnml model with a single <net> element having a single page. Any <net> may be flatten to a single page.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The initial AbstractPetriNet subtypes are built using the assumption that multiple pages will be flattened to a single page.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"using AbstractTrees, PNML, InteractiveUtils, Markdown","category":"page"},{"location":"interface/#Simple-Interface-Methods","page":"Interfaces","title":"Simple Interface Methods","text":"","category":"section"},{"location":"interface/#pid-get-PNML-ID-symbol","page":"Interfaces","title":"pid - get PNML ID symbol","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Objects within a pnml graph have unique identifiers, which are used for referring to the object. This includes: AbstractPnmlObject subtypes, PnmlNet.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.pid","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.pid) # hide","category":"page"},{"location":"interface/#name-get-name","page":"Interfaces","title":"name - get name","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"AbstractPnmlObjects and PnmlNets have a name label. PNML.Labels.Declarations have a name attribute. ToolInfos have a toolname attribute.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.name","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.name) # hide","category":"page"},{"location":"interface/#tag-access-XML-tag-symbol","page":"Interfaces","title":"tag - access XML tag symbol","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.tag","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.tag) # hide","category":"page"},{"location":"interface/#nettype-return-PnmlType-identifying-PNTD","page":"Interfaces","title":"nettype - return PnmlType identifying PNTD","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.nettype","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.nettype) # hide","category":"page"},{"location":"interface/#Nodes-of-Petri-Net-Graph","page":"Interfaces","title":"Nodes of Petri Net Graph","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Return vector of nodes.","category":"page"},{"location":"interface/#places","page":"Interfaces","title":"places","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.places","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.places) # hide","category":"page"},{"location":"interface/#transitions","page":"Interfaces","title":"transitions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.transitions","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.transitions) # hide","category":"page"},{"location":"interface/#arcs","page":"Interfaces","title":"arcs","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.arcs","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.arcs) # hide","category":"page"},{"location":"interface/#refplaces","page":"Interfaces","title":"refplaces","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.refplaces","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.refplaces)  # hide","category":"page"},{"location":"interface/#reftransitions","page":"Interfaces","title":"reftransitions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.reftransitions","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.reftransitions)  # hide","category":"page"},{"location":"interface/#Node-Predicates-uses-PNML-ID","page":"Interfaces","title":"Node Predicates - uses PNML ID","text":"","category":"section"},{"location":"interface/#has_place","page":"Interfaces","title":"has_place","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_place","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_place)  # hide","category":"page"},{"location":"interface/#has_transition","page":"Interfaces","title":"has_transition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_place","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_transition)  # hide","category":"page"},{"location":"interface/#has_arc","page":"Interfaces","title":"has_arc","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_arc","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_arc) # hide","category":"page"},{"location":"interface/#has_refplace","page":"Interfaces","title":"has_refplace","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_refplace","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_refplace)  # hide","category":"page"},{"location":"interface/#has_reftransition","page":"Interfaces","title":"has_reftransition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.has_reftransition","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_reftransition)  # hide","category":"page"},{"location":"interface/#Node-Access-uses-PNML-ID","page":"Interfaces","title":"Node Access - uses PNML ID","text":"","category":"section"},{"location":"interface/#place","page":"Interfaces","title":"place","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.place","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.place)  # hide","category":"page"},{"location":"interface/#transition","page":"Interfaces","title":"transition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.transition","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.transition) # hide","category":"page"},{"location":"interface/#arc","page":"Interfaces","title":"arc","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.arc","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.arc)  # hide","category":"page"},{"location":"interface/#refplace","page":"Interfaces","title":"refplace","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.refplace","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.refplace)  # hide","category":"page"},{"location":"interface/#reftransition","page":"Interfaces","title":"reftransition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.reftransition","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.reftransition)  # hide","category":"page"},{"location":"interface/#Node-ID-Iteratables","page":"Interfaces","title":"Node ID Iteratables","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Better to iterate than allocate. Using a set abstraction that iterates consistently, perhaps in insertion order.","category":"page"},{"location":"interface/#place_idset","page":"Interfaces","title":"place_idset","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Object Synopsis Comment\nAbstractPetriNet place_idset(pnmlnet)) forward to pnml net\nPnmlNet keys(placedict(net)) of PnmlNetData OrderedDict\nPage place_idset(netsets(page)) of PnmlNetKeys Set\nPnmlNetKeys s.place_set ","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The contents of PnmlKeySet are indices into PnmlNetData. When there is only one page, the keys of the placedict and place_set will be (must be) the same. The order of the two may differ.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Do they have the same type? place_dict::OrderedCollections.OrderedDict{Symbol, P} place_set::Set{Symbol}","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"For the foreseeable future, there will be little use of multi-page APIs. It is expected that flattened PNML nets will be the fully supported, tested, thought-through API.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.place_idset","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.place_idset)  # hide","category":"page"},{"location":"interface/#transition_idset","page":"Interfaces","title":"transition_idset","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.transition_idset","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.transition_idset)  # hide","category":"page"},{"location":"interface/#arc_idset","page":"Interfaces","title":"arc_idset","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.arc_idset","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.arc_idset)  # hide","category":"page"},{"location":"interface/#refplace_idset","page":"Interfaces","title":"refplace_idset","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.refplace_idset","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.refplace_idset)  # hide","category":"page"},{"location":"interface/#reftransition_idset","page":"Interfaces","title":"reftransition_idset","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.reftransition_idset","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.reftransition_idset)  # hide","category":"page"},{"location":"interface/#Arc-Related","page":"Interfaces","title":"Arc Related","text":"","category":"section"},{"location":"interface/#all_arcs-source-or-target-is-PNML-ID","page":"Interfaces","title":"all_arcs - source or target is PNML ID","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.all_arcs","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.all_arcs)  # hide","category":"page"},{"location":"interface/#src_arcs-source-is-PNML-ID","page":"Interfaces","title":"src_arcs - source is PNML ID","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"PNML.src_arcs","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.src_arcs)  # hide","category":"page"},{"location":"interface/#tgt_arcs-target-is-PNML-ID","page":"Interfaces","title":"tgt_arcs - target is PNML ID","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"tgt_arcs","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.tgt_arcs)  # hide","category":"page"},{"location":"interface/#inscription-evaluate-inscription-value-(or-return-default)","page":"Interfaces","title":"inscription - evaluate inscription value (or return default)","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"inscription","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.inscription)  # hide","category":"page"},{"location":"interface/#deref!-dereference-all-references-of-flattened-net","page":"Interfaces","title":"deref! - dereference all references of flattened net","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"deref!","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.deref!)  # hide","category":"page"},{"location":"interface/#deref_place-dereference-one-place","page":"Interfaces","title":"deref_place - dereference one place","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"deref_place","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.deref_place)  # hide","category":"page"},{"location":"interface/#deref_transition-dereference-one-transition","page":"Interfaces","title":"deref_transition - dereference one transition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"deref_transition","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.deref_transition)  # hide","category":"page"},{"location":"interface/#Place-Related","page":"Interfaces","title":"Place Related","text":"","category":"section"},{"location":"interface/#initial_marking-evaluate-marking-value-(or-return-default)","page":"Interfaces","title":"initial_marking - evaluate marking value (or return default)","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"initial_marking","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.initial_marking)  # hide","category":"page"},{"location":"interface/#initial_markings-return-LVector-of-marking-values-labeled-by-place-id","page":"Interfaces","title":"initial_markings - return LVector of marking values labeled by place id","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"initial_markings","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.initial_markings)  # hide","category":"page"},{"location":"interface/#Transition-Related","page":"Interfaces","title":"Transition Related","text":"","category":"section"},{"location":"interface/#conditions-collect-evaluated-conditions","page":"Interfaces","title":"conditions - collect evaluated conditions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"conditions","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.conditions)  # hide","category":"page"},{"location":"interface/#condition-evaluate-condition-of-one-transition","page":"Interfaces","title":"condition - evaluate condition of one transition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"condition","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.condition)  # hide","category":"page"},{"location":"interface/#transition_function-return-LVector-of-in_out-for-all-transitions","page":"Interfaces","title":"transition_function - return LVector of in_out for all transitions","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"transition_function","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.transition_function)  # hide","category":"page"},{"location":"interface/#in_out-tuple-of-ins,-outs-of-one-transition","page":"Interfaces","title":"in_out - tuple of ins, outs of one transition","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"in_out","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.in_out)  # hide","category":"page"},{"location":"interface/#ins-LVector-of-source-arc-evaluated-inscriptions.","page":"Interfaces","title":"ins - LVector of source arc evaluated inscriptions.","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"ins","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.ins)  # hide","category":"page"},{"location":"interface/#outs-LVector-of-target-arc-evaluated-inscriptions.","page":"Interfaces","title":"outs - LVector of target arc evaluated inscriptions.","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"outs","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.outs)  # hide","category":"page"},{"location":"interface/#Labels-Annotation-and-HLAnnotation","page":"Interfaces","title":"Labels - Annotation and HLAnnotation","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Both have Graphics and ToolInfo. Labels.HLAnnotation adds optional <text>, <structure>.","category":"page"},{"location":"interface/#text","page":"Interfaces","title":"text","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"text","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.text) # hide","category":"page"},{"location":"interface/#value","page":"Interfaces","title":"value","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"value","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.value) # hide","category":"page"},{"location":"interface/#has_labels-do-any-exist","page":"Interfaces","title":"has_labels - do any exist","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"has_labels","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_labels) # hide","category":"page"},{"location":"interface/#has_label-does-a-specific-label-exist","page":"Interfaces","title":"has_label - does a specific label exist","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"has_label","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_label) # hide","category":"page"},{"location":"interface/#get_label-get-a-specific-label","page":"Interfaces","title":"get_label - get a specific label","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"get_label","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.get_label) # hide","category":"page"},{"location":"interface/#ToolInfo","page":"Interfaces","title":"ToolInfo","text":"","category":"section"},{"location":"interface/#has_toolinfo-does-a-specific-toolinfo-exist","page":"Interfaces","title":"has_toolinfo - does a specific toolinfo exist","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"has_toolinfo","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.has_toolinfo) # hide","category":"page"},{"location":"interface/#get_toolinfo-get-a-specific-toolinfo-exist","page":"Interfaces","title":"get_toolinfo - get a specific toolinfo exist","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"get_toolinfo","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.get_toolinfo) # hide","category":"page"},{"location":"interface/#PnmlType-traits","page":"Interfaces","title":"PnmlType traits","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"See PnmlTypeDefs for details of the singleton types used.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"pnmlnet_type","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.pnmlnet_type) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"page_type","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.page_type) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"marking_type","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.marking_type) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"inscription_type","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.inscription_type) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"condition_type","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.condition_type) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"place_type","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.place_type) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"transition_type","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.transition_type) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"arc_type","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.arc_type) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"refplace_type","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.refplace_type) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"reftransition_type","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"methods(PNML.reftransition_type) # hide","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"info: parse_type is different\nParser.parse_type is used to parse an XML <type> element. It is not one of these look-up a type trait methods.","category":"page"},{"location":"acknowledgments/#Acknowledgments","page":"Acknowledgments","title":"Acknowledgments","text":"","category":"section"},{"location":"acknowledgments/#MathML.jl","page":"Acknowledgments","title":"MathML.jl","text":"","category":"section"},{"location":"acknowledgments/","page":"Acknowledgments","title":"Acknowledgments","text":"Its function map architecture was adopted and (permute|perverse|use)d in PNML.j.","category":"page"},{"location":"library/","page":"Docstrings","title":"Docstrings","text":"CurrentModule = PNML","category":"page"},{"location":"library/#PNML-Reference","page":"Docstrings","title":"PNML Reference","text":"","category":"section"},{"location":"library/","page":"Docstrings","title":"Docstrings","text":"Modules = [PNML, PNML.PnmlTypeDefs, PNML.PnmlIDRegistrys,\n            PNML.Sorts, PNML.Declarations, PNML.PnmlGraphics, PNML.Labels, PNML.Parser]","category":"page"},{"location":"library/#PNML.PNML","page":"Docstrings","title":"PNML.PNML","text":"Petri Net Markup Language, is an XML-based format. PNML.jl reads a pnml model and emits an intermediate representation (IR).\n\nThe intermediate representation (IR) represents the XML tree via julia data structures: dictionaries, NamedTuples, LabelledArrays, strings, numbers, objects, vectors. The exact mixture changes as the project continues.\n\nThe tags of the XML are used as keys and names as much as possible.\n\nWhat is accepted as values is ~~often~~ a superset of what a given pntd schema specifies. This can be thought of as duck-typing. Conforming to the pntd is not the role of the IR.\n\nThe pnml specification has layers. This package has layers: PnmlNet, AbstractPetriNet\n\nThe core layer is useful and extendable. The standard defines extensions of the core, called meta-models, for\n\nplace-transition petri nets (integers) and\nhigh-level petri net graphs (many-sorted algebra).\n\nThis package family adds non-standard continuous net (float64) support. Note that there is not yet any RelaxNG schema for our extensions.\n\nOn top of the concrete PnmlNet of the IR are net adaptions and interpertations. This is the level that Petri Net conformance can be imposed. It is also where other Net constructs can be defined over PnmlNets. Perhaps as new meta-models.\n\n\n\n\n\n","category":"module"},{"location":"library/#PNML.CONFIG","page":"Docstrings","title":"PNML.CONFIG","text":"See PnmlConfig for default values.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.Maybe","page":"Docstrings","title":"PNML.Maybe","text":"Alias for Union{T, Nothing}.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.XDVT","page":"Docstrings","title":"PNML.XDVT","text":"XMLDict values type. Maybe too large for union-splitting.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.idregistry","page":"Docstrings","title":"PNML.idregistry","text":"ID registry of the current scope. Nets are the usual scope = a net-level-global.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.AbstractOperator","page":"Docstrings","title":"PNML.AbstractOperator","text":"abstract type AbstractOperator <: PNML.AbstractTerm\n\nOperators are part of the high-level pnml many-sorted algebra.\n\n...can be a built-in constant or a built-in operator, a multiset operator which among others can construct a multiset from an enumeration of its elements, or a tuple operator. Each operator has a sequence of sorts as its input sorts, and exactly one output sort, which defines its signature.\n\nSee NamedOperator and ArbitraryOperator.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractPetriNet","page":"Docstrings","title":"PNML.AbstractPetriNet","text":"abstract type AbstractPetriNet{PNTD<:PNML.PnmlTypeDefs.PnmlType}\n\nTop-level of a single network in a pnml model that is some flavor of Petri Net. Note that pnml can represent nets that are not Petri Nets.\n\nHere is where specialization and restriction are applied to achive Proper Petri Behavior.\n\nSee PnmlModel, PnmlType.\n\nExtended\n\nAdditional constrants can be imposed. We want to run under the motto: \"syntax is not semantics, quack\".\n\nSince a PNML.Document model can contain multiple networks it is possible that a higher-level will create multiple AbstractPetriNet instances, each a different type.\n\nMultiple Pages can (are permitted to) be merged into one page by flatten_pages! without losing any Petri Net semantics.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractPnmlNode","page":"Docstrings","title":"PNML.AbstractPnmlNode","text":"abstract type AbstractPnmlNode{PNTD} <: PNML.AbstractPnmlObject\n\nPetri Net Graph nodes are Place, Transition. They are the source or target of an Arc\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractPnmlObject","page":"Docstrings","title":"PNML.AbstractPnmlObject","text":"abstract type AbstractPnmlObject\n\nObjects of a Petri Net Graph are pages, arcs, nodes.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractPnmlTool","page":"Docstrings","title":"PNML.AbstractPnmlTool","text":"abstract type AbstractPnmlTool\n\nTool specific information objects can be attached to nodes and labels, AbstractPnmlObjects and AbstractLabels subtypes.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractTerm","page":"Docstrings","title":"PNML.AbstractTerm","text":"abstract type AbstractTerm\n\nTerms are part of the multi-sorted algebra that is part of a High-Level Petri Net.\n\nAn abstract type in the pnml XML specification, concrete Terms are variables and operators found within the <structure> element of a label.\n\nNotably, a Term is not a PnmlLabel (or a PNML Label).\n\nReferences\n\nSee also Declaration, Labels.SortType, AbstractDeclaration.\n\nTerm_(logic):\n\nA first-order term is recursively constructed from constant symbols, variables and function symbols.\n\nBesides in logic, terms play important roles in universal algebra, and rewriting systems.\n\nmore convenient to think of a term as a tree.\n\nA term that doesn't contain any variables is called a ground term\n\nWhen the domain of discourse contains elements of basically different kinds, it is useful to split the set of all terms accordingly. To this end, a sort (sometimes also called type) is assigned to each variable and each constant symbol, and a declaration...of domain sorts and range sort to each function symbol....\n\nType_theory\n\nterm in logic is recursively defined as a constant symbol, variable, or a function application, where a term is applied to another term\n\nif t is a term of type σ → τ, and s is a term of type σ, then the application of t to s, often written (t s), has type τ.\n\nLambda terms:\n\nThe term redex, short for reducible expression, refers to subterms that can be reduced by one of the reduction rules.\n\nSee Metatheory and SymbolicUtils\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AbstractVariable","page":"Docstrings","title":"PNML.AbstractVariable","text":"abstract type AbstractVariable <: PNML.AbstractTerm\n\nVariables are part of the high-level pnml many-sorted algebra.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.AnyElement","page":"Docstrings","title":"PNML.AnyElement","text":"struct AnyElement\n\ntag::Symbol\nelements::Union{SubString{String}, String, OrderedCollections.LittleDict{Union{String, Symbol}, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Union{String, Symbol}}}, AbstractVector{Union{String, Symbol}}}, VS<:Union{Tuple, AbstractVector{Any}}}, Vector{Union{SubString{String}, String, OrderedCollections.LittleDict{Union{String, Symbol}, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Union{String, Symbol}}}, AbstractVector{Union{String, Symbol}}}, VS<:Union{Tuple, AbstractVector{Any}}}}}}\n\nHold well-formed XML. See also ToolInfo and PnmlLabel.\n\nCreates a tree whose nodes are Union{DictType, String, SubString{String}}. #TODO when can there be leaf nodes of String, Substring{String?} See DictType.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Arc","page":"Docstrings","title":"PNML.Arc","text":"Edge of a Petri Net Markup Language graph that connects place and transition.\n\nmutable struct Arc{I<:Union{PNML.Labels.HLInscription, PNML.Labels.Inscription}} <: PNML.AbstractPnmlObject\n\nid::Symbol\nsource::Base.RefValue{Symbol}\ntarget::Base.RefValue{Symbol}\ninscription::Union{PNML.Labels.HLInscription, PNML.Labels.Inscription}\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\nlabels::Union{Nothing, Vector{PNML.Labels.PnmlLabel}}\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Bag","page":"Docstrings","title":"PNML.Bag","text":"Bag: a TermInterface expression calling pnmlmultiset(basis, x, multi) to construct a PnmlMultiset.\n\nSee Operator for another TermInterface operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.BoolExpr","page":"Docstrings","title":"PNML.BoolExpr","text":"TermInterface boolean expression types.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.BooleanConstant","page":"Docstrings","title":"PNML.BooleanConstant","text":"BooleanConstant(\"true\"|\"false\")\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.BooleanEx","page":"Docstrings","title":"PNML.BooleanEx","text":"BooleanEx\n\nTermInterface expression for a BooleanSort.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.DeclDict","page":"Docstrings","title":"PNML.DeclDict","text":"struct DeclDict\n\nvariabledecls::Dict{Symbol, Any}\nnamedsorts::Dict{Symbol, Any}\narbitrarysorts::Dict{Symbol, Any}\npartitionsorts::Dict{Symbol, Any}\nnamedoperators::Dict{Symbol, Any}\narbitraryoperators::Dict{Symbol, Any}\npartitionops::Dict{Symbol, Any}\nfeconstants::Dict{Symbol, Any}\nusersorts::Dict{Symbol, Any}\nuseroperators::Dict{Symbol, Any}\n\nCollection of dictionaries holding various kinds of PNML declarations. Each keyed by REFID symbols.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.DictType","page":"Docstrings","title":"PNML.DictType","text":"Dictionary filled by XMLDict in unparsed_tag\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.HLPetriNet","page":"Docstrings","title":"PNML.HLPetriNet","text":"Wrap a single pnml net. Presumes that the net does not need to be flattened as all content is in first page.\n\nstruct HLPetriNet{PNTD} <: PNML.AbstractPetriNet{PNTD}\n\nnet::PnmlNet{PNTD} where PNTD\n\nDetails\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.HLPetriNet-Tuple{AbstractString}","page":"Docstrings","title":"PNML.HLPetriNet","text":"Construct from string of valid pnml XML, using the first network in model.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.LiteralExpr","page":"Docstrings","title":"PNML.LiteralExpr","text":"LiteralExpr(ex)\n\nLiterally ex, an Expr. toexpr on LiteralExpr recursively calls toexpr on any interpolated symbolic expressions.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.MalformedException","page":"Docstrings","title":"PNML.MalformedException","text":"struct MalformedException <: PnmlException\n\nmsg::String\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.MissingIDException","page":"Docstrings","title":"PNML.MissingIDException","text":"struct MissingIDException <: PnmlException\n\nmsg::String\n\nUse exception to allow dispatch and additional data presentation to user.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.NumberConstant","page":"Docstrings","title":"PNML.NumberConstant","text":"NumberConstant{T<:Number, S}\n\nBuiltin operator that has arity=0 means the same result every time, a constant. Restricted to NumberSorts, those Sorts whose eltype isa Number.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.NumberEx","page":"Docstrings","title":"PNML.NumberEx","text":"NumberEx\n\nTermInterface expression for a NumberSort.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.OpExpr","page":"Docstrings","title":"PNML.OpExpr","text":"TermInterface operator expression types.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Operator","page":"Docstrings","title":"PNML.Operator","text":"PNML Operator as Functor\n\ntag maps to func, a functor/function Callable. Its arity is same as length of inexprs and insorts\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Page","page":"Docstrings","title":"PNML.Page","text":"mutable struct Page{PNTD<:PNML.PnmlTypeDefs.PnmlType, P, T, A, RP, RT} <: PNML.AbstractPnmlObject\n\npntd::PNML.PnmlTypeDefs.PnmlType\nid::Symbol\ndeclaration::PNML.Labels.Declaration\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\nlabels::Union{Nothing, Vector{PNML.Labels.PnmlLabel}}\npagedict::OrderedCollections.OrderedDict{Symbol, Page{PNTD, P, T, A, RP, RT}} where {PNTD<:PNML.PnmlTypeDefs.PnmlType, P, T, A, RP, RT}\nnetdata::PNML.PnmlNetData\nnetsets::PNML.PnmlNetKeys\n\nContain all places, transitions & arcs. Pages are for visual presentation. There must be at least 1 Page for a valid pnml model.\n\nPNTD binds the other type parameters together to express a specific PNG. See PnmlNet\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Place","page":"Docstrings","title":"PNML.Place","text":"mutable struct Place{PNTD, M} <: PNML.AbstractPnmlNode{PNTD}\n\npntd::Any\nid::Symbol\ninitialMarking::Any\nsorttype::PNML.Labels.SortType\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\nlabels::Union{Nothing, Vector{PNML.Labels.PnmlLabel}}\n\nPlace node of a Petri Net Markup Language graph.\n\nEach place has an initial marking that has a basis matching sorttype. M is a \"multiset sort denoting a collection of tokens\". A \"multiset sort over a basis sort is interpreted as \"the set of multisets over the type associated with the basis sort\".\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlConfig","page":"Docstrings","title":"PNML.PnmlConfig","text":"Configuration with default values that can be overidden by a LocalPreferences.toml.\n\nOptions\n\nindent_width::Int: Indention of nested lines.\ntext_element_optional::Bool: There are pnml files that break the rules & do not have <text> elements.\nwarn_on_fixup::Bool: When an missing value is replaced by a default value, issue a warning.\nwarn_on_namespace::Bool: There are pnml files that break the rules & do not have an xml namespace.\nwarn_on_unclaimed::Bool: Issue warning when PNML label does not have a parser defined. While allowed, there will be code required to do anything useful with the label.\nwarn_on_unimplemented::Bool: Issue warning to highlight something unimplemented. Expect high volume of messages.\nverbose::Bool: Print information as runs.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlException","page":"Docstrings","title":"PNML.PnmlException","text":"abstract type PnmlException <: Exception\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlExpr","page":"Docstrings","title":"PNML.PnmlExpr","text":"TermInterface expression types.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlModel","page":"Docstrings","title":"PNML.PnmlModel","text":"mutable struct PnmlModel\n\nnets::Tuple{Vararg{PnmlNet}}\nnamespace::String\nregs::Vector{PNML.PnmlIDRegistrys.PnmlIDRegistry}\n\nOne or more Petri Nets and an ID Registries.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlMultiset","page":"Docstrings","title":"PNML.PnmlMultiset","text":"pnmlmultiset(basis::UserSort, x::T, multi::Int=1) -> PnmlMultiset{basis,T}\n\nConstruct as a multiset with one element, x, with default multiplicity of 1.\n\nPnmlMultiset wraps a Multisets.Multiset{T} and has type parameters B, a tuple of NamedSort REFIDs (first is the sort), and a matching sort element of type T.\n\nSome Operatorsand [Variables`](@ref) create/use a multiset. Thre are constants (and 0-arity operators) defined that must be multisets since HL markings are multisets.\n\n\"multix\" is text representation of the<numberof>operator that produces a multiset. As does<all>` operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlNet","page":"Docstrings","title":"PNML.PnmlNet","text":"mutable struct PnmlNet{PNTD<:PNML.PnmlTypeDefs.PnmlType, P, T, A, RP, RT}\n\ntype::PNML.PnmlTypeDefs.PnmlType\nid::Symbol\npagedict::OrderedCollections.OrderedDict{Symbol, Page{PNTD, P, T, A, RP, RT}} where {PNTD<:PNML.PnmlTypeDefs.PnmlType, P, T, A, RP, RT}\nnetdata::PNML.PnmlNetData\npage_set::OrderedCollections.OrderedSet{Symbol}\ndeclaration::PNML.Labels.Declaration\nnamelabel::Union{Nothing, PNML.Labels.Name}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\nlabels::Union{Nothing, Vector{PNML.Labels.PnmlLabel}}\nidregistry::PNML.PnmlIDRegistrys.PnmlIDRegistry\n\nOne Petri Net of a PNML model.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlNetData","page":"Docstrings","title":"PNML.PnmlNetData","text":"struct PnmlNetData{PNTD<:PNML.PnmlTypeDefs.PnmlType}\n\npntd::PNML.PnmlTypeDefs.PnmlType\nplace_dict::OrderedCollections.OrderedDict{Symbol, Any}\ntransition_dict::OrderedCollections.OrderedDict{Symbol, Any}\narc_dict::OrderedCollections.OrderedDict{Symbol, Any}\nrefplace_dict::OrderedCollections.OrderedDict{Symbol, Any}\nreftransition_dict::OrderedCollections.OrderedDict{Symbol, Any}\n\nCollect each of the PnmlNodess & Arcs of a Petri Net Graph into one collection. Accessed via pnml ID key or iterate over values of an OrderedDict.\n\nIn the 'pnml' specification there is a Page structure that can be removed by flatten_pages!, removing some display-related information, leaving a functional Petri Net Graph as described in this structure. It is intended to be a per-PnmlNet database that is mutated as each page is parsed.\n\nSee PnmlNetKeys for page-level pnml ID of \"owners\" net data.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlNetKeys","page":"Docstrings","title":"PNML.PnmlNetKeys","text":"struct PnmlNetKeys\n\npage_set::OrderedCollections.OrderedSet{Symbol}\nplace_set::OrderedCollections.OrderedSet{Symbol}\ntransition_set::OrderedCollections.OrderedSet{Symbol}\narc_set::OrderedCollections.OrderedSet{Symbol}\nreftransition_set::OrderedCollections.OrderedSet{Symbol}\nrefplace_set::OrderedCollections.OrderedSet{Symbol}\n\nPer-page structure of OrderedSets of pnml IDs for each \"owned\" Page and other AbstractPnmlObject.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTuple","page":"Docstrings","title":"PNML.PnmlTuple","text":"The <tuple> operator is used to wrap an ordered sequence of AbstractTerm instances. When evaluated each of the expressions will have the same sort as in the ProductSort.\n\nPnmlTupleEx is the PnmlExpr that produces an expression calling pnmltuple.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTupleEx","page":"Docstrings","title":"PNML.PnmlTupleEx","text":"PnmlTupleEx(args::Vector)\n\nPnmlTuple TermInterface expression object wraps an ordered collection of PnmlExpr objects. There is a related ProductSort: an ordered collection of sorts. Each tuple element will have the same sort as the corresponding product sort.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.REFID","page":"Docstrings","title":"PNML.REFID","text":"Alias for Symbol that refers to something with an ID Symbol.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.RefPlace","page":"Docstrings","title":"PNML.RefPlace","text":"Reference Place node of a Petri Net Markup Language graph. For connections between pages.\n\nstruct RefPlace <: PNML.ReferenceNode\n\nid::Symbol\nref::Symbol\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\nlabels::Union{Nothing, Vector{PNML.Labels.PnmlLabel}}\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.RefTransition","page":"Docstrings","title":"PNML.RefTransition","text":"Refrence Transition node of a Petri Net Markup Language graph. For connections between pages.\n\nstruct RefTransition <: PNML.ReferenceNode\n\nid::Symbol\nref::Symbol\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\nlabels::Union{Nothing, Vector{PNML.Labels.PnmlLabel}}\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.ReferenceNode","page":"Docstrings","title":"PNML.ReferenceNode","text":"abstract type ReferenceNode <: PNML.AbstractPnmlObject\n\nFor common behavior shared by RefPlace, RefTransition used to connect Page together.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.SimpleNet","page":"Docstrings","title":"PNML.SimpleNet","text":"struct SimpleNet{PNTD} <: PNML.AbstractPetriNet{PNTD}\n\nid::Symbol\nnet::PnmlNet{PNTD} where PNTD\n\nTODO: Rename SimpleNet to TBD\n\nSimpleNet is a concrete AbstractPetriNet wrapping a single PnmlNet.\n\nUses a flattened net to avoid the page level of the pnml hierarchy.\n\nNote: A multi-page petri net can always be flattened by removing referenceTransitions & referencePlaces, and merging pages into the first page.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.SubstitutionDict","page":"Docstrings","title":"PNML.SubstitutionDict","text":"SubstitutionDict = OrderderDict{REFID, Multiset}\n\nVariable ID used to access marking value. One for each variable of a transition.\n\nA higher level will produce candidate consistent substitution dictionaries, filtering them by one or more guards. Condition callable object guards are part of selecting enabled transition => subsitution dictionary firing pairs. The firing rule selects one of the firing pairs, using the substitution dictionary to construct postset marking updates.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.TokenGraphics","page":"Docstrings","title":"PNML.TokenGraphics","text":"struct TokenGraphics{T<:Float32} <: PNML.AbstractPnmlTool\n\npositions::Array{PNML.PnmlGraphics.Coordinate{T}, 1} where T<:Float32\n\nTokenGraphics is <toolspecific> content. Combines the <tokengraphics> and <tokenposition> elements.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.ToolInfo","page":"Docstrings","title":"PNML.ToolInfo","text":"struct ToolInfo\n\ntoolname::String\nversion::String\ninfos::Vector{PNML.AnyElement}\n\nToolInfo holds a <toolspecific> tag.\n\nIt wraps a iteratable collection (currently vector) of well formed elements parsed into AnyElements for use by anything that understands toolname, version tool specifics.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Transition","page":"Docstrings","title":"PNML.Transition","text":"Transition node of a Petri Net Markup Language graph.\n\nmutable struct Transition{PNTD, C} <: PNML.AbstractPnmlNode{PNTD}\n\npntd::Any\nid::Symbol\ncondition::Any\nnamelabel::Union{Nothing, PNML.Labels.Name}\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\nlabels::Union{Nothing, Vector{PNML.Labels.PnmlLabel}}\nvars::Set{Symbol}\nvarsubs::Vector{NamedTuple}\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.UserOperator","page":"Docstrings","title":"PNML.UserOperator","text":"struct UserOperator <: PNML.AbstractOperator\n\ndeclaration::Symbol\n\nUser operators refers to a NamedOperator declaration.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Variable","page":"Docstrings","title":"PNML.Variable","text":"struct Variable <: PNML.AbstractVariable\n\nrefvariable::Symbol\n\nVariable refers to a VariableDeclaration. Example input: <variable refvariable=\"varx\"/>.\n\n#TODO examples of use, modifying and accessing\n\n\n\n\n\n","category":"type"},{"location":"library/#Base.:*-Union{Tuple{T}, Tuple{B}, Tuple{Number, PNML.PnmlMultiset{B, T}}} where {B, T}","page":"Docstrings","title":"Base.:*","text":"n*B for PnmlMultisets is the scalar multiset product.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:*-Union{Tuple{T}, Tuple{B}, Tuple{PNML.PnmlMultiset{B, T}, PNML.PnmlMultiset{B, T}}} where {B, T}","page":"Docstrings","title":"Base.:*","text":"A*B for PnmlMultisets is forwarded Multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:+-Union{Tuple{T}, Tuple{B}, Tuple{PNML.PnmlMultiset{B, T}, PNML.PnmlMultiset{B, T}}} where {B, T}","page":"Docstrings","title":"Base.:+","text":"A+B for PnmlMultisets is the disjoint union of enclosed multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:--Union{Tuple{T}, Tuple{B}, Tuple{PNML.PnmlMultiset{B, T}, PNML.PnmlMultiset{B, T}}} where {B, T}","page":"Docstrings","title":"Base.:-","text":"A-B for PnmlMultisets is the disjoint union of enclosed multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:<-Union{Tuple{T}, Tuple{B}, Tuple{PNML.PnmlMultiset{B, T}, PNML.PnmlMultiset{B, T}}} where {B, T}","page":"Docstrings","title":"Base.:<","text":"A<B for PnmlMultisets is forwarded Multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:<=-Union{Tuple{T}, Tuple{B}, Tuple{PNML.PnmlMultiset{B, T}, PNML.PnmlMultiset{B, T}}} where {B, T}","page":"Docstrings","title":"Base.:<=","text":"A<=B for PnmlMultisets is forwarded Multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:>-Union{Tuple{T}, Tuple{B}, Tuple{PNML.PnmlMultiset{B, T}, PNML.PnmlMultiset{B, T}}} where {B, T}","page":"Docstrings","title":"Base.:>","text":"A>B for PnmlMultisets is forwarded Multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#Base.:>=-Union{Tuple{T}, Tuple{B}, Tuple{PNML.PnmlMultiset{B, T}, PNML.PnmlMultiset{B, T}}} where {B, T}","page":"Docstrings","title":"Base.:>=","text":"A>=B for PnmlMultisets is forwarded Multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._get_op_dict-Tuple{DeclDict, Symbol}","page":"Docstrings","title":"PNML._get_op_dict","text":"Return operator dictionary containing key id.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._match","page":"Docstrings","title":"PNML._match","text":"_match(ti::ToolInfo, name::AbstractString) -> Bool\n_match(ti::ToolInfo, name::String, version::String) -> Bool\n_match(ti::ToolInfo, namerex::Regex, versionrex::Regex) -> Bool\n\nReturn true if both toolname and version match. Default is any version.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML._op_dictionaries-Tuple{}","page":"Docstrings","title":"PNML._op_dictionaries","text":"Return tuple of operator dictionary fields in the Declaration Dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._ops-Tuple{Any}","page":"Docstrings","title":"PNML._ops","text":"Return iterator over operator dictionaries of Declaration Dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._sort_dictionaries-Tuple{}","page":"Docstrings","title":"PNML._sort_dictionaries","text":"Return tuple of sort dictionary fields in the Declaration Dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML._sorts-Tuple{Any}","page":"Docstrings","title":"PNML._sorts","text":"Return iterator over sort dictionaries of Declaration Dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.accum_varset!-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict, Symbol}","page":"Docstrings","title":"PNML.accum_varset!","text":"Collect/intersect binding of one arc variable binding set.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.accum_varsets!-Tuple{OrderedCollections.OrderedDict, OrderedCollections.OrderedDict}","page":"Docstrings","title":"PNML.accum_varsets!","text":"accum_varsets!(bvs, arc_bvs) -> Bool\n\nCollect variable bindings, intersecting among arcs. Return enabled status of false if any variable does not have a substitution.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.adjacent_place","page":"Docstrings","title":"PNML.adjacent_place","text":"adjacent_place(net::PnmlNet, id::Arc) -> Place\nadjacent_place(netdata, source,::Symbol target::Symbol) -> Place\n\nAdjacent place of an arc is either the source or target.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.all_arcs","page":"Docstrings","title":"PNML.all_arcs","text":"Return arcs that have a source or target of transition id.\n\nSee also src_arcs, tgt_arcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.allpages-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.allpages","text":"allpages(net::PnmlNet|dict::OrderedDict) -> Iterator\n\nReturn iterator over all pages in the net. Maintains insertion order.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.append_page!-Tuple{Page, Page}","page":"Docstrings","title":"PNML.append_page!","text":"Append selected fields of r to fields of l. Some, like Names and xml, are omitted because they are scalar values, not collections.\n\npagedict & netdata (holding the arc and pnml nodes) are per-net data that is not modified here. netsets hold pnml IDs \"owned\"\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arbitraryops-Tuple{DeclDict}","page":"Docstrings","title":"PNML.arbitraryops","text":"Return dictonary of ArbitraryOperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arbitrarysorts-Tuple{DeclDict}","page":"Docstrings","title":"PNML.arbitrarysorts","text":"Return dictonary of ArbitrarySort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arc","page":"Docstrings","title":"PNML.arc","text":"Return arc with id if found, otherwise nothing.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.arc-Tuple{Any, Symbol, Symbol}","page":"Docstrings","title":"PNML.arc","text":"Return Arc from 's' to 't' or nothing. Useful for graphs where arcs are represented by a tuple(source,target).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.arc_idset","page":"Docstrings","title":"PNML.arc_idset","text":"Return iterator over arc ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.arc_type","page":"Docstrings","title":"PNML.arc_type","text":"Type of Arc.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.arcs","page":"Docstrings","title":"PNML.arcs","text":"arcs(n::PnmlNet) -> iterator\narcs(p::AbstractPetriNet) -> iterator\n\nReturn iterator over arc ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.basis","page":"Docstrings","title":"PNML.basis","text":"basis(x) -> UserSort\n\nReturn UserSort referencing a NamedSort, ArbitrarySort or PartitionSort declaration.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.basis-Union{Tuple{PNML.PnmlMultiset{B, T}}, Tuple{T}, Tuple{B}} where {B, T}","page":"Docstrings","title":"PNML.basis","text":"basis(ms::PnmlMultiset) -> UserSort\n\nMultiset basis (B type parameter) is a REFID to a UserSort that references a NamedSort. Which gives a name and id to a built-in Sorts, ProductSorts, or other UserSorts. MultisetSorts not allowed here. Nor loops in sort references.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.binding_value_sets-Tuple{PnmlNet, Any}","page":"Docstrings","title":"PNML.binding_value_sets","text":"binding_value_sets(net::PnmlNet, marking) -> Vector{Dict{REFID,Any}}\n\nReturn dictionary with transaction ID is key and value is binding set for variables of that transition. Each variable of an enabled transition will have a non-empty binding.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.cardinality-Tuple{PNML.PnmlMultiset}","page":"Docstrings","title":"PNML.cardinality","text":"cardinality(ms::PnmlMultiset, x) -> Integer\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.condition","page":"Docstrings","title":"PNML.condition","text":"Return condition's value of transition.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.condition-Tuple{Transition}","page":"Docstrings","title":"PNML.condition","text":"condition(::Transition) -> Condition\n\nReturn condition label.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.condition_type","page":"Docstrings","title":"PNML.condition_type","text":"Type of Condition.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.condition_value_type","page":"Docstrings","title":"PNML.condition_value_type","text":"Return value type.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.conditions","page":"Docstrings","title":"PNML.conditions","text":"Return a labelled vector of condition values.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.conditions-Tuple{PNML.AbstractPetriNet}","page":"Docstrings","title":"PNML.conditions","text":"conditions(petrinet) -> LVector{condition_value_type(pntd)}\n\nLVector labelled with transition id and holding its condition's value.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.coordinate_type","page":"Docstrings","title":"PNML.coordinate_type","text":"Return Coordinate{coordinate_value_type(T)}\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.coordinate_value_type","page":"Docstrings","title":"PNML.coordinate_value_type","text":"Return type of value in a Coordinate.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.declarations-Tuple{DeclDict}","page":"Docstrings","title":"PNML.declarations","text":"declarations(dd::DeclDict) -> Iterator\n\nReturn an iterator over all the declaration dictionaries' values. Flattens iterators: variabledecls, namedsorts, arbitrarysorts, partitionsorts, partitionops, namedoperators, arbitraryops, feconstants, usersorts, useroperators.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.deref!-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.deref!","text":"deref!(net::PnmlNet; trim, verbose)\n\n\nRemove reference nodes from arcs.\n\nOperates on the PnmlNetData at the net level. Expects that the PnmlNetKeys of the firstpage will have to be cleaned as part of flatten_pages!,\n\nAxioms\n\nAll ids in a network are unique in that they only have one instance in the XML.\nA chain of reference Places (or Transitions) always ends at a Place (or Transition).\nAll ids are valid.\nNo cycles.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.deref_place-Tuple{PnmlNet, Symbol}","page":"Docstrings","title":"PNML.deref_place","text":"deref_place(net, id[], trim::Bool] ) -> Symbol\n\nReturn id of referenced place. If trim is true (default) the reference is removed.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.deref_transition-Tuple{PnmlNet, Symbol}","page":"Docstrings","title":"PNML.deref_transition","text":"deref_transition(net, id[, trim::Bool] ) -> Symbol\n\nReturn id of referenced transition. If trim is true (default) the reference is removed.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.dict_show","page":"Docstrings","title":"PNML.dict_show","text":"dict_show(io::IO, x, 0)\n\nInternal helper for things that contain DictType.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.enabled-Tuple{PNML.AbstractPetriNet, Any}","page":"Docstrings","title":"PNML.enabled","text":"enabled(::AbstractPetriNet, ::LVector) -> LVector\n\nReturn labelled vector of id=>boolean where true means transition id is enabled at current marking.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.enabledXXX-Tuple{PnmlNet, Any}","page":"Docstrings","title":"PNML.enabledXXX","text":"enabledXXX(net::PnmlNet, marking)\n\nUpdate tr.vars, tr.varsubs for every transition tr in net using marking.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.feconstants-Tuple{DeclDict}","page":"Docstrings","title":"PNML.feconstants","text":"Return dictonary of FEConstant\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.fill_nonhl!","page":"Docstrings","title":"PNML.fill_nonhl!","text":"fill_nonhl!() -> Nothing\nfill_nonhl!(dd::DeclDict) -> Nothing\n\nFill a DeclDict with defaults and values needed by non-high-level networks. Defaults to filling the scoped value PNML.DECLDICT[].\n\nNamedSort(:integer, \"Integer\", IntegerSort())\nNamedSort(:natural, \"Natural\", NaturalSort())\nNamedSort(:positive, \"Positive\", PositiveSort())\nNamedSort(:real, \"Real\", RealSort())\nNamedSort(:dot, \"Dot\", DotSort())\nNamedSort(:bool, \"Bool\", BoolSort())\n\nUserSort(:integer)\nUserSort(:natural)\nUserSort(:positive)\nUserSort(:real)\nUserSort(:dot)\nUserSort(:bool)\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.fill_sort_tag!","page":"Docstrings","title":"PNML.fill_sort_tag!","text":"fill_sort_tag!(dd::DeclDict, tag::Symbol, name, sort)\n\nIf not already in the declarations dictionary, create and add a namedsort, usersort duo for tag.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.find_net-Tuple{Any, Symbol}","page":"Docstrings","title":"PNML.find_net","text":"find_net(model, id::Symbol) -> Union{Nothing, PnmlNet}\n\n\nReturn PnmlNet having id or nothing`.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.find_nets","page":"Docstrings","title":"PNML.find_nets","text":"Return nets matching pntd type given as symbol or pnmltype singleton.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.fire!-Tuple{Any, Any, Any}","page":"Docstrings","title":"PNML.fire!","text":"fire!(incidence, enabled, marking) -> LVector\n\nReturn the marking after firing transition:   marking + incidence * enabled\n\nmarking LVector values added to product of incidence' matrix and firing vector enabled.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.firstpage-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.firstpage","text":"Usually the only interesting page.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.flatten_pages!","page":"Docstrings","title":"PNML.flatten_pages!","text":"flatten_pages!(net::PnmlNet[; options])\n\nMerge page content into the 1st page of the net.\n\nOptions\n\ntrim::Bool Remove refrence nodes (default true). See deref!.\nverbose::Bool Print breadcrumbs See CONFIG.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.get_arc_bvs!-NTuple{4, Any}","page":"Docstrings","title":"PNML.get_arc_bvs!","text":"get_arc_bvs!(arc_bvs, arc_vars, placesort, mark) -> Bool\n\nFill arc_bvs with entry for each arc_vars\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.get_label","page":"Docstrings","title":"PNML.get_label","text":"get_label(x, tag::Symbol) -> PnmlLabel\n\nReturn first label of x with a matching tagvalue.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.get_toolinfo","page":"Docstrings","title":"PNML.get_toolinfo","text":"get_toolinfo(infos, toolname[, version]) -> Maybe{ToolInfo}\n\nReturn first toolinfo in iteratable collection infos having a matching toolname and version. See has_toolinfo\n\nget_toolinfo(ti::ToolInfo, toolname[, version]) -> Maybe{ToolInfo}\n\nReturn ti if toolname and version match, nothing otherwise.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.get_toolinfos","page":"Docstrings","title":"PNML.get_toolinfos","text":"get_toolinfos(infos, toolname::Regex[, version::Regex]) -> Iterator\n\nReturn iterator over toolinfos matching toolname and version regular expressions.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.has_arc","page":"Docstrings","title":"PNML.has_arc","text":"\n\nReturn true if any arc has id.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.has_label","page":"Docstrings","title":"PNML.has_label","text":"has_label(x, tag::Symbol) -> Bool\n\nDoes x have any label with a matching tag.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.has_labels","page":"Docstrings","title":"PNML.has_labels","text":"has_labels(x) -> Bool\n\nDoes x have any labels.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.has_name","page":"Docstrings","title":"PNML.has_name","text":"has_name(x) -> Bool\n\nReturn true if there is a name. Some declarations (inside a label) have a name. Nodes (nets, pages, places, transitions, arcs) may optionally have a name (as a label).\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.has_operator-Tuple{DeclDict, Symbol}","page":"Docstrings","title":"PNML.has_operator","text":"Does any operator dictionary contain id?\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.has_place","page":"Docstrings","title":"PNML.has_place","text":"Return true if there is any place with id?\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.has_refplace","page":"Docstrings","title":"PNML.has_refplace","text":"\n\n\n\n","category":"function"},{"location":"library/#PNML.has_reftransition","page":"Docstrings","title":"PNML.has_reftransition","text":"\n\n\n\n","category":"function"},{"location":"library/#PNML.has_toolinfo","page":"Docstrings","title":"PNML.has_toolinfo","text":"has_toolinfo(infos, toolname[, version]) -> Bool\n\nDoes any toolinfo in iteratable infos have a matching toolname, and a matching version (if it is provided). toolname and version will be turned into Regexs to match against each ToolInfo in the infos collection.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.has_transition","page":"Docstrings","title":"PNML.has_transition","text":"Is there a transition with id?\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.hassort-Tuple{Any}","page":"Docstrings","title":"PNML.hassort","text":"hassort(x) -> Bool\n\nPredicate testing applicability of sortof.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.in_inscriptions-Tuple{Any, Any}","page":"Docstrings","title":"PNML.in_inscriptions","text":"Iterate over preset of transition, returning source place id => inscription value pairs.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.in_out","page":"Docstrings","title":"PNML.in_out","text":"Return tuple of input, output labelled vectors with key of place ids and value of arc inscription's value for use as a transition function. #TODO When do these get called \"pre\" and \"post\"?\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.inc_indent","page":"Docstrings","title":"PNML.inc_indent","text":"Increment the :indent value by inc.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.incidence_matrix-Tuple{PNML.AbstractPetriNet, Any}","page":"Docstrings","title":"PNML.incidence_matrix","text":"incidence_matrix(petrinet, marking) -> LArray\n\nWhen token identity is collective, marking and inscription values are Numbers and matrix C[transition,place] = inscription(transition,place) - inscription(place,transition) is called the incidence_matrix.\n\nHigh-level nets have tokens with individual identity, perhaps tuples of them, usually multisets of finite enumerations, can be other sorts including numbers, strings, lists. Symmetric nets are restricted, and thus easier to deal with and reason about.\n\nWe use multiset cardinality to turn high-level inscriptions into integers.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.indent-Tuple{IO}","page":"Docstrings","title":"PNML.indent","text":"Return blank string of current indent size in io.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.infos-Tuple{PNML.ToolInfo}","page":"Docstrings","title":"PNML.infos","text":"Content of a ToolInfo.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.initial_marking","page":"Docstrings","title":"PNML.initial_marking","text":"Return the initial marking of a place.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.initial_markings","page":"Docstrings","title":"PNML.initial_markings","text":"initial_markings(petrinet) -> LVector{marking_value_type}\n\nLVector labelled with place id and holding initial marking's value. Used to create a vector of place markings indexed by place ID.\n\n#TODO refactor from LVector to tuples of pairs.\n\nHigh-level P/T Nets use cardinality of its multiset place marking value. Really, the implementation should be the same as for PTNet.\n\nOther HL Nets use multisets.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.input_matrix-Tuple{PNML.AbstractPetriNet, Any}","page":"Docstrings","title":"PNML.input_matrix","text":"input_matrix(petrinet::AbstractPetriNet) -> Matrix{inscription_value_type(net)}\n\nCreate and return a matrix ntransitions x nplaces.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.ins-Tuple{Any, Symbol}","page":"Docstrings","title":"PNML.ins","text":"ins(net, transition_id) -> LVector\n\nReturn vector of inscription values labeled with source place id for arcs with transition_id as the target id.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.inscription","page":"Docstrings","title":"PNML.inscription","text":"Return incription value of arc.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.inscription-Tuple{Arc}","page":"Docstrings","title":"PNML.inscription","text":"inscription(arc::Arc) -> Union{Number,PnmlMultiset}\n\nEvery inscription label is treated as a functor.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.inscription-Tuple{PNML.AbstractPetriNet, Symbol}","page":"Docstrings","title":"PNML.inscription","text":"Forward inscription lookup to pnmlnet\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.inscription-Tuple{PnmlNet, Symbol}","page":"Docstrings","title":"PNML.inscription","text":"Forward inscription to arcdict\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.inscription_type","page":"Docstrings","title":"PNML.inscription_type","text":"inscription_type(pntd) -> Inscription{inscription_value_type(pntd)}.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.inscription_value","page":"Docstrings","title":"PNML.inscription_value","text":"inscription_value(::Type{T}, a, z, varsub) -> Union{Number, PnmlMultiset}\n\nIf a is nothing return z else call inscription(a)(marking_vector, varsub); where z is zero or zero-like PnmlMultiset of same type as inscription.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.inscription_value_type","page":"Docstrings","title":"PNML.inscription_value_type","text":"inscription_value_type(pntd) -> Union{Int64, Float64, <:PnmlMultiset}\n\nReturn value type of pntd.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.inscriptions-Tuple{PNML.AbstractPetriNet}","page":"Docstrings","title":"PNML.inscriptions","text":"inscriptions(petrinet::AbstractPetriNet) -> LVector[id(arc) => inscription(arc)]\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.isoperator-Tuple{Symbol}","page":"Docstrings","title":"PNML.isoperator","text":"isoperator(tag::Symbol) -> Bool\n\nPredicate to identify operators in the high-level pntd's many-sorted algebra abstract syntaxt tree.\n\nNote: It is not the same as Meta.isoperator. Both work on Symbols. Not expecting any conflict.\n\ninteger\nmultiset\nboolean\ntuple\nbuiltin constant\nuseroperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.ispid-Tuple{Symbol}","page":"Docstrings","title":"PNML.ispid","text":"ispid(x::Symbol)\n\nReturn function to be used like: any(ispid(:asym), iterablewithpid).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.labels","page":"Docstrings","title":"PNML.labels","text":"labels(x) -> Iterateable\n\nReturn iterator of labels attached to x.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.logfile-Tuple{Any}","page":"Docstrings","title":"PNML.logfile","text":"Return open file IO object.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.marking_type","page":"Docstrings","title":"PNML.marking_type","text":"marking_type(pntd) -> Marking\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.marking_value_type","page":"Docstrings","title":"PNML.marking_value_type","text":"Return value type.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.metagraph","page":"Docstrings","title":"PNML.metagraph","text":"metagraph(::AbstractPetriNet) -> MetaGraph\nmetagraph(::PnmlNet) -> MetaGraph\n\nReturn MetaGraph instance based on a SimpleDiGraph with PNML nodes attached to vertices and edges.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.multiplicity-Tuple{PNML.PnmlMultiset, Any}","page":"Docstrings","title":"PNML.multiplicity","text":"multiplicity(ms::PnmlMultiset, x) -> Integer\nmultiplicity(ms::Number, x) -> Number\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.multiset-Tuple{PNML.PnmlMultiset}","page":"Docstrings","title":"PNML.multiset","text":"multiset(ms::PnmlMultiset) -> Multiset\n\nAccess wrapped multiset.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.name","page":"Docstrings","title":"PNML.name","text":"name(x) -> String\n\nReturn name String. Default to empty string.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.name-Tuple{PNML.ToolInfo}","page":"Docstrings","title":"PNML.name","text":"Name of tool to for this tool specific information element.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedoperators-Tuple{DeclDict}","page":"Docstrings","title":"PNML.namedoperators","text":"Return dictonary of NamedOperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedsorts-Tuple{DeclDict}","page":"Docstrings","title":"PNML.namedsorts","text":"Return dictonary of NamedSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.nets-Tuple{PnmlModel}","page":"Docstrings","title":"PNML.nets","text":"nets(model::PnmlModel) -> Tuple{Vararg{PnmlNet}}\n\n\nReturn all nets of model.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.nettype","page":"Docstrings","title":"PNML.nettype","text":"Return the PnmlType subtype representing the flavor (or pntd) of this kind of Petri Net Graph.\n\nSee also pnmltype\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.null_function-Tuple{Any}","page":"Docstrings","title":"PNML.null_function","text":"Dummy function\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.number_value-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T<:Number","page":"Docstrings","title":"PNML.number_value","text":"number_value(::Type{T}, s) -> T\n\nParse string as a type T <: Number.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.operator-Tuple{DeclDict, Symbol}","page":"Docstrings","title":"PNML.operator","text":"operator(dd::DeclDict, id::Symbol) -> AbstractOperator\noperator(id::Symbol) -> AbstractOperator\n\nReturn operator TermInterface expression for id.     toexpr(::OpExpr, varsub) = :(useroperator(REFID)(varsub))\n\n\"Operator Declarations\" include: :namedoperator, :feconstant, :partitionelement, :arbitraryoperator with types NamedOperator, FEConstant, PartitionElement, ArbitraryOperator. These define operators of different types that are placed into separate dictionaries.\n\n#! CORRECT AbstractOperator type hierarchy that has Operator as concrete type. #! AbstractDeclarations and AbstractTerms are \"parallel\" hierarchies in the UML, #! with AbstractTerms divided into AbstractOperators and AbstractVariables.\n\nuseroperator(REFID) is used to locate the operator definition, when it is found in feconstants(), is a callable returning a FEConstant literal.\n\n`toexpr(::FEConstantEx, varsub) = :(useroperator(REFID)(varsub))`\n\nThe FEConstant operators defined by the declaration do not have a distinct type name in the specification. Note that a FEConstant's value in the specification is its identity. We could use objectid(::FEConstant), REFID or name for output value. Output sort of op is FEConstant.\n\nOther OperatorDeclaration dictionarys also hold TermInterface expressions accessed by\n\n`toexpr(::OpExpr, varsub) = :(useroperator(REFID)(varsub))`\n\nwhere OpExpr is the TermInterface to match OperatorDeclaration. With output sort to match OperatorDeclaration .\n\n#TODO named operator input variables and thier sorts\n\n#TODO partition element\n\n#TODO arbitrary opearator\n\n#TODO built-in operators\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.operators-Tuple{DeclDict}","page":"Docstrings","title":"PNML.operators","text":"operators(dd::DeclDict)-> Iterator\n\nIterate over each operator in the operator subset of declaration dictionaries .\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.out_inscriptions-Tuple{Any, Any}","page":"Docstrings","title":"PNML.out_inscriptions","text":"Iterate over postset of transition, returning target place id => inscription value pairs.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.output_matrix-Tuple{PNML.AbstractPetriNet, Any}","page":"Docstrings","title":"PNML.output_matrix","text":"output_matrix(petrinet::AbstractPetriNet) -> Matrix{inscription_value_type(net)}\n\nCreate and return a matrix ntransitions x nplaces.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.outs-Tuple{Any, Symbol}","page":"Docstrings","title":"PNML.outs","text":"outs(net, transition_id) -> LVector\n\nReturn vector of inscription values labeled with target place id for arcs with transition_id as the source id.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.page_type","page":"Docstrings","title":"PNML.page_type","text":"Type of Page.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.pages","page":"Docstrings","title":"PNML.pages","text":"pages(net::PnmlLabel|page::Page) -> iterator\n\nReturn iterator of pages directly owned by that object.\n\nSee allpages for an iterator over all pages in the PNML network model. When there is only one page in the net, or all pages are owned by the 'net' itself, 'allpages' and 'pages` behave the same.\n\nMaintains order (insertion order).\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.pages-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.pages","text":"Iterator of Pages directly owned by net.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.partitionops-Tuple{DeclDict}","page":"Docstrings","title":"PNML.partitionops","text":"Return dictonary of partitionops (PartitionElement)\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.partitionsorts-Tuple{DeclDict}","page":"Docstrings","title":"PNML.partitionsorts","text":"Return dictonary of PartitionSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.pid","page":"Docstrings","title":"PNML.pid","text":"pid(x) -> Symbol\n\nReturn pnml id symbol of x. An id's value is unique in the XML model of PNML. REFID is used for refrences to pnml ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.place","page":"Docstrings","title":"PNML.place","text":"Return the place with id.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.place_idset","page":"Docstrings","title":"PNML.place_idset","text":"Return iterator of all place IDs.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.place_idset-Tuple{PNML.AbstractPetriNet}","page":"Docstrings","title":"PNML.place_idset","text":"Return pnmlnet's place_idset\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.place_idset-Tuple{Page}","page":"Docstrings","title":"PNML.place_idset","text":"Return netsets place_idset\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.place_idset-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.place_idset","text":"Return iterator over keys of a dictionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.place_pnk-Tuple{PNML.PnmlNetKeys}","page":"Docstrings","title":"PNML.place_pnk","text":"Return a `OrderedSet{Symbol}, should it be an iterator?\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.place_type","page":"Docstrings","title":"PNML.place_type","text":"Type of Place.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.places","page":"Docstrings","title":"PNML.places","text":"Return iterator of all places.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.pnml_hl_operator-Tuple{Symbol}","page":"Docstrings","title":"PNML.pnml_hl_operator","text":"pnml_hl_operator(tag::Symbol) -> Callable(::Vector{AbstractTerm})\n\nReturn callable with a single argument, a vector of inputs.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.pnml_hl_outsort-Tuple{Symbol}","page":"Docstrings","title":"PNML.pnml_hl_outsort","text":"pnml_hl_outsort(tag::Symbol; insorts::Vector{UserSort}) -> UserSort\n\nReturn sort that operator tag returns.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.pnmlmultiset","page":"Docstrings","title":"PNML.pnmlmultiset","text":"pnmlmultiset(basis::UserSort, x, multi::Int=1) -> PnmlMultiset\npnmlmultiset(basis::UserSort, x::Multisets.Multiset) -> PnmlMultiset\npnmlmultiset(basis::UserSort) -> PnmlMultiset\n\nConstructs a PnmlMultiset containing a multiset and a sort from either\n\na usersort, one element and a multiplicity, default = 1, denoted \"1'x\",\na usersort and Multiset\nor just a sort (not usersort or multisetsort), uses all sortelements(sort), each with multiplicity = 1.\n\nAre mapping to Multisets.jl implementation: Create empty Multiset{T}() then fill.   If we have an element we can use typeof(x) to deduce T.   If we have a basis sort definition we use eltype(basis) to deduce T.\n\nUsages\n\n⟨all⟩ wants all sortelements\ndefault marking, inscription want one element or zero elements (elements can be PnmlTuples)\n\nwe always find a sort to use, And use dummy elements for their typeof for empty multisets.\n\nExpect to be called from a @matchable Terminterface, thusly:\n\neval(toexpr(Bag(basis, x, multi)))\neval(toexpr(Bag(basis)))\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.pnmlnet_type","page":"Docstrings","title":"PNML.pnmlnet_type","text":"\n\n\n\n","category":"function"},{"location":"library/#PNML.post_flatten_verify-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.post_flatten_verify","text":"Verify a PnmlNet after it has been flattened or is otherwise expected to be a single-page net.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.postset-Tuple{PnmlNet, Symbol}","page":"Docstrings","title":"PNML.postset","text":"postset(net, id) -> Iterator\n\nIterate ids of output (arc's target) for source transition or place id.\n\nSee out_inscriptions and transition_function.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.preset-Tuple{PnmlNet, Symbol}","page":"Docstrings","title":"PNML.preset","text":"preset(net, id) -> Iterator\n\nIterate ids of input (arc's source) for output transition or place id.\n\nSee in_inscriptions and transition_function.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.rate_value_type","page":"Docstrings","title":"PNML.rate_value_type","text":"rate_value_type(::PnmlType) -> Number\n\nReturn rate value type based on net type.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.rates-Tuple{PNML.AbstractPetriNet}","page":"Docstrings","title":"PNML.rates","text":"rates(petrinet::AbstractPetriNet) -> LVector[id(transition) => rate(transition]\n\nReturn a transition-id labelled vector of rate values.\n\nWe allow all PNML nets to be stochastic Petri nets. See rate.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.reachability_graph-Tuple{Any}","page":"Docstrings","title":"PNML.reachability_graph","text":"reachability_graph\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.refid","page":"Docstrings","title":"PNML.refid","text":"refid(x) -> REFID\n\nReturn reference id symbol. Multiple objects may hold the same refid value.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.refid-Tuple{PNML.ReferenceNode}","page":"Docstrings","title":"PNML.refid","text":"Return the id of the referenced node.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.refplace","page":"Docstrings","title":"PNML.refplace","text":"Return reference place matching id.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.refplace_idset","page":"Docstrings","title":"PNML.refplace_idset","text":"refplace_idset(x) -> OrderedSet{Symbol} #TODO iterator?\n\nReturn reference place pnml ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.refplace_type","page":"Docstrings","title":"PNML.refplace_type","text":"Tyoe of RefPlace.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.refplaces","page":"Docstrings","title":"PNML.refplaces","text":"Return vector of all reference places.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.reftransition","page":"Docstrings","title":"PNML.reftransition","text":"Return reference transition matching id.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.reftransition_idset","page":"Docstrings","title":"PNML.reftransition_idset","text":"reftransition_idset(x) -> OrderedSet{Symbol} #TODO iterator?\n\nReturn reference transition pnml ids.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.reftransition_type","page":"Docstrings","title":"PNML.reftransition_type","text":"Type of RefTransition.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.reftransitions","page":"Docstrings","title":"PNML.reftransitions","text":"Return vector of all reference transitions.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.registry_of-Tuple{PnmlModel, Symbol}","page":"Docstrings","title":"PNML.registry_of","text":"Return PnmlIDRegistry of a PnmlNet in a model.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.regs-Tuple{PnmlModel}","page":"Docstrings","title":"PNML.regs","text":"regs(\n    model::PnmlModel\n) -> Vector{PNML.PnmlIDRegistrys.PnmlIDRegistry}\n\n\nReturn all PnmlIDRegistrys of model.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.rewriteXXX-Tuple{PnmlNet, Any}","page":"Docstrings","title":"PNML.rewriteXXX","text":"rewriteXXX(net, marking)\n\nRewrite PnmlExpr (TermInterface) expressions.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.save_config!","page":"Docstrings","title":"PNML.save_config!","text":"save_config!(config::PnmlConfig=CONFIG)\n\nSave a configuration to your LocalPreferences.toml file using Preferences.jl. The saved preferences will be automatically loaded next time you do using PNML\n\nExamples\n\njulia> using PNML\n\njulia> PNML.CONFIG[].verbose = true;\n\njulia> PNML.CONFIG[].warn_on_unclaimed = true;     # Customize some defaults\n\njulia> PNML.save_config!(PNML.CONFIG[]); # Will be automatically read next time you `using PNML`\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.sortdefinition","page":"Docstrings","title":"PNML.sortdefinition","text":"sortdefinition(NamedSort|ArbitrarySort|PartitionSort)\n\nReturn AbstractSort from a SortDeclaration. Expected usage pattern is usersort -> sortdeclaration -> sortdefinition. This uses REFIDs to the objects in dictionarys in ScopedValue DeclDict\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.sortelements-Tuple{PNML.PnmlMultiset}","page":"Docstrings","title":"PNML.sortelements","text":"sortelements(ms::PnmlMultiset) -> iterator\n\nIterates over elements of the basis sort. May not be finite sort!\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.sortof","page":"Docstrings","title":"PNML.sortof","text":"sortof(x) -> AbstractSort\n\nReturn the sort of an object or type. Any type that supports the PNML sort interface is expected to define hassort to be true and a sortof method that returns a sort instance.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.sortref","page":"Docstrings","title":"PNML.sortref","text":"sortref(x) -> UserSort\n\nReturn a REFID wrapped in a UserSort\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.source-Tuple{Arc}","page":"Docstrings","title":"PNML.source","text":"source(arc) -> Symbol\n\nReturn identity symbol of source of arc.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.src_arcs","page":"Docstrings","title":"PNML.src_arcs","text":"Return arcs that have a source of transition id.\n\nSee also all_arcs, tgt_arcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.substitute-Tuple{PnmlExpr, NamedTuple}","page":"Docstrings","title":"PNML.substitute","text":"substitute(expr, dict)\n\nRecursivly substitute a VariableEx with its the value from dict. The values in dict will be ground terms of a place's sorttype. These values are from the current marking vector. ```\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.tag","page":"Docstrings","title":"PNML.tag","text":"tag(x) -> Symbol\n\nReturn tag symbol. Multiple objects may hold the same tag value. Often used to refer to an XML tag.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.target-Tuple{Arc}","page":"Docstrings","title":"PNML.target","text":"target(arc) -> Symbol\n\nReturn identity symbol of target of arc.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.term","page":"Docstrings","title":"PNML.term","text":"term(x)\n\nReturn term of x. PnmlExpr that eval'ed returns the value.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.tgt_arcs","page":"Docstrings","title":"PNML.tgt_arcs","text":"Return arcs that have a target of transition id.\n\nSee also all_arcs, src_arcs.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.transition","page":"Docstrings","title":"PNML.transition","text":"\n\n\n\n","category":"function"},{"location":"library/#PNML.transition_function","page":"Docstrings","title":"PNML.transition_function","text":"transition_function(petrinet::AbstractPetriNet) -> LVector{Symbol, Tuple{LVector,LVector}\n\nTransition function of a Petri Net. Each transition has an input vector and an output vector. Each labelled vector is indexed by the place on the other end of the arc. Values are inscriptions of the arc.\n\nkeys are transition ids\n\nvalues are tuple of input, output labeled vectors,\n\nlabel is source or target place id - inscription (integer?)\n\ntfun = LVector(\n    birth=(LVector(rabbits=1.0), LVector(rabbits=2.0)),\n    predation=(LVector(wolves=1.0, rabbits=1.0), LVector(wolves=2.0)),\n    death=(LVector(wolves=1.0), LVector()),\n)\n\nVector{Tuple{Dict{Symbol, Number},Dict{Symbol, Number}}\n\nΔ = 3-element LabelledArrays.LArray{Tuple{LabelledArrays.LArray{Float64, 1, Vector{Float64}},\n                                          LabelledArrays.LArray{T, 1, D} where {T, D<:AbstractVector{T}}},\n                                    1,\n                 Vector{Tuple{LabelledArrays.LArray{Float64, 1, Vector{Float64}},\n                              LabelledArrays.LArray{T, 1, D}  where {T, D<:AbstractVector{T}}}},\n(:birth, :predation, :death)}:\n\n[tid => ([src=>inscription], [tgt=>inscription])]\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.transition_idset","page":"Docstrings","title":"PNML.transition_idset","text":"\n\n\n\n","category":"function"},{"location":"library/#PNML.transition_type","page":"Docstrings","title":"PNML.transition_type","text":"Type of TYransition.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.transitions","page":"Docstrings","title":"PNML.transitions","text":"Return iterator of all transitions.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.unwrap_pmset-Tuple{Any}","page":"Docstrings","title":"PNML.unwrap_pmset","text":"unwrap_pmset(mark) -> Multiset\n\nIf marking wraps a PnmlMultiset, extract a singleton.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.useroperators-Tuple{DeclDict}","page":"Docstrings","title":"PNML.useroperators","text":"Return dictonary of UserOperator\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.usersorts-Tuple{DeclDict}","page":"Docstrings","title":"PNML.usersorts","text":"Return dictonary of UserSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.validate_declarations-Tuple{DeclDict}","page":"Docstrings","title":"PNML.validate_declarations","text":"validate_declarations(dd::DeclDict) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.validate_toolinfos-Tuple{Any}","page":"Docstrings","title":"PNML.validate_toolinfos","text":"validate_toolinfos(infos, dd) -> Bool\n\nValidate each ToolInfo in the iterable infos collection.\n\nNote that each info may contain any well-formed XML. That XML for other tools must be ignored. Any info for this tool will have deeper validation implemented.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.value","page":"Docstrings","title":"PNML.value","text":"value(x)\n\nReturn value of x. Can be a wrapped value or a derived value. May return an Expr that returns the value when eval'ed.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.variabledecls-Tuple{DeclDict}","page":"Docstrings","title":"PNML.variabledecls","text":"Return dictonary of VariableDecl\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.variables","page":"Docstrings","title":"PNML.variables","text":"variables(x) -> Tuple{REFID}\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.verify-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.verify","text":"Error if any diagnostic messages are collected. Especially intended to detect semantc error.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.version-Tuple{PNML.ToolInfo}","page":"Docstrings","title":"PNML.version","text":"Version of tool for this tool specific information element.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.vertex_codes-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.vertex_codes","text":"pnml id symbol mapped to graph vertex code.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.vertex_data!-Tuple{Dict{Symbol, Tuple{Int64, Union{Place, Transition}}}, PnmlNet, Any}","page":"Docstrings","title":"PNML.vertex_data!","text":"Fill dictionary where keys are pnml ids, values are tuples of vertex code, place or transition.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.vertex_labels-Tuple{PnmlNet}","page":"Docstrings","title":"PNML.vertex_labels","text":"graph vertex code mapped to pnml id symbol.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.zero_marking-Tuple{Place}","page":"Docstrings","title":"PNML.zero_marking","text":"Return zero valued PnmlMultiset with same basis and eltype as place's marking.\n\n\n\n\n\n","category":"method"},{"location":"library/#TermInterface.maketerm","page":"Docstrings","title":"TermInterface.maketerm","text":"@matchable TermInterface expressions\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.PnmlTypeDefs","page":"Docstrings","title":"PNML.PnmlTypeDefs","text":"Petri Net Type Definition (pntd) URI mapped to PnmlType subtype singleton.\n\n\n\n\n\n","category":"module"},{"location":"library/#PNML.PnmlTypeDefs.default_pntd_map","page":"Docstrings","title":"PNML.PnmlTypeDefs.default_pntd_map","text":"Map from Petri Net Type Definition (pntd) URI to Symbol. Allows multiple strings to map to the same pntd.\n\nThere is a companion map pnmltype_map that takes the symbol to a type object.\n\nThe URI is a string and may be the full URL of a pntd schema, just the schema file name, or a placeholder for a future schema.\n\nFor readability, the 'pntd symbol' should match the name used in the URI with inconvinient characters removed or replaced. For example, '-' is replaced by '_'.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.PnmlTypeDefs.pnmltype_map","page":"Docstrings","title":"PNML.PnmlTypeDefs.pnmltype_map","text":"The key Symbols are the supported kinds of Petri Nets. Maps to singletons.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.PnmlTypeDefs.AbstractContinuousNet","page":"Docstrings","title":"PNML.PnmlTypeDefs.AbstractContinuousNet","text":"abstract type AbstractContinuousNet <: PNML.PnmlTypeDefs.PnmlType\n\nUses floating point numbers for markings, inscriptions. Most of the functionality is shared with AbstractPnmlCore. This seperates the\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.AbstractHLCore","page":"Docstrings","title":"PNML.PnmlTypeDefs.AbstractHLCore","text":"abstract type AbstractHLCore <: PNML.PnmlTypeDefs.PnmlType\n\nBase of High Level Petri Net pntds which add large extensions to PNML core. hlinitialMarking, hlinscription, and defined label structures.\n\nSee PnmlTypeDefs.HLCoreNet, PnmlTypeDefs.SymmetricNet, PnmlTypeDefs.PT_HLPNG and others.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.AbstractPnmlCore","page":"Docstrings","title":"PNML.PnmlTypeDefs.AbstractPnmlCore","text":"abstract type AbstractPnmlCore <: PNML.PnmlTypeDefs.PnmlType\n\nBase of token/integer-based Petri Net pntds.\n\nSee PnmlCoreNet, PTNet and others.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.ContinuousNet","page":"Docstrings","title":"PNML.PnmlTypeDefs.ContinuousNet","text":"struct ContinuousNet <: PNML.PnmlTypeDefs.AbstractContinuousNet\n\nTODO: Continuous Petri Net\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.HLCoreNet","page":"Docstrings","title":"PNML.PnmlTypeDefs.HLCoreNet","text":"struct HLCoreNet <: PNML.PnmlTypeDefs.AbstractHLCore\n\nHLCoreNet can be used for generic high-level nets. We try to implement and test all function at `PnmlCoreNet level, but expect to find use for a concrete type at this level for testing high-level extensions.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.HLPNG","page":"Docstrings","title":"PNML.PnmlTypeDefs.HLPNG","text":"struct HLPNG <: PNML.PnmlTypeDefs.AbstractHLCore\n\nHigh-Level Petri Net Graphs (HLPNGs) are the most intricate High-Level Petri Net schema. It extends SymmetricNet, including with\n\ndeclarations for sorts and functions (ArbitraryDeclarations)\nsorts for Integer, String, and List\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.PTNet","page":"Docstrings","title":"PNML.PnmlTypeDefs.PTNet","text":"struct PTNet <: PNML.PnmlTypeDefs.AbstractPnmlCore\n\nPlace-Transition Petri Nets add small extensions to core PNML. Integer-valued initialMarking and inscription.\n\nThe grammer file is ptnet.pnml so we name it PTNet. Note that 'PT' is often the prefix for XML tags specialized for this net type.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.PT_HLPNG","page":"Docstrings","title":"PNML.PnmlTypeDefs.PT_HLPNG","text":"struct PT_HLPNG <: PNML.PnmlTypeDefs.AbstractHLCore\n\nPlace-Transition Net in HLCoreNet notation.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.PnmlCoreNet","page":"Docstrings","title":"PNML.PnmlTypeDefs.PnmlCoreNet","text":"struct PnmlCoreNet <: PNML.PnmlTypeDefs.AbstractPnmlCore\n\nThe most minimal concrete Petri Net.\n\nUsed to implement and test the core PNML support. Covers the complete graph infrastructure including labels attached to nodes and arcs.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.PnmlType","page":"Docstrings","title":"PNML.PnmlTypeDefs.PnmlType","text":"abstract type PnmlType\n\nAbstract root of a dispatch type based on Petri Net Type Definitions (pntd).\n\nEach Petri Net Markup Language (PNML) network element will have a single pntd URI as a required 'type' XML attribute. That URI should refer to a RelaxNG schema defining the syntax and semantics of the XML model.\n\nSelected abbreviations, URIs that do not resolve to a valid schema file, are also allowed.\n\nRefer to pntd_symbol and pnmltype for how to get from the URI to a singleton.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.SymmetricNet","page":"Docstrings","title":"PNML.PnmlTypeDefs.SymmetricNet","text":"struct SymmetricNet <: PNML.PnmlTypeDefs.AbstractHLCore\n\nSymmetric Petri Net is the best-worked use case in the primer and ISO specification part 2.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlTypeDefs.add_nettype!-Tuple{AbstractDict, Symbol, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.PnmlTypeDefs.add_nettype!","text":"add_nettype!(\n    dict::AbstractDict,\n    s::Symbol,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n)\n\n\nAdd or replace mapping from Symbol s to PnmlType singleton pntd.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlTypeDefs.all_nettypes-Tuple{Any}","page":"Docstrings","title":"PNML.PnmlTypeDefs.all_nettypes","text":"Return iterator over PnmlType singletons filtered by the prediciate p.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlTypeDefs.all_nettypes-Tuple{}","page":"Docstrings","title":"PNML.PnmlTypeDefs.all_nettypes","text":"Return iterator over PnmlType singletons.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlTypeDefs.iscontinuous","page":"Docstrings","title":"PNML.PnmlTypeDefs.iscontinuous","text":"Values are floating point.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.PnmlTypeDefs.isdiscrete","page":"Docstrings","title":"PNML.PnmlTypeDefs.isdiscrete","text":"Values are integers.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.PnmlTypeDefs.ishighlevel","page":"Docstrings","title":"PNML.PnmlTypeDefs.ishighlevel","text":"Values are many-sorted.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.PnmlTypeDefs.pnmltype","page":"Docstrings","title":"PNML.PnmlTypeDefs.pnmltype","text":"pnmltype(pntd::T) -> PnmlType\npnmltype(uri::AbstractString) -> PnmlType\npnmltype(s::Symbol; pnmltype_map=pnmltype_map) -> PnmlType\n\nMap either a text string or a symbol to a dispatch type singlton.\n\nWhile that string may be a URI for a pntd, we treat it as a simple string without parsing. The PnmlTypeDefs.pnmltype_map and PnmlTypeDefs.default_pntd_map are both assumed to be correct here.\n\nUnknown or empty uri will map to symbol :pnmlcore. Unknown symbol throws a DomainError exception.\n\nExamples\n\njldoctest; setup=:(using PNML; using PNML: pnmltype, pntd_symbol)\njulia> pnmltype(PnmlCoreNet())\nPnmlCoreNet()\n\njulia> pnmltype(\"nonstandard\")\nPnmlCoreNet()\n\njulia> pnmltype(:symmetric)\nSymmetricNet()\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.PnmlTypeDefs.pntd_symbol-Tuple{AbstractString}","page":"Docstrings","title":"PNML.PnmlTypeDefs.pntd_symbol","text":"pntd_symbol(s::AbstractString) -> Symbol\n\n\nMap string s to a pntd symbol using default_pntd_map. Any unknown s is mapped to :pnmlcore. Returned symbol is suitable for pnmltype to use to index into pnmltype_map.\n\nExamples\n\njulia> PNML.PnmlTypeDefs.pntd_symbol(\"foo\")\n:pnmlcore\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlIDRegistrys","page":"Docstrings","title":"PNML.PnmlIDRegistrys","text":"Petri Net Markup Language identifier registry.\n\n\n\n\n\n","category":"module"},{"location":"library/#PNML.PnmlIDRegistrys.PnmlIDRegistry","page":"Docstrings","title":"PNML.PnmlIDRegistrys.PnmlIDRegistry","text":"Holds a set of PNML ID symbols and, optionally, a lock to allow safe reentrancy.\n\nstruct PnmlIDRegistry\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlIDRegistrys.isregistered-Tuple{PNML.PnmlIDRegistrys.PnmlIDRegistry, Symbol}","page":"Docstrings","title":"PNML.PnmlIDRegistrys.isregistered","text":"isregistered(\n    registry::PNML.PnmlIDRegistrys.PnmlIDRegistry,\n    id::Symbol\n) -> Bool\n\n\nReturn true if id is registered in registry.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlIDRegistrys.register_id!-Tuple{PNML.PnmlIDRegistrys.PnmlIDRegistry, Symbol}","page":"Docstrings","title":"PNML.PnmlIDRegistrys.register_id!","text":"register_id!(\n    registry::PNML.PnmlIDRegistrys.PnmlIDRegistry,\n    id::Symbol\n) -> Symbol\n\n\nRegister id symbol and return the symbol.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlIDRegistrys.reset_reg!-Tuple{PNML.PnmlIDRegistrys.PnmlIDRegistry}","page":"Docstrings","title":"PNML.PnmlIDRegistrys.reset_reg!","text":"reset_reg!(registry::PNML.PnmlIDRegistrys.PnmlIDRegistry)\n\n\nEmpty the set of id symbols. Use case is unit tests.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Sorts.AbstractSort","page":"Docstrings","title":"PNML.Sorts.AbstractSort","text":"abstract type AbstractSort\n\nPart of the high-level pnml many-sorted algebra. See  PNML.Labels.SortType.\n\nNamedSort is an AbstractTerm that declares a definition using an AbstractSort. The pnml specification sometimes uses overlapping language.\n\nFrom the 'primer': built-in sorts of Symmetric Nets are the following: booleans, integerrange, finite enumerations, cyclic enumerations, permutations, dots and partitions.\n\nAnd more sorts for HLPNG: integer, strings, list\n\nWith additions we made: real.\n\nOh, also ArbitrarySorts.\n\nThe eltype is expected to be a concrete subtype of Number such as Int, Bool or Float64.\n\nExtras\n\nNotes:\n\nNamedSort is a Declarations.SortDeclaration\n\nPNML.PnmlTypeDefs.HLPNG adds PNML.Declarations.ArbitrarySort.\n\nUserSort holds the id symbol of a NamedSort.\nHere 'type' means a 'term' from the many-sorted algebra.\nWe use sorts even for non-high-level nets.\nExpect eltype(::AbstractSort) to return a concrete subtype of Number.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.BoolSort","page":"Docstrings","title":"PNML.Sorts.BoolSort","text":"Built-in sort whose eltype is Bool\n\nOperators: and, or, not, imply\n\nFunctions: equality, inequality\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.CyclicEnumerationSort","page":"Docstrings","title":"PNML.Sorts.CyclicEnumerationSort","text":"struct CyclicEnumerationSort{N, M} <: PNML.Sorts.EnumerationSort{N, M}\n\nWraps tuple of REFIDs into feconstant(decldict). Operations differ between EnumerationSorts. All wrap a tuple of symbols and metadata, allowing attachment of Partition/PartitionElement.\n\nSee ISO/IEC 15909-2:2011/Cor.1:2013(E) defect 11 power or nth successor/predecessor\n\nMCC2023/SharedMemory-COL-100000 has cyclic enumeration with 100000 <feconstant> elements.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.DotConstant","page":"Docstrings","title":"PNML.Sorts.DotConstant","text":"DotConstant()\n\nDuck-typed as AbstractOperator.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.DotSort","page":"Docstrings","title":"PNML.Sorts.DotSort","text":"Built-in sort whose eltype is Bool, the smallest Integer subtype that can represent one.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.EnumerationSort","page":"Docstrings","title":"PNML.Sorts.EnumerationSort","text":"abstract type EnumerationSort{N, M} <: PNML.Sorts.AbstractSort\n\nSee FiniteEnumerationSort, PNML.Sorts.CyclicEnumerationSort. Both hold an ordered collection of PNML.Declarations.FEConstant REFIDs and metadata.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.FiniteEnumerationSort","page":"Docstrings","title":"PNML.Sorts.FiniteEnumerationSort","text":"struct FiniteEnumerationSort{N, M} <: PNML.Sorts.EnumerationSort{N, M}\n\nWraps tuple of IDREFs into feconstant(decldict).\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.FiniteIntRangeConstant","page":"Docstrings","title":"PNML.Sorts.FiniteIntRangeConstant","text":"Must refer to a value between the start and end of the respective FiniteIntRangeSort.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.FiniteIntRangeSort","page":"Docstrings","title":"PNML.Sorts.FiniteIntRangeSort","text":"FiniteIntRangeSort(start::T, stop::T; meta) where {T<:Integer} -> Range\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.IntegerSort","page":"Docstrings","title":"PNML.Sorts.IntegerSort","text":"Built-in sort whose eltype is Int\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.ListSort","page":"Docstrings","title":"PNML.Sorts.ListSort","text":"struct ListSort <: PNML.Sorts.AbstractSort\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.MultisetSort","page":"Docstrings","title":"PNML.Sorts.MultisetSort","text":"struct MultisetSort <: PNML.Sorts.AbstractSort\n\nWrap a UserSort. Warning: do not cause recursive multiset Sorts.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.NaturalSort","page":"Docstrings","title":"PNML.Sorts.NaturalSort","text":"Built-in sort whose eltype is Int\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.NullSort","page":"Docstrings","title":"PNML.Sorts.NullSort","text":"Built-in sort whose eltype is Nothing\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.PositiveSort","page":"Docstrings","title":"PNML.Sorts.PositiveSort","text":"Built-in sort whose eltype is Int\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.ProductSort","page":"Docstrings","title":"PNML.Sorts.ProductSort","text":"struct ProductSort{N} <: PNML.Sorts.AbstractSort\n\nAn ordered collection of sorts. The elements of the sort are tuples of elements of each sort.\n\nISO 15909-1:2019 Concept 14 (color domain) finite cartesian product of color classes. Where sorts are the syntax for color classes and ProduceSort is the color domain.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.RealSort","page":"Docstrings","title":"PNML.Sorts.RealSort","text":"Built-in sort whose eltype is Float64\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.StringSort","page":"Docstrings","title":"PNML.Sorts.StringSort","text":"struct StringSort <: PNML.Sorts.AbstractSort\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Sorts.UserSort","page":"Docstrings","title":"PNML.Sorts.UserSort","text":"struct UserSort <: PNML.Sorts.AbstractSort\n\nHolds a reference id (REFID) to a subtype of SortDeclaration.\n\nPNML.Declarations.NamedSort is used to construct a sort out of builtin sorts.\n\n\n\n\n\n","category":"type"},{"location":"library/#Base.length-Tuple{PNML.Sorts.EnumerationSort}","page":"Docstrings","title":"Base.length","text":"Return number of FEConstants contained by this sort.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Sorts.builtin_sorts-Tuple{}","page":"Docstrings","title":"PNML.Sorts.builtin_sorts","text":"Tuple of sort IDs that are considered builtin. There will be a version defined for each in the DECLDICT[]. Users may (re)define these.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Sorts.equals-Union{Tuple{T}, Tuple{T, T}} where T<:PNML.Sorts.AbstractSort","page":"Docstrings","title":"PNML.Sorts.equals","text":"equals(\n    a::PNML.Sorts.AbstractSort,\n    b::PNML.Sorts.AbstractSort\n) -> Any\n\n\nFor sorts to be the same, first they must have the same type. Then any contents of the sorts are compared semantically.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Sorts.isbuiltinsort-Tuple{Symbol}","page":"Docstrings","title":"PNML.Sorts.isbuiltinsort","text":"isbuiltinsort(::Symbol) -> Bool\n\nIs tag in builtin_sorts.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Sorts.refs-Tuple{PNML.Sorts.EnumerationSort}","page":"Docstrings","title":"PNML.Sorts.refs","text":"refs(sort::EnumerationSort) -> NTuple{N,REFID}\n\nReturn NTuple of FEConstant REFIDs.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Sorts.sorts-Tuple{PNML.Sorts.ProductSort}","page":"Docstrings","title":"PNML.Sorts.sorts","text":"sorts(ps::ProductSort)\n\nReturn sorts that are in the product.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.namedsort-Tuple{UserSort}","page":"Docstrings","title":"PNML.namedsort","text":"Get NamedSort from UserSort REFID\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.sortelements-Tuple{PNML.Sorts.BoolSort}","page":"Docstrings","title":"PNML.sortelements","text":"Elements of boolean sort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.sortelements-Tuple{PNML.Sorts.EnumerationSort}","page":"Docstrings","title":"PNML.sortelements","text":"sortelements(sort::EnumerationSort) -> Iterator\n\nReturn iterator into feconstant(DECLDICT[]) for this sort's FEConstants. Maintains order of this sort.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.sortelements-Tuple{PNML.Sorts.FiniteIntRangeSort}","page":"Docstrings","title":"PNML.sortelements","text":"Return iterator from range start to range stop, inclusive\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Declarations.AbstractDeclaration","page":"Docstrings","title":"PNML.Declarations.AbstractDeclaration","text":"abstract type AbstractDeclaration\n\nDeclarations define objects/names that are used for high-level terms in conditions, inscriptions, markings. The definitions are attached to PNML nets and/or pages using a PNML Label defined in a <declarations> tag.\n\nid\nname\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.ArbitraryOperator","page":"Docstrings","title":"PNML.Declarations.ArbitraryOperator","text":"struct ArbitraryOperator <: PNML.Declarations.OperatorDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\ndeclaration::Symbol\n\n...arbitrary sorts and operators do not come with a definition of the sort or operation; they just introduce a new symbol.\n\nLike ArbitrarySort, does not have an associated algebra, not usable by SymmetricNet.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.ArbitrarySort","page":"Docstrings","title":"PNML.Declarations.ArbitrarySort","text":"struct ArbitrarySort <: PNML.Declarations.SortDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\nbody::Symbol\n\nArbitrary sorts that can be used for constructing terms are reserved for/supported by HLPNG in the pnml specification.\n\n...arbitrary sorts and operators do not come with a definition of the sort or operation; they just introduce a new symbol.\n\nLike ArbitraryOperator, does not have an associated algebra, not usable by SymmetricNet.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.FEConstant","page":"Docstrings","title":"PNML.Declarations.FEConstant","text":"FEConstant\n\nFinite enumeration constant.\n\nUsage\n\nfec = FEConstant(:anID, \"somevalue\", :sortrefid)\nfec() == :anID\nfec.name = \"somevalue\"\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.NamedOperator","page":"Docstrings","title":"PNML.Declarations.NamedOperator","text":"struct NamedOperator{T} <: PNML.Declarations.OperatorDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\nparameter::Vector{PNML.Declarations.VariableDeclaration}\ndef::Any\n\nSee UserOperator\n\nVector of VariableDeclaration for parameters (ordered), and duck-typed AbstractTerm for its body.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.NamedSort","page":"Docstrings","title":"PNML.Declarations.NamedSort","text":"struct NamedSort{S<:PNML.Sorts.AbstractSort} <: PNML.Declarations.SortDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\ndef::PNML.Sorts.AbstractSort\n\nDeclaration of a NamedSort. Wraps an instance of an AbstractSort. See MultisetSort, ProductSort, UserSort.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.OperatorDeclaration","page":"Docstrings","title":"PNML.Declarations.OperatorDeclaration","text":"abstract type OperatorDeclaration <: PNML.Declarations.AbstractDeclaration\n\nNamedOperator. FEConstant, PartitionElement and ArbitraryOperator are all referenced by UserOperator.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.PartitionElement","page":"Docstrings","title":"PNML.Declarations.PartitionElement","text":"PartitionElement(id::Symbol, name, Vector{IDREF}, REFID)\n\nid::Symbol\nname::Union{SubString{String}, String}\nterms::Vector{Symbol}\npartition::Symbol\n\nEstablishes an equivalence class over a PNML.Declarations.PartitionSort's emumeration. See also FiniteEnumerationSort. Gives a name to an element of a partition. The element is an equivalence class.\n\nPartitionElement is different from FiniteEnumeration, CyclicEnumeration, FiniteIntRangeSort in that it holds UserOperators, not FEConstants. The UserOperator refers to the FEConstants of the sort over which the partition is defined. NB: FEConstants are 0-arity operators. UserOperator is how operation declarations are accessed.\n\nNB: The \"PartitionElementOf\" operator maps each element of the FiniteEnumeration (referenced by the partition) to the PartitionElement (of the partition) to which it belongs.\n\nPartitionElementOf(partition, feconstant) -> PartitionElement partitionelementof(partition, feconstant) -> PartitionElement\n\nPartitionElementOf is passed a REFID of the partition whose PartitionElement membership is being queried.\n\nEach PartitionElement contains a collection of REFIDs to UserOperators which refer to a finite sort's (FiniteEnumeration, CyclicEnumeration, FiniteIntRangeSort) FEConstant by REFID.\n\nTest for membership by iterating over each partition element, and over each term.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.PartitionSort","page":"Docstrings","title":"PNML.Declarations.PartitionSort","text":"struct PartitionSort <: PNML.Declarations.SortDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\ndef::Symbol\nelements::Vector{PNML.Declarations.PartitionElement}\n\nPartition sort declaration is a finite enumeration that is partitioned into sub-ranges of enumerations. Is the sort at the partition or the element level (1 sort or many sorts?)\n\nLike NamedSort, will add an id and name to a sort, however, it used indirection via a UserSort.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.SortDeclaration","page":"Docstrings","title":"PNML.Declarations.SortDeclaration","text":"abstract type SortDeclaration <: PNML.Declarations.AbstractDeclaration\n\nSee PNML.Declarations.NamedSort and [PNML.Declarations.ArbitrarySort] as concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.UnknownDeclaration","page":"Docstrings","title":"PNML.Declarations.UnknownDeclaration","text":"struct UnknownDeclaration <: PNML.Declarations.AbstractDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\nnodename::Union{SubString{String}, String}\ncontent::Vector{PNML.AnyElement}\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.VariableDeclaration","page":"Docstrings","title":"PNML.Declarations.VariableDeclaration","text":"struct VariableDeclaration <: PNML.Declarations.AbstractDeclaration\n\nid::Symbol\nname::Union{SubString{String}, String}\nsort::UserSort\n\nPNML.DeclDict variabledecls[id] = tuple(VariableDeclaration(id, \"human name\", sort), instanceofsort)\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Declarations.contains","page":"Docstrings","title":"PNML.Declarations.contains","text":"Return Bool true if fec in pe.terms\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Declarations.element_ids-Tuple{PNML.Declarations.PartitionSort, Symbol}","page":"Docstrings","title":"PNML.Declarations.element_ids","text":"Iterator over partition element REFIDs of a `PartitionSort\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Declarations.element_names-Tuple{PNML.Declarations.PartitionSort, Symbol}","page":"Docstrings","title":"PNML.Declarations.element_names","text":"Iterator over partition element names\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlGraphics.Coordinate","page":"Docstrings","title":"PNML.PnmlGraphics.Coordinate","text":"struct Coordinate{T<:Float32}\n\nx_::Float32\ny_::Float32\n\nCartesian Coordinate are actually positive decimals. Ranges from 0 to 999.9.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlGraphics.Coordinate-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1<:Number, T2<:Number}","page":"Docstrings","title":"PNML.PnmlGraphics.Coordinate","text":"Construct a Coordinate from mixed Int, Float64.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.PnmlGraphics.Fill","page":"Docstrings","title":"PNML.PnmlGraphics.Fill","text":"Fill attributes as strings.\n\nstruct Fill\n\ncolor::String\nimage::String\ngradient_color::String\ngradient_rotation::String\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlGraphics.Font","page":"Docstrings","title":"PNML.PnmlGraphics.Font","text":"Font attributes as strings.\n\nstruct Font\n\nfamily::String\nstyle::String\nweight::String\nsize::String\nalign::String\nrotation::String\ndecoration::String\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlGraphics.Graphics","page":"Docstrings","title":"PNML.PnmlGraphics.Graphics","text":"PNML Graphics can be attached to many parts of PNML models.\n\nstruct Graphics{T<:Float32}\n\ndimension::PNML.PnmlGraphics.Coordinate\nfill::PNML.PnmlGraphics.Fill\nfont::PNML.PnmlGraphics.Font\nline::PNML.PnmlGraphics.Line\noffset::PNML.PnmlGraphics.Coordinate\npositions::Array{PNML.PnmlGraphics.Coordinate{T}, 1} where T<:Float32\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.PnmlGraphics.Line","page":"Docstrings","title":"PNML.PnmlGraphics.Line","text":"Line attributes as strings.\n\nstruct Line\n\ncolor::String\nshape::String\nstyle::String\nwidth::String\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.AbstractLabel","page":"Docstrings","title":"PNML.Labels.AbstractLabel","text":"abstract type AbstractLabel\n\nLabels are attached to the Petri Net Graph objects. See AbstractPnmlObject.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Annotation","page":"Docstrings","title":"PNML.Labels.Annotation","text":"abstract type Annotation <: PNML.Labels.AbstractLabel\n\nLabel that may be displayed. Differs from an Attribute Label by possibly having a Graphics field.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Condition","page":"Docstrings","title":"PNML.Labels.Condition","text":"(c::Condition)(args) -> Bool\n\nUse args, a dictionary of variable substitutions into the expression to return a Bool.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Condition-2","page":"Docstrings","title":"PNML.Labels.Condition","text":"mutable struct Condition{T<:PnmlExpr, N} <: PNML.Labels.Annotation\n\ntext::Union{Nothing, String}\nterm::PnmlExpr\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\nvars::NTuple{N, Symbol} where N\n\nLabel a Transition with an boolean expression used to determine when/if the transition fires.\n\nThere may be other things evaluating to boolean used to determine transition firing filters, including: priority labels, inhibitor arc, place capacity labels, time/delay labels.\n\nExamples\n\njulia> c = PNML.Labels.Condition(false)\nCondition(\"\", BooleanEx(BooleanConstant(false)))\n\njulia> c()\nfalse\n\njulia> c = PNML.Labels.Condition(\"xx\", BooleanEx(BooleanConstant(true)))\nCondition(\"xx\", BooleanEx(BooleanConstant(true)))\n\njulia> c()\ntrue\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Declaration","page":"Docstrings","title":"PNML.Labels.Declaration","text":"struct Declaration <: PNML.Labels.Annotation\n\ntext::Union{Nothing, String}\nddict::DeclDict\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\n\nLabel of a <net> or <page> that holds zero or more declarations. The declarations are used to define parts of the many-sorted algebra used by High-Level Petri Nets.\n\nAll the declarations in the <structure> are placed into a single per-net dictonary. The text, graphics, and tools fields are expected to be nothing, but are present because, being labels, it is allowed.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.HLAnnotation","page":"Docstrings","title":"PNML.Labels.HLAnnotation","text":"abstract type HLAnnotation <: PNML.Labels.AbstractLabel\n\nAnnotation label that uses <text> and <structure>.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.HLInscription","page":"Docstrings","title":"PNML.Labels.HLInscription","text":"struct HLInscription{T<:PnmlExpr, N} <: PNML.Labels.HLAnnotation\n\ntext::Union{Nothing, String}\nterm::PnmlExpr\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\nvars::NTuple{N, Symbol} where N\n\nLabels an Arc with a term in a many-sorted algebra. See also Inscription for non-high-level net inscriptions.\n\nHLInscription(t::PnmlExpr)() is a functor evaluating the expression and a value of the eltype of sort of inscription.\n\nExamples\n\nins() isa eltype(sortof(ins))\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.HLLabel","page":"Docstrings","title":"PNML.Labels.HLLabel","text":"struct HLLabel{PNTD} <: PNML.Labels.Annotation\n\ntext::Union{Nothing, String}\nstructure::Union{Nothing, PNML.AnyElement}\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\n\nHigh-level pnml labels are expected to have <text> and <structure> elements. This concrete type is for \"unclaimed\" labels in a high-level petri net.\n\nSome \"claimed\" HLAnnotation labels are Condition, Declaration, HLMarking, HLInscription.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.HLMarking","page":"Docstrings","title":"PNML.Labels.HLMarking","text":"(hlm::HLMarking)() -> PnmlMultieset\n\nEvaluate a HLMarking term.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.HLMarking-2","page":"Docstrings","title":"PNML.Labels.HLMarking","text":"mutable struct HLMarking{T<:PnmlExpr} <: PNML.Labels.HLAnnotation\n\ntext::Union{Nothing, String}\nterm::PnmlExpr\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\n\nMultiset of a sort labeling of a Place in a High-level Petri Net Graph. See AbstractHLCore, AbstractTerm, Marking.\n\nIs a functor that returns the evaluated value.\n\n... is a term with some multiset sort denoting a collection of tokens on the corresponding place, which defines its initial marking.\n\nNB: The place's sorttype is not a multiset\n\na ground term of the corresponding multiset sort. (does not contain variables)\n\nFor every sort, the multiset sort over this basis sort is interpreted as the set of multisets over the type associated with the basis sort.\n\nMultiset literals ... are defined using Add and NumberOf (multiset operators).\n\nExamples\n\n; setup=:(using PNML; using PNML: HLMarking, NaturalSort, NumberConstant; PNML.fill_nonhl!(PNML.DECLDICT[]))\njulia> m = HLMarking(PNML.pnmlmultiset(usersort(:integer), 1))\nHLMarking(Bag(usersort(:integer), 1))\n\njulia> m()\n1\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Inscription","page":"Docstrings","title":"PNML.Labels.Inscription","text":"struct Inscription{T<:PnmlExpr} <: PNML.Labels.Annotation\n\nterm::PnmlExpr\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\n\nLabels an Arc. See also HLInscription. ```\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Marking","page":"Docstrings","title":"PNML.Labels.Marking","text":"struct Marking{T<:PnmlExpr} <: PNML.Labels.Annotation\n\nterm::PnmlExpr\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\n\nNumber-valued label of Place. See PTNet, ContinuousNet, HLMarking.\n\nIs a functor that returns the value. ```\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Marking-Tuple{}","page":"Docstrings","title":"PNML.Labels.Marking","text":"Evaluate Marking instance by returning the evaluated TermInterface expression.\n\nThe Marking vs. HLMarking values differ by handling of token identity. Place/Transition Nets (PNet, ContinuousNet) use collective token identity (map to ::Number). High-level Nets (SymmetricNet, HLPNG) use individual token identity (colored petri nets). TODO Cite John Baez for this distinction.\n\nThere is a multi-sorted algebra definition mechanism defined for HL Nets. HLMarking values are a ground terms of this multi-sorted algebra. There are abstract syntax trees defined by PNML. We use TermInterface to implement/manipulate the terms.\n\nInscription and condition expressions may contain variables that map to a place's tokens. HL Nets need to evaluate expressions as part of enabling and transition firing rules. The result must be a ground term, and is used to update a marking.\n\nFor non-High,level nets, the inscrition TermInterface expression evaluates to a Number and the condition is a boolean expression (default true).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.Name","page":"Docstrings","title":"PNML.Labels.Name","text":"struct Name <: PNML.Labels.Annotation\n\ntext::String\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\n\nName is for display, possibly in a tool specific way.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.PnmlLabel","page":"Docstrings","title":"PNML.Labels.PnmlLabel","text":"struct PnmlLabel <: PNML.Labels.Annotation\n\ntag::Symbol\nelements::Union{SubString{String}, String, OrderedCollections.LittleDict{Union{String, Symbol}, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Union{String, Symbol}}}, AbstractVector{Union{String, Symbol}}}, VS<:Union{Tuple, AbstractVector{Any}}}, Vector{Union{SubString{String}, String, OrderedCollections.LittleDict{Union{String, Symbol}, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Union{String, Symbol}}}, AbstractVector{Union{String, Symbol}}}, VS<:Union{Tuple, AbstractVector{Any}}}}}}\n\nWrap an AbstractDict holding a PNML Label as parsed by XMLDict. Use the XML tag as identifier.\n\nUsed for \"unclaimed\" labels that do not have, or we choose not to use, a dedicated parse method. Claimed labels will have a type/parser defined to make use of the structure defined by the pntd schema.\n\nSee also AnyElement. The difference is that AnyElement allows any well-formed XML, while PnmlLabel is restricted to PNML Labels (with extensions in PNML.jl).\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.SortType","page":"Docstrings","title":"PNML.Labels.SortType","text":"struct SortType <: PNML.Labels.Annotation\n\ntext::Union{Nothing, String}\nsort_::UserSort\ngraphics::Union{Nothing, PNML.PnmlGraphics.Graphics}\ntools::Union{Nothing, Vector{PNML.ToolInfo}}\n\nA places's <type> label wraps a UserSort that holds a REFID to the sort of a place, hence use of sorttype. It is the type (or set) concept of the many-sorted algebra.\n\nFor high-level nets there will be a declaration section with a rich language of sorts using UserSort & PNML.Declarations.NamedSort defined in the xml input.\n\nFor other PnmlNet's they are used internally to allow common implementations.\n\ndefines the type by referring to some sort; by the fixed interpretation of built-in sorts,\n\nthis sort defines the type of the place.\n\nBy the fixed interpretation of sorts, this implicitly refers to a set, which is the type of that place.\n\n\"refers to set\" excludes multiset (as stated elsewhere in specification)\n\nthis is a sort, not a term, so no variables or operators.\n\nThe initial marking function M0 is defined by the label HLMarking of the places. ... this is a ground term of the corresponding multiset sort.\n\nGround terms have no variables and can be evaluated outside of a transition firing rule.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.Structure","page":"Docstrings","title":"PNML.Labels.Structure","text":"struct Structure\n\ntag::Symbol\nel::Union{SubString{String}, String, OrderedCollections.LittleDict{Union{String, Symbol}, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Union{String, Symbol}}}, AbstractVector{Union{String, Symbol}}}, VS<:Union{Tuple, AbstractVector{Any}}}, Vector{Union{SubString{String}, String, OrderedCollections.LittleDict{Union{String, Symbol}, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Union{String, Symbol}}}, AbstractVector{Union{String, Symbol}}}, VS<:Union{Tuple, AbstractVector{Any}}}}}}\n\nHigh-level Annotation Labels place meaning in <structure> that is consumed by \"claimed\" labels. Is is expected to contain an abstract syntax tree (ast) for the many-sorted algebra expressed in XML. We implement this to allow use of <structure> tags by other PnmlTypes.\n\nExtra\n\nThere are various defined structure ast variants in pnml:\n\nSort Type of a Place [builtin, multi, product, user]\nPlace HLMarking [variable, operator]\nTransition Condition [variable, operator]\nArc Inscription [variable, operator]\nDeclarations [sort, variable, operator]\n\nThese should all have dedicated parsers and objects as claimed labels. Here we provide a fallback for unclaimed tags.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels.TransitionRate","page":"Docstrings","title":"PNML.Labels.TransitionRate","text":"struct TransitionRate{T<:Number} <: PNML.Labels.Annotation\n\nvalue::Number\n\nWrap value of rate label of a Transition.\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Labels._attribute-Tuple{OrderedCollections.LittleDict{Union{String, Symbol}, Any, KS, VS} where {KS<:Union{Tuple{Vararg{Union{String, Symbol}}}, AbstractVector{Union{String, Symbol}}}, VS<:Union{Tuple, AbstractVector{Any}}}, Symbol}","page":"Docstrings","title":"PNML.Labels._attribute","text":"Find an XML attribute. XMLDict uses symbols as keys. Value returned is a string.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.default_condition-Tuple{PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Labels.default_condition","text":"default_condition(pntd::PnmlType) -> Condition\n\nHas meaning of true or always.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.default_hlinscription-Union{Tuple{T}, Tuple{T, PNML.Labels.SortType}} where T<:PNML.PnmlTypeDefs.AbstractHLCore","page":"Docstrings","title":"PNML.Labels.default_hlinscription","text":"default_hlinscription(\n    _::PNML.PnmlTypeDefs.AbstractHLCore,\n    placetype::PNML.Labels.SortType\n) -> PNML.Labels.HLInscription{Bag, 0}\n\n\nReturn default HLInscription value based on PNTD. Has meaning of unity, as in one of the adjacent place's sorttype. #TODO Add element of sort selector\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.default_inscription","page":"Docstrings","title":"PNML.Labels.default_inscription","text":"Return default inscription value based on PNTD. Has meaning of unity, as in one.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Labels.default_marking-Tuple{PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Labels.default_marking","text":"default_marking(t::PNML.PnmlTypeDefs.PnmlType)\n\n\nReturn default marking value based on PnmlType. Has meaning of empty, as in zero. For high-level nets, the marking is an empty multiset whose basis matches placetype. Others have a marking that is a Number.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.default_typeusersort","page":"Docstrings","title":"PNML.Labels.default_typeusersort","text":"Return instance of default SortType UserSort based on PNTD. Useful for non-high-level nets and PTNet. See PNML.fill_nonhl!\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Labels.delay-Tuple{Any}","page":"Docstrings","title":"PNML.Labels.delay","text":"delay(transition) -> Tuple{AbstractString, Float64, Float64}\n\n\nReturn delay label value of transition as interval tuple: (\"closure-string\", left, right) Missing delay labels default to (\"closed\", 0.0, 0.0) a.k.a. zero.\n\nAll net types may have a delay value type. Expected label XML: see MathML. Only non-negative.\n\nSupports\n\n(\"closed-open\", 0.0, ∞)  -> [0.0, ∞)\n(\"open-closed\", 2.0, 6.0 -> (2.0, 6.0]\n(\"open\", 2.0, 6.0)       -> (2.0, 6.0)\n(\"closed\", 2.0, 6.0)     -> [2.0, 6.0]\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.get_labels-Tuple{Any, Symbol}","page":"Docstrings","title":"PNML.Labels.get_labels","text":"get_labels(iteratable, s::Symbol) -> Iterator\n\nFilter iteratable collection for elements having s as the tag.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.hastag-Tuple{Any, Symbol}","page":"Docstrings","title":"PNML.Labels.hastag","text":"hastag(x, tagvalue::Symbol) -> Function\n\nReturn method with one argument. Duck-typed to test anything with tag accessor.\n\nEXAMPLES\n\nIterators.filter(Fix2(hastag, tagvalue), iteratable)\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.rate-Tuple{Any}","page":"Docstrings","title":"PNML.Labels.rate","text":"rate(t::Transition) -> Real\n\nReturn rate label value of transition.  Missing rate labels are defaulted to zero.\n\nAll net types may have a rate value type. Expected label XML: <rate> <text>0.3</text> </rate>\n\nSee rate_value_type.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.text-Tuple{PNML.Labels.AbstractLabel}","page":"Docstrings","title":"PNML.Labels.text","text":"Return text field. All labels are expected to have one that may be nothing or an empty string.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Labels.text_content","page":"Docstrings","title":"PNML.Labels.text_content","text":"Find first :text in vx and return its :content as string.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.def_sort_element-Tuple{PNML.Labels.SortType}","page":"Docstrings","title":"PNML.def_sort_element","text":"def_sort_element(pt)\n\nReturn an arbitrary element of the sort. All sorts are expected to be iteratable, so we return first. Uses include default inscription value and default initial marking value sort.\n\npt can be anything with a sortelements method that returns an iterator that has length. See AbstractSort, SortType.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.get_label-Tuple{Any, Symbol}","page":"Docstrings","title":"PNML.get_label","text":"Return label matching tagvalueornothing``.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.has_label-Tuple{Any, Symbol}","page":"Docstrings","title":"PNML.has_label","text":"Return true if collection v contains label with tagvalue.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.term-Tuple{PNML.Labels.HLMarking}","page":"Docstrings","title":"PNML.term","text":"term(marking) -> PnmlExpr\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.pnml_ns","page":"Docstrings","title":"PNML.Parser.pnml_ns","text":"Namespace expected for pnml XML.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.Parser.sort_ids","page":"Docstrings","title":"PNML.Parser.sort_ids","text":"Tags used in sort XML elements.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.Parser.transition_xlabels","page":"Docstrings","title":"PNML.Parser.transition_xlabels","text":"Transition enrichment labels.\n\n\n\n\n\n","category":"constant"},{"location":"library/#PNML.Parser.ParseInscriptionTerm","page":"Docstrings","title":"PNML.Parser.ParseInscriptionTerm","text":"ParseInscriptionTerm(placetype) -> Functor\n\nHolds parameters for parsing inscription. The sort of the inscription must match the place sorttype. Input arcs (source is a transition) and output arcs (source is a place) called as (pit::ParseInscriptionTerm)(::XMLNode, ::PnmlType)\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Parser.ParseMarkingTerm","page":"Docstrings","title":"PNML.Parser.ParseMarkingTerm","text":"ParseMarkingTerm(placetype) -> Functor\n\nHolds parameters for parsing when called as (f::T)(::XMLNode, ::PnmlType)\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Parser.XMLNode","page":"Docstrings","title":"PNML.Parser.XMLNode","text":"Alias for EzXML.Node\n\n\n\n\n\n","category":"type"},{"location":"library/#PNML.Parser._parse_page!-Union{Tuple{T}, Tuple{Any, Any, EzXML.Node, T, Symbol}} where T<:PNML.PnmlTypeDefs.PnmlType","page":"Docstrings","title":"PNML.Parser._parse_page!","text":"parse_page!(pagedict, netdata, node, pntd) -> Page\n\nPlace Page in pagedict using id as the key.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.add_toolinfo!-Tuple{Vector{PNML.ToolInfo}, Any, Any}","page":"Docstrings","title":"PNML.Parser.add_toolinfo!","text":"add_toolinfo!(\n    infos::Vector{PNML.ToolInfo},\n    node,\n    pntd\n) -> Vector{PNML.ToolInfo}\n\n\nAdd ToolInfo to infos, return nothing.\n\nThe UML from the pnml primer (and schemas) use <toolspecific> as the tag name for instances of the type ToolInfo.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.allchildren-Tuple{EzXML.Node, AbstractString}","page":"Docstrings","title":"PNML.Parser.allchildren","text":"allchildren(\n    node::EzXML.Node,\n    tag::AbstractString;\n    namespace\n) -> Vector{EzXML.Node}\n\n\nReturn vector of el's immediate children with tag.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.alldecendents-Tuple{EzXML.Node, AbstractString}","page":"Docstrings","title":"PNML.Parser.alldecendents","text":"alldecendents(\n    node::EzXML.Node,\n    tag::AbstractString;\n    namespace\n) -> Vector{EzXML.Node}\n\n\nReturn vector of node's immediate children and decendents with tag.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.anyelement-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.anyelement","text":"anyelement(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> PNML.AnyElement\n\n\nReturn AnyElement holding a well-formed XML node. See ToolInfo for one intended use-case.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.attribute","page":"Docstrings","title":"PNML.Parser.attribute","text":"attribute(node::EzXML.Node, key::AbstractString) -> String\nattribute(\n    node::EzXML.Node,\n    key::AbstractString,\n    msg::String\n) -> String\n\n\nReturn XML attribute value.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.deduce_sort-Tuple{Any}","page":"Docstrings","title":"PNML.Parser.deduce_sort","text":"Return sort REFID.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.eval_initialmarking_term-Tuple{}","page":"Docstrings","title":"PNML.Parser.eval_initialmarking_term","text":"\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.firstchild","page":"Docstrings","title":"PNML.Parser.firstchild","text":"firstchild(\n    node::EzXML.Node,\n    tag::AbstractString\n) -> Union{Nothing, EzXML.Node}\nfirstchild(\n    node::EzXML.Node,\n    tag::AbstractString,\n    namespace::AbstractString\n) -> Union{Nothing, EzXML.Node}\n\n\nReturn up to 1 immediate child of el that is a tag.  ns is the default namespace. Invent a prefix to create an iterator of namespace prefix and URI pairs\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.get_toolinfos!-Tuple{Any, Any, Any}","page":"Docstrings","title":"PNML.Parser.get_toolinfos!","text":"get_toolinfos!(tools, node, pntd) -> tools\n\nCalls add_toolinfo(tools, info, pntd)` for each info found.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.make_usersort-Tuple{Symbol, String, Any}","page":"Docstrings","title":"PNML.Parser.make_usersort","text":"make_usersort(tag::Symbol, name::String, sort) -> sort\n\nFill the declaration dictionary with a namedsort and usersort.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_arc!-NTuple{4, Any}","page":"Docstrings","title":"PNML.Parser.parse_arc!","text":"Fill arcset, arcdict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_arc-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_arc","text":"parse_arc(node::XMLNode, pntd::PnmlType) -> Arc\n\nConstruct an Arc with labels specialized for the PnmlType.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_condition-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_condition","text":"parse_condition(::XMLNode, ::PnmlType) -> Condition\n\nLabel of transition node. Used in the enabling function.\n\nDetails\n\nISO/IEC 15909-1:2019(E) Concept 15 (symmetric net) introduces Φ(transition), a guard or filter function, that is and'ed into the enabling function. 15909-2 maps this to <condition> expressions.\n\nLater concepts add filter functions that are also and'ed into the enabling function.\n\nConcept 28 (prioritized Petri net enabling rule)\nConcept 31 (time Petri net enabling rule)\n\nWe support PTNets having <condition> with same syntax as High-level nets. Condition has <text> and <structure> elements, with all meaning in the <structure> that holds an expression evaluating to a boolean value.\n\nOne field of a Condition holds an expression, see BoolExpr. Another field holds information on variables in the expression.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_condition_term-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_condition_term","text":"parse_condition_term(::XMLNode, ::PnmlType) -> PnmlExpr, UserSort\n\nUsed as a termparser by parse_label_content for Condition label of a Transition; will have a structure element containing a term.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_declaration","page":"Docstrings","title":"PNML.Parser.parse_declaration","text":"Return Declaration label of 'net' or 'page' node. Assume behavior of a High-level Net label in that the meaning is in a <structure>.\n\nExpected format: <declaration> <structure> <declarations> <namedsort/> <namedsort/> ...\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.parse_feconstants","page":"Docstrings","title":"PNML.Parser.parse_feconstants","text":"parse_feconstants(::XMLNode, ::PnmlType, ::REFID) -> Tuple{Symbols}\n\nPlace the constants into feconstants(). Return tuple of finite enumeration constant REFIDs.\n\nAccess as 0-ary operator indexed by REFID\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.parse_file-Tuple{AbstractString}","page":"Docstrings","title":"PNML.Parser.parse_file","text":"parse_file(fname::AbstractString) -> PnmlModel\n\n\nBuild a PnmlModel from a file containing XML. See parse_str and parse_pnml.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_graphics-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_graphics","text":"parse_graphics(\n    node,\n    pntd\n) -> PNML.PnmlGraphics.Graphics{Float32}\n\n\nArcs, Annotations and Nodes have different graphics semantics. Return a Graphics holding the union of possibilities.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_graphics_coordinate-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_graphics_coordinate","text":"parse_graphics_coordinate(\n    node,\n    pntd\n) -> PNML.PnmlGraphics.Coordinate{Float32}\n\n\nReturn Coordinate. Specification seems to only use integers, we also allow real numbers.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_graphics_fill-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_graphics_fill","text":"parse_graphics_fill(node, pntd) -> PNML.PnmlGraphics.Fill\n\n\nReturn Fill\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_graphics_font-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_graphics_font","text":"parse_graphics_font(node, pntd) -> PNML.PnmlGraphics.Font\n\n\nReturn Font.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_graphics_line-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_graphics_line","text":"parse_graphics_line(node, pntd) -> PNML.PnmlGraphics.Line\n\n\nReturn Line.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_hlinitialMarking-Tuple{EzXML.Node, PNML.Labels.SortType, PNML.PnmlTypeDefs.AbstractHLCore}","page":"Docstrings","title":"PNML.Parser.parse_hlinitialMarking","text":"parse_hlinitialMarking(\n    node::EzXML.Node,\n    placetype::PNML.Labels.SortType,\n    pntd::PNML.PnmlTypeDefs.AbstractHLCore\n) -> PNML.Labels.HLMarking\n\n\nHigh-level initial marking labels are expected to have a <structure> child containing a ground term. Sort of marking term must be the same as placetype, the places SortType. Will be a UserSort that holds the ID of a sort declaration.\n\nNB: Used by PTNets that assume placetype is DotSort().\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_hlinscription-Tuple{EzXML.Node, Symbol, Symbol, PNML.PnmlTypeDefs.AbstractHLCore}","page":"Docstrings","title":"PNML.Parser.parse_hlinscription","text":"parse_hlinscription(\n    node::EzXML.Node,\n    source::Symbol,\n    target::Symbol,\n    pntd::PNML.PnmlTypeDefs.AbstractHLCore;\n    netdata\n)\n\n\nhlinscriptions are expressions.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_initialMarking-Tuple{EzXML.Node, PNML.Labels.SortType, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_initialMarking","text":"parse_initialMarking(\n    node::EzXML.Node,\n    placetype::PNML.Labels.SortType,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> PNML.Labels.Marking{T} where T<:NumberEx\n\n\nNon-high-level PnmlType initial marking parser. Most things are assumed to be Numbers.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_inscription-Tuple{EzXML.Node, Symbol, Symbol, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_inscription","text":"parse_inscription(\n    node::EzXML.Node,\n    source::Symbol,\n    target::Symbol,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> PNML.Labels.Inscription{T} where T<:Union{NumberEx{Float64}, NumberEx{Int64}}\n\n\nIgnore the source & target IDREF symbols.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_label-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_label","text":"parse_label(\n    node::EzXML.Node,\n    _::PNML.PnmlTypeDefs.PnmlType\n) -> @NamedTuple{tag::Symbol, xml::EzXML.Node}\n\n\nShould not often have a <label> tag, this will bark if one is found and return NamedTuple (tag,xml) to defer parsing the xml.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_label_content-Union{Tuple{F}, Tuple{EzXML.Node, F, PNML.PnmlTypeDefs.PnmlType}} where F","page":"Docstrings","title":"PNML.Parser.parse_label_content","text":"parse_label_content(node::XMLNode, termparser, pntd) -> NamedTuple\n\nParse top-level label using a termparser callable applied to any <structure> element. Also parses <text>, <toolinfo>, graphics and sort of term.\n\nTop-level labels are marking, inscription, condition. Each having a termparser.\n\nReturns vars, a tuple of PNML variable REFIDs. Used in the muti-sorted algebra of High-level nets.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_name-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_name","text":"parse_name(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> PNML.Labels.Name\n\n\nReturn Name label holding text value and optional tool & GUI information.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_namedoperator-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_namedoperator","text":"parse_namedoperator(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> NamedOperator\n\n\nDeclaration of an operator expression in many-sorted algebra.\n\nAn operator of arity 0 is a constant (ground-term, literal). When arity > 0, the parameters are variables, using a NamedTuple for values.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_namedsort-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_namedsort","text":"parse_namedsort(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> NamedSort\n\n\nDeclaration that wraps a Sort, adding an ID and name.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_net","page":"Docstrings","title":"PNML.Parser.parse_net","text":"parse_net(node::EzXML.Node) -> PnmlNet\nparse_net(\n    node::EzXML.Node,\n    pntd_override::Union{Nothing, PNML.PnmlTypeDefs.PnmlType}\n) -> PnmlNet\n\n\nReturn a PnmlNet`.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.parse_net_1-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType, Symbol}","page":"Docstrings","title":"PNML.Parser.parse_net_1","text":"Parse PNML <net> with a defined PnmlType used to set the expected behavior of labels attached to the nodes of a petri net graph, including: marking, inscription, condition and sorttype.\n\nPage IDs are appended as the XML tree is descended, followed by node IDs.\n\nNote the use of scoped value DECLDICT[] to access the per-net data structure as a scoped global. Some uses of this scoped value are embedded in accessor methods like variabledecls().\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_operator_term-Tuple{Symbol, EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_operator_term","text":"parse_operator_term(\n    tag::Symbol,\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType;\n    vars\n)\n\n\nBuild an Operator Functor from the XML tree at node.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_page!-Tuple{Any, Any, Any, EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_page!","text":"Call parse_page!, add page to dictionary and id set\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_partitionelement!-Tuple{Vector{PNML.Declarations.PartitionElement}, EzXML.Node, Symbol}","page":"Docstrings","title":"PNML.Parser.parse_partitionelement!","text":"parse_partitionelement!(elements::Vector{PartitionElement}, node::XMLNode)\n\nParse <partitionelement>, add FEconstant refids to the element and append element to the vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_place!-NTuple{4, Any}","page":"Docstrings","title":"PNML.Parser.parse_place!","text":"Fill placeset, placedict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_place-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_place","text":"parse_place(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> Place{PNTD, M} where {PNTD<:PNML.PnmlTypeDefs.PnmlType, M<:Union{PNML.Labels.HLMarking, PNML.Labels.Marking{T} where T<:NumberEx}}\n\n\nsee fill_nonhl!\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_pnml-Tuple{EzXML.Node}","page":"Docstrings","title":"PNML.Parser.parse_pnml","text":"parse_pnml(xmlnode) -> PnmlModel\n\nStart parse from the root node of a well formed pnml XML document. Return a PnmlModel holding one or more PnmlNet. And each net has an independent ID Registry.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_refPlace!-NTuple{4, Any}","page":"Docstrings","title":"PNML.Parser.parse_refPlace!","text":"Fill refplaceset, refplacedict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_refPlace-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_refPlace","text":"parse_refPlace(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> RefPlace\n\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_refTransition!-NTuple{4, Any}","page":"Docstrings","title":"PNML.Parser.parse_refTransition!","text":"Fill reftransitionset, reftransitiondict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_refTransition-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_refTransition","text":"parse_refTransition(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> RefTransition\n\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_sort","page":"Docstrings","title":"PNML.Parser.parse_sort","text":"parse_sort(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> Union{Nothing, PNML.Sorts.AbstractSort}\nparse_sort(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType,\n    refid::Symbol\n) -> Union{Nothing, PNML.Sorts.AbstractSort}\n\n\nSorts are found within an enclosing XML element, usually <structure>. PNML maps the sort element name, frequently called a 'tag', to the body of the sort. Heavily-used in the high-level abstract syntax tree. Some nesting is used. Meaning that some sorts contain other sorts.\n\nSee also parse_sorttype_term, parse_namedsort, parse_variabledecl.\n\n\n\n\n\n","category":"function"},{"location":"library/#PNML.Parser.parse_sorttype_term-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_sorttype_term","text":"parse_sorttype_term(::XMLNode, ::PnmlType) ->\n\nThe PNML \"type\" of a Place is a \"sort\" of the high-level many-sorted algebra.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_str-Tuple{AbstractString}","page":"Docstrings","title":"PNML.Parser.parse_str","text":"parse_str(str::AbstractString) -> PnmlModel\n\n\nBuild a PnmlModel from a string containing XML. See parse_file and parse_pnml.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_structure-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_structure","text":"parse_structure(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> Any\n\n\nReturn PNML.Labels.Structure holding an XML <structure>. Should be inside of an PNML label. A \"claimed\" label usually elids the <structure> level (does not call this method).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_term-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_term","text":"parse_term(::XMLNode, ::PnmlType) -> (PnmlExpr, sort, vars)\nparse_term(::Val{:tag}::XMLNode, ::PnmlType) -> (PnmlExpr, sort, vars)\n\nThere will be no XML node <term>. Instead it is the interpertation of the child of a <structure>, <subterm> or <def> element with a nodename of tag.\n\nThe Relax NG Schema does contain concept of an abstact \"Term\". Concrete term kinds are Variable and Operator.\n\nAll terms have a sort, #TODO\n\nWill be using TermInterface.jl to build an expression tree (AST) that can contain: operators, constants (as 0-airity operators), and variables.\n\nAST are evaluated for place initialMarking (ground terms only) and transition firing where conditions and inscription expressions may contain non-ground terms (using variables).\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_term-Tuple{Val{:gtp}, EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_term","text":"`<gtp>` Partition element greater than.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_term-Tuple{Val{:partitionelementof}, EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_term","text":"parse_partitionelement!(elements::Vector{PartitionElement}, node::XMLNode)\n\nParse <partitionelement>, add FEconstant refids to the element and append element to the vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_text-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_text","text":"parse_text(\n    node::EzXML.Node,\n    _::PNML.PnmlTypeDefs.PnmlType\n) -> String\n\n\nReturn the stripped string of node's content.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_tokengraphics-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_tokengraphics","text":"parse_tokengraphics(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> PNML.TokenGraphics{Float32}\n\n\nParse high-level place-transition net's (HL-PTNet) toolspecific structure defined for token graphics. See TokenGraphics and parse_tokenposition.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_tokenposition-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_tokenposition","text":"parse_tokenposition(\n    node,\n    pntd\n) -> PNML.PnmlGraphics.Coordinate{Float32}\n\n\nReturn Cartesian Coordinate relative to containing element.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_toolspecific-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.parse_toolspecific","text":"parse_toolspecific(node, pntd) -> PNML.ToolInfo\n\n\nReturn ToolInfo with tool & version attributes and content.\n\nThe content can be one or more well-formed xml elements. Each are wrapped in a PnmlLabel.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_transition!-NTuple{4, Any}","page":"Docstrings","title":"PNML.Parser.parse_transition!","text":"Fill transitionset, transitiondict.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_transition-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_transition","text":"parse_transition(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> Transition{<:PNML.PnmlTypeDefs.PnmlType, PNML.Labels.Condition}\n\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_type-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_type","text":"parse_type(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> PNML.Labels.SortType\n\n\nLabel that defines the \"sort\" of tokens held by the place and semantics of the marking. NB: The \"type\" of a place from many-sorted algebra is different from the Petri Net \"type\" of a net or \"pntd\". Neither is directly a julia type.\n\nAllow all pntd's places to have a <type> label.  Non high-level are expecting a numeric sort: eltype(sort) <: Number.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_unknowndecl-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_unknowndecl","text":"parse_unknowndecl(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> PNML.Declarations.UnknownDeclaration\n\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_usersort-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_usersort","text":"parse_usersort(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> UserSort\n\n\nReturns UserSort wraping the REFID of a NamedSort or AbstractSort.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.parse_variabledecl-Tuple{EzXML.Node, PNML.PnmlTypeDefs.PnmlType}","page":"Docstrings","title":"PNML.Parser.parse_variabledecl","text":"parse_variabledecl(\n    node::EzXML.Node,\n    pntd::PNML.PnmlTypeDefs.PnmlType\n) -> PNML.Declarations.VariableDeclaration\n\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.pnml_namespace-Tuple{EzXML.Node}","page":"Docstrings","title":"PNML.Parser.pnml_namespace","text":"pnml_namespace(\n    node::EzXML.Node;\n    missing_ns_fatal,\n    default_ns\n) -> String\n\n\nReturn namespace. When node does not have a namespace return default value pnml_ns and warn or throw an error.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.register_idof!-Tuple{PNML.PnmlIDRegistrys.PnmlIDRegistry, EzXML.Node}","page":"Docstrings","title":"PNML.Parser.register_idof!","text":"register_idof!(\n    registry::PNML.PnmlIDRegistrys.PnmlIDRegistry,\n    node::EzXML.Node\n) -> Symbol\n\n\nReturn registered symbol from id attribute of node. See PnmlIDRegistry.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.registry-Tuple{}","page":"Docstrings","title":"PNML.Parser.registry","text":"registry() -> PnmlIDRegistry\n\nConstruct an empty PNML ID registry using a ReentrantLock.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.subterms-Tuple{Any, Any}","page":"Docstrings","title":"PNML.Parser.subterms","text":"subterms(node, pntd; vars) -> Vector{PnmlExpr}\n\nUnwrap each <subterm> and parse into a PnmlExpr term. Collect variable REFIDs in vars.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.unparsed_tag-Tuple{EzXML.Node}","page":"Docstrings","title":"PNML.Parser.unparsed_tag","text":"unparsed_tag(node::EzXML.Node) -> Tuple{String, Any}\n\n\nReturn tuple of (tag, XDVT) holding well formed XML tree. XMLDict\n\nThe main use-case is to be wrapped in a PnmlLabel, AnyElement, or PNML.Labels.Structure.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.unwrap_subterm-Tuple{EzXML.Node}","page":"Docstrings","title":"PNML.Parser.unwrap_subterm","text":"unwrap_subterm(st::XMLNode) -> XMLNode, Symbol\n\nUnwrap a <subterm> by returning tuple of child node and child's tag.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.xmlroot-Tuple{AbstractString}","page":"Docstrings","title":"PNML.Parser.xmlroot","text":"xmlroot(s::AbstractString) -> EzXML.Node\n\n\nParse string s into EzXML node.\n\n\n\n\n\n","category":"method"},{"location":"library/#PNML.Parser.@xml_str-Tuple{Any}","page":"Docstrings","title":"PNML.Parser.@xml_str","text":"Parse string into EzXML node.\n\nSee xmlroot.\n\n\n\n\n\n","category":"macro"},{"location":"traits/","page":"Traits","title":"Traits","text":"CurrentModule = PNML","category":"page"},{"location":"traits/#Traits","page":"Traits","title":"Traits","text":"","category":"section"},{"location":"traits/","page":"Traits","title":"Traits","text":"Some of the traits used are based on the pntd. Each supported pntd has a singleton subtype of PnmlType.","category":"page"},{"location":"traits/","page":"Traits","title":"Traits","text":"3 branches of pntd based on number system","category":"page"},{"location":"traits/","page":"Traits","title":"Traits","text":"core uses integers\nhigh-level uses terms of many-sorted algebra\ncontinuous/hybrid uses floating point","category":"page"},{"location":"traits/","page":"Traits","title":"Traits","text":"Default place markings and arc inscriptions are different for the three.","category":"page"},{"location":"traits/","page":"Traits","title":"Traits","text":"using  PNML, InteractiveUtils, Markdown\nlist_type(f) = for pntd in values(PNML.PnmlTypeDefs.pnmltype_map)\n    println(rpad(pntd, 15), \" -> \", f(pntd))\nend","category":"page"},{"location":"traits/#isdiscrete","page":"Traits","title":"isdiscrete","text":"","category":"section"},{"location":"traits/","page":"Traits","title":"Traits","text":"list_type(PNML.isdiscrete)","category":"page"},{"location":"traits/#iscontinuous","page":"Traits","title":"iscontinuous","text":"","category":"section"},{"location":"traits/","page":"Traits","title":"Traits","text":"list_type(PNML.iscontinuous)","category":"page"},{"location":"traits/#ishighlevel","page":"Traits","title":"ishighlevel","text":"","category":"section"},{"location":"traits/","page":"Traits","title":"Traits","text":"list_type(PNML.ishighlevel)","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"CurrentModule = PNML","category":"page"},{"location":"pnml/#PNML.jl","page":"Petri Net Markup Language","title":"PNML.jl","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Documentation for the GitHub PNML.jl repository. Which defines a Julia module named PNML. Which handles an XML markup language with the acronym 'PNML' – Petri Net Markup Language.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"using Markdown, Pkg, Dates, InteractiveUtils\n\nfunction print_dep_version(depname)\n\tdeps = values(Pkg.dependencies())\n\tversion = first(d for d in deps if d.name == depname).version\n\t\"$depname: v$version\"\nend\n\nMarkdown.parse(\"\"\"\n\tThese docs were generated at $(now()) on $(gethostname()) using:\n\t\t- $(print_dep_version(\"PNML\"))\n   \"\"\")","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"using InteractiveUtils; # hide\nversioninfo()","category":"page"},{"location":"pnml/#www.pnml.org","page":"Petri Net Markup Language","title":"www.pnml.org","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"In this section 'PNML' refers to the markup language, its specification and schemas, not this software.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"http://www.pnml.org","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"has publications and tutorials covering PNML at various points in its evolution.\nhas links to a series of ISO/IEC 15909 standards relating to PNML.\nis the cannonical site for the meta-models, RELAX-NG XML schemas that define the grammar of several Petri Net Type Defintions (pntd), including:","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"  - PT Net (Place/Transition Net)\n  - Symmetric Net","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"and more: examples, meta-models in EMF, java-based framework","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"There are 2 flavors currently covered by PNML meta-models:","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"integer-valued, where tokens have collective identities.\nHigh-level, where tokens have individual identities using a many-sorted algebra.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"TODO cite J. Baez.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"The people behind PNML, and as stated in 15909-2, are of the Model Driven Software Engineering camp and have chosen Java, Eclipse and its modeling framework (EMF).","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"See A primer on the Petri Net Markup Language and ISO/IEC 15909-2(pdf) for more details. The rest of this page will hopefully make more sense if you are familiar with the primer's contents. Use the RelaxNG Schema as definitive like the 'primer' counsels.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Note that the pnml XML file is the working intermediate representation of a suite of tools that use RelaxNG and Schematron for validation of the interchange file's content.","category":"page"},{"location":"pnml/#Interoperability","page":"Petri Net Markup Language","title":"Interoperability","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Petri Net Type Definition schema files (pntd) are defined using RELAX-NG XML Schema files (rng). Petri Net Markup Language files (pnml) are intended to be validated against a pntd schema.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"For interchange of pnml between tools it should be enough to support the same pntd schema.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Note that ISO released part 3 of the PNML standard covering extensions and structuring mechanisms in 2021. And some http://www.pnml.org files address these extensions.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"It is possible to create a non-standard pntd. And more will be standardized, either formally or informally. Non-standard mostly means that the interchangibility is restricted.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Since validation is not a goal of PNML.jl, non-standard pntds can be used for the URI of an XML net tag's type attribute. Notably pnmlcore and nonstandard are mapped to PnmlCoreNet.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"PnmlCoreNet is the minimum level of meaning that any pnml file can hold. PNML.jl should be able to create a valid intermediate representation using PnmlCoreNet since all the higher-level meaning is expressed as pnml labels, restrictions, and required XML tag names.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Further parsing of labels is specialized upon subtypes of PNML.AbstractPetriNet. See Traits for more details.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"If you want interchangability of pnml models, you will have to stick to the standard pnml pntds. The High Level Petri Net, even when restricted to symmetricnet.pntd, is very expressive. Even the base pnmlcore.pntd is useful.","category":"page"},{"location":"pnml/#Why-no-Schema-Verification","page":"Petri Net Markup Language","title":"Why no Schema Verification","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Within PNML.jl no schema-level validation is done.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Note that, depending on context, 'PNML' may refer to either the markup language or the Julia code in the following.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"In is allowed by the PNML specification to omit validation with the presumption that some specialized, external tool can be applied, thus allowing the file format to be used for inter-tool communication with lower overhead in each tool.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Also omiting pntd validation allows \"duck typing\" of Petri Nets built upon the PNML intermediate representration.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Of some note it that PNML.jl extends PNML. These, non-standard pntd do not (yet) have a schema written. See ContinuousNet.","category":"page"},{"location":"pnml/#PNTD-Maps","page":"Petri Net Markup Language","title":"PNTD Maps","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Defaut PNTD to Symbol map (URI string to pntd symbol):","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"using PNML; foreach(println, sort(collect(pairs(PNML.PnmlTypeDefs.default_pntd_map)))) #hide","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"PnmlType map (pntd symbol to singleton):","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"using PNML; foreach(println, pairs(PNML.PnmlTypeDefs.pnmltype_map)) #hide","category":"page"},{"location":"pnml/#Handling-Labels","page":"Petri Net Markup Language","title":"Handling Labels","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"The implementation of Labels supports annotation and attribute format labels.","category":"page"},{"location":"pnml/#Annotation-Labels","page":"Petri Net Markup Language","title":"Annotation Labels","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"annotation format labels are expected to have either a <text> element, a <structure> element or both. Often the <text> is a human-readable representation of of the <structure> element. Graphics and ToolInfo elements may be present.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"For PTNet (and pnmlcore) only the Name label with a <text> element (and no <structure> element) is defined by the specification.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Labels defined in High-Level pntds, specifically 'Symmetric Nets', \"require\" all meaning to reside in the <structure>.","category":"page"},{"location":"pnml/#Attribute-Labels","page":"Petri Net Markup Language","title":"Attribute Labels","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"attribute format labels are present in the UML model of pnml. They differ from annotation by omitting the Graphics element, but retain the ToolInfo element. Unless an optimization is identified, both attribute and annotation will share the same implementation.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"A standard-conforming pnml model would not have any Graphics element so that field would be nothing.","category":"page"},{"location":"pnml/#High-level-Petri-Net-Concepts","page":"Petri Net Markup Language","title":"High-level Petri Net Concepts","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Based on a draft version of ISO/IEC 15909-1:2004 High-level Petri nets - Part 1: Concepts, definitions and graphical notation.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Useful for setting the ontology.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Arc inscriptions are expressions that are evaluated.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Place markings are multisets of tokens of a sort/type.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Transition conditions are boolean expressions that are evaluated. Used to determine if transition is enabled.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Expressions in pnml can be many-sorted algebras. Declaration, Term, Sort, Multiset, Variable, are among the concepts used to define expressions.","category":"page"},{"location":"pnml/#Terms","page":"Petri Net Markup Language","title":"Terms","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Terms have sorts: the sort of the variable or the output sort of the operator.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Terms can be buit from built-in operators and sorts, and user-defined variables. These are defined in variable declarations, a kind of annotation label attached to pages and nets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"A transition can have a condition, a term of sort boolean, which imposes restrictions on when the transition may fire.","category":"page"},{"location":"pnml/#Sorts","page":"Petri Net Markup Language","title":"Sorts","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"named sorts are constructed from existing sorts and given a new name.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"arbitrary sort is not defined in core, is not allowed in Symmetric Nets. HLPNG adds arbitrary declarations, sorts of lists, strings, integers to Symmetric Nets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"The sort of a term is the sort of the variable or the output sort of the operator.","category":"page"},{"location":"pnml/#Operators","page":"Petri Net Markup Language","title":"Operators","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"An operator can be: built-in constant, built-in operator, multiset operator or tuple operator.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"User-defined operators, or named operators are abbreviations, built from existing operators and parameter variables.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"There will be arbitrary operator declarations for High-Level Petri Net Graphs, but not for Symmetric Nets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Operators have a sequence of input sorts and a single output sort.","category":"page"},{"location":"pnml/#Variables","page":"Petri Net Markup Language","title":"Variables","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"TBD","category":"page"},{"location":"pnml/#Notes-on-Petri-Nets","page":"Petri Net Markup Language","title":"Notes on Petri Nets","text":"","category":"section"},{"location":"pnml/#Multiset-Rewriting-Systems","page":"Petri Net Markup Language","title":"Multiset Rewriting Systems","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"I. Cervesato: Petri Nets as Multiset Rewriting Systems in a Linear Framework","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"This addresses Place Transition Nets. High-level Petri nets explictily use multisets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"factor out the multiplicity of the elements of the underlying set. This is achieved by first defining the notion of singleton multisets and then by writing arbitrary multisets as linear combination of singleton multisets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"a rewrite rule can be viewed as a singleton multiset","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Petri nets are meant to represent evolving systems. To represent this dynamic flavor, we will rely on the notion of multiset rewriting systems.","category":"page"},{"location":"pnml/#Continuous,-Open-and-Other-Petri-Nets","page":"Petri Net Markup Language","title":"Continuous, Open and Other Petri Nets","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Allow marking, inscription, conditions to be floating point even when specification wants an integer. This allows continuous nets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"See Petri.jl and AlgebraicPetri.jl for some continuous Petri Net use-cases.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"TODO: Hybrid nets combining floating point/continuous and integer/discrete inscription/marking.","category":"page"},{"location":"pnml/#References","page":"Petri Net Markup Language","title":"References","text":"","category":"section"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"www.pnml.org","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"L.M. Hillah and E. Kindler and F. Kordon and L. Petrucci and N. Trèves: A primer on the Petri Net Markup Language and ISO/IEC 15909-2 Petri Net Newsletter 76:9–28, October 2009 (originally presented at the 10th International workshop on Practical Use of Colored Petri Nets and the CPN Tools – CPN'09).","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"ISO High-level Petri nets Specification in multiple parts:","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"ISO/IEC 15909-1:2019 — Part 1: Concepts, definitions and graphical notation\nISO/IEC 15909-2:2011 — Part 2: Transfer format\nISO/IEC 15909-2:2011/Cor 1:2013 — Part 2: Transfer format — TECHNICAL CORRIGENDUM 1\nISO/IEC 15909-3:2021 — Part 3: Extensions and structuring mechanisms","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Well-formed Petri nets \"...only a limited set of operators are available (identify, broadcast, successor and predecessor functions are allowed on circular finite types)\". Restrictions that differentiates SymmetricNet and HLPNG.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"PNML Framework \"... a free and open-source prototype implementation of ISO/IEC-15909, International Standard on Petri Nets\". The framework is an Eclipse/Java construction using Eclipse Public License 1.0. Uses Model-Driven Engineering to provide generated APIs.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"github.com/lip6/pnmlframework hosts the source code of PNML Framework. See apidocs and XMLTestFilesRepository.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"github.com/loig/pinimili Go language.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"github.com/stackdump/gopetri Go language.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"github.com/daemontus/pnml-parser Rust language.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Browsable PNML Grammar from Grammar Zoo  For Symmetric Nets.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"nLab multisorted algebraic theories","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"Automated Code Optimization with E-Graphs: Alessandro Cheli's Thesis on Metatheory.jl.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"ePNK a platform for developing Petri net tools based on the PNML transfer format is another Eclipse/Java EMF thing. Implements more complicated PNML than used in MCC. By authors of PNML. github has the source, documentation, examples.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"\"The Model Checking Contest (MCC) has two different parts: the Call for Models, which gathers Petri net models proposed by the scientific community, and the Call for Tools, which benchmarks verification tools developed within the scientific community.\" Each year new models are added to the contest.","category":"page"},{"location":"pnml/","page":"Petri Net Markup Language","title":"Petri Net Markup Language","text":"\"Petri net model using AlgebraicPetri.jl Micah Halter, 2021-03-26\"","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"CurrentModule = PNML","category":"page"},{"location":"parser/#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"parser/#Unclaimed-Labels","page":"Parser","title":"Unclaimed Labels","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"XML tags that are not 'claimed' are recursively parsed into a DictType by unparsed_tag.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"See AnyElement, PNML.Parser.anyelement, PnmlLabel","category":"page"},{"location":"parser/#AnyElement","page":"Parser","title":"AnyElement","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"Main use case if for ToolInfo content. The specification allows any well-formed XML. Only the intended tool needs to understand the content.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"TODO Implement a ToolInfo for PNML.jl extensions.","category":"page"},{"location":"parser/#PnmlLabel","page":"Parser","title":"PnmlLabel","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"Applies label semantics to a DictType. Used for not-yet-implemented labels. Many of the labels used for high-level many-sorted algebra have not been implemented.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"See rate for a use case.","category":"page"},{"location":"parser/#Sorts","page":"Parser","title":"Sorts","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"Figure 11 of the primer lists built-in sorts and functions for Symmetric Nets, a restricted High-Level Petri Net Graph. See PnmlTypeDefs, PnmlTypeDefs.HLPNG and AbstractHLCore","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Some of the restrictions:","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Declarations.ArbitrarySort and 'Unparsed' not allowed.\ncarrier sets of all basic (is this built-in?) sorts are finite\nsorttype of a place must not be a multiset sort (but multiset is in the UML diagram)","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"What HLPNG adds:","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"declarations for sorts and functions\nArbitraryDeclarations: ArbitrarySort, ArbitraryOperator, Unparsed\nIntegers\nStrings\nLists","category":"page"},{"location":"parser/#Structure-of-High-level-Annotation","page":"Parser","title":"Structure of High-level Annotation","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"Schematic of annotation label:","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"text\nstructure\nTerm\nsubterm\nTerm (its alternating subterm Term all the way down)\ntoolspecific\ngraphics","category":"page"},{"location":"parser/#Enabling-and-Firing","page":"Parser","title":"Enabling and Firing","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"See discussions on PnmlTuple, ProductSorts and variables.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"This is a discussion of ENABLING rule","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"c::Condition is attached to  t::Transition.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"preset(net, pid(t)) ∪ postset(net, pid(t)) are the attached arcs.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"arc inscription expressions have variable arguments as do conditions.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"vars are ordered collections in standard! It uses Abstract Math and UML2 to say so. As they are the arguments to operators (expressions with variables), they need to be consistent.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"0-ary operators are constants and literals (as ground terms without variables). Rewriting may? optimize/minimize these terms.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"There will be inscriptions in preset(t) that are ground terms (constant or literal). Use in postset is the obvious case: generate token. A preset ground term inscription will not have a variable and use a multiplicity = 1. Value will be of the marking basis sort (like all inscriptions). The inscription is enabled if multiset[value] > 0, and value is removed on firing. This is the same behavior as for PTNets that use integer-valued markings and inscriptions.","category":"page"},{"location":"parser/#binding-value-set","page":"Parser","title":"binding value set","text":"","category":"section"},{"location":"parser/","page":"Parser","title":"Parser","text":"Collection of subsitution dictionaries created from binding value sets of all incriptions by selecting one from each set. length(1st set) * length(2nd set) * ... length(nth set)","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Condition     Each dictionary is one substitution for every variable     Dict(REFID => value in bindingvalueset(REFID))","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"sub = Dict{REFID,Ref{SORT}}()\n\nRef{SORT}(multiset element) || Ref{SORT}(multiset element, tuple index)\n    REFID may be repeated\n        multiple of same var in an inscrition <= multplicity of a value in marking multiset\n    &/or\n        same var in multiple inscriptions all with same value\n\nfor each substituion tuple element\n    sub(varid) maps the variable to a value\n    Used in evaluating (c::Condition)() to filter the substituion collection\n\nfor each preset(t) inscription\n    bindings to marking values that satisfy the inscription.\n    Only continue if all constraints are met, else return `false`.\n    if var already has a binding only consider those values\n        remove values from binding that do not satisfy this inscription\n        value must be present in each marking of sufficent multiplicity\n    #todo recursivly re-evaluate after each add?","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"PnmlTuple that are ProductSort elements and julia Tuple are not the same. ^ The vars tuple may contain elements of a PnmlTuple. Use marking basis to decide.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"variables are how an element of marking multiset is identified/assessed.  for each preset(t)","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"each element of each marking multiset is bound to the variable or variables  -> tuple of bindings\nenabling rule returning true for a tuple of bindings adds tuple to enabled transition modes.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Generate JIT compiled code that uses REFID to update the VariableDeclaration  with arg reference information then applies/evaluates expression using the value.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"? Each arg in iteratable ordered collection args is bound as the value of a ? pnml variable that appears within the expression tree rooted at term?","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Varible in tree is a REFID to a VariableDeclaration that has the name and sort.  args are pairs of name (or REFID) and reference to marking value.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Reference to marking value is only read here as part of enabling function.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Make a copy of expression? Just during bring-up to verify same behavior & debug.  Simplify the expression by rewriting once (not each use).  The optimized expression still has variables at this point that are REFIDs.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"preset variables are a superset of postset variables.  Every postset variable is also a preset variable.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Variable v is bound to preset marking value (element of a multiset)","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"as tuple of place REFID index into marking_vector, and a mutiset element.\nbv_sets is a vector of variable binding value sets, one for each variable\nuse multipicity(multiset, element) >= length(v in variables(inscription(arc))) to test enabled state of binding to an element\nbuild a binding value set (bvs) of those element bindings that are enabled\neach arc shares a bvs in bv_sets for each variable in variables(inscription(arc))\ntrvars records variables in transaction. There is a bvsets for each REFID in tv_vars\none or more of the bvs members is selected for a firing\n","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Use variable to remove element (decrease multiplicity) from preset, add element to postset.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"foreach preset(t) arc inscription vars tuple    enabling rule iterates matches for variable sort in marking multiset    testing each binding combination in condition functor.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Will iterate over each preset(t) marking's multiset elements.  There will be (must be) a variable for each sort in the multiset basis.  PnmlTuples are unpacked into multiple variables.","category":"page"},{"location":"parser/","page":"Parser","title":"Parser","text":"Variables that appear in more than one preset(t) marking basis  must have the same value in each marking to be enabled","category":"page"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"CurrentModule = PNML","category":"page"},{"location":"evaluate/#Evaluate-possible-functors","page":"Evaluate","title":"Evaluate possible functors","text":"","category":"section"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"Things that are functors:","category":"page"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"Marking: return marking_value_type\nInscription: return inscription_value_type\nCondition: return condition_value_type\nTerm: return a sort's value type TBD","category":"page"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"using AbstractTrees, PNML, InteractiveUtils, Markdown","category":"page"},{"location":"evaluate/#Examples","page":"Evaluate","title":"Examples","text":"","category":"section"},{"location":"evaluate/#XMLDict-format-Terms","page":"Evaluate","title":"XMLDict format Terms","text":"","category":"section"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"XMLDict.jl","category":"page"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"XMLDict implements an Associative interface (get(), getindex(), haskey()) for reading XML elements and attributes.","category":"page"},{"location":"evaluate/#Operator-that-constructs-a-multiset-of-sort-dot.","page":"Evaluate","title":"Operator that constructs a multiset of sort dot.","text":"","category":"section"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"A marking is a multiset of a place's sorttype. The output sort of the operator must be of this sort (equatSorts is true and sortof(place) == sortof(marking)).","category":"page"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"The output sort of numberof is the sort of the element in 2nd subterm.","category":"page"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"positive and dotconstant are builtin-constants.","category":"page"},{"location":"evaluate/#Tuple","page":"Evaluate","title":"Tuple","text":"","category":"section"},{"location":"evaluate/#Add-multisets","page":"Evaluate","title":"Add multisets","text":"","category":"section"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"<hlinitialMarking>\n    <text>1`3 ++ 1`2</text>\n    <structure>\n        <add>\n            <subterm>\n                <numberof>\n                <subterm><numberconstant value=\\\"1\\\"><positive/></numberconstant></subterm>\n                <subterm><numberconstant value=\\\"3\\\"><positive/></numberconstant></subterm>\n                </numberof>\n            </subterm>\n            <subterm>\n                <numberof>\n                <subterm><numberconstant value=\\\"1\\\"><positive/></numberconstant></subterm>\n                <subterm><numberconstant value=\\\"2\\\"><positive/></numberconstant></subterm>\n                </numberof>\n            </subterm>\n        </add>\n    </structure>\n</hlinitialMarking>","category":"page"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"Constructs an expression that adds 2 multisets. When all multiplicities are 1 and sortof subterm has an eltype the usual math applies. Output sort needs to match eltype of operation result.","category":"page"},{"location":"evaluate/","page":"Evaluate","title":"Evaluate","text":"1`3 + 1`2 = 3 + 2 = 5\n2`3 + 1`2 = 3 + 3 + 2 = 8","category":"page"},{"location":"evaluate/#Zero","page":"Evaluate","title":"Zero","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = PNML","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 5","category":"page"},{"location":"examples/#Lotka-Volterra","page":"Examples","title":"Lotka-Volterra","text":"","category":"section"},{"location":"examples/#Petri.jl-Starting-Point","page":"Examples","title":"Petri.jl Starting Point","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"https://github.com/mehalter/Petri.jl","category":"page"},{"location":"examples/#Example-2","page":"Examples","title":"Example 2","text":"","category":"section"},{"location":"examples/#Stuff-for-example-2","page":"Examples","title":"Stuff for example 2","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"CurrentModule = PNML","category":"page"},{"location":"layers/#Layers-of-Abstraction","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"note: Graphics are elided from this discussion\nEverywhere there are ToolInfos in this discussion one may assume that there is also an optional Graphics possible.While we parse such XML into \"containers of strings\" and Coordinates. No further use is implemented or planned. And no discussion of use is present.","category":"page"},{"location":"layers/#Intermediate-Representation","page":"Layers of Abstraction","title":"Intermediate Representation","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"The intermediate representation (IR) is between the XML model and a \"usable\" network. Many different flavors of Petri Nets are expected to be implemented using the IR.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"The IR is constructed by traversing the XML and using tag names as dictonary keys.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"In the first part of parsing, a named tuple is filled with appropriate initial values for each xml tag. Then optional child keys have values bound as they are parsed.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"The second part of parsing instantiates objects using the named tuple as input.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"The structure of the IR follows the tree structure of a well-formed XML document and the PNML specification.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"XML attribute names and child element tag names are used for keys of the same dictonary. The pnml specification/schemas do not use colliding names. However, the <toolspecific> tag's content is not required to be valid pnml, just well-formed XML. We assume nobody would use colliding names intentionally.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"The crude structure required by the pnmlcore schema: PnmlModel","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"Net\nPage\n- Places, Marking\n- Transitions, Condition\n- Arcs, Inscription\n- Toolinfos\n- Labels\n- Subpages\nName","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"- Toolinfos\n- Labels","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"The IR is implemented under the assumption the the input pnml file is valid. All tags are assumed to be meaningful to the resulting network. The pnmlcore schema requires undefined tags will be considered pnml labels. The IR is capable of handling arbitrary labels. Many label tags from higherlevel pnml schemas are recognized by the IR parsers.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"While the Petri Net Type Definition (pntd) is present in every valid net, it was not necessary to consult the type during creation of the IR. It is expected that conforming to pntd will be done at a higher level.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"Some parts of pnml are complicated. Not yet completed bits may be implemented as wrappers holdind unparsed XML. In fact, parts of pnml are specified as holding any well-formed XML.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"The crude structure required by the pnmlcore schema: PnmlModel","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"Net\nPages\nPlaces, Marking, unclaimed labels  [SortType] [Capacity]\nTransitions, Condition, unclaimed labels [rate]\nArcs, Inscription, unclaimed labels [ArcType]\nToolinfos [TokenGraphics]\nLabels unclaimed, [Declaration]\nSubpages\nName (everybody has name)\nToolinfos\nLabels","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"It is expected that conforming to pntd will be done at a higher level.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"Level Sorts \nCore Bool, Int \nPT Bool, Int \nContinuous Bool, Float64 \nHybrid Bool, Int, Float64 \nhigh-level Bool, Int, Term \nSymmetric Bool, Int, Term \nPTHLPNG Bool, Int, Term ","category":"page"},{"location":"layers/#Core-Layer","page":"Layers of Abstraction","title":"Core Layer","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"What is permitted by the specification in a XML file will be a subset of the implementation.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"Concepts from High-Level Petri Nets will be used in the Core layer.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"PNTD Sort value \nPnmlType Int \nAbstractContinuousNet Float64 \nAbstractHLCore DotConstant()) ","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"Use Union{Bool, Int, Float64, DictType} as the set of types that a Term's can contain. Consider Bool, Int, Float64 as builtin-sorts, and DictType as \"user defined\" sorts.","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"using  PNML, InteractiveUtils, Markdown\nlist_type(f) = for pntd in values(PNML.PnmlTypeDefs.pnmltype_map)\n    println(rpad(pntd, 15), \" -> \", f(pntd))\nend\n","category":"page"},{"location":"layers/#Type-Lookup-Layers","page":"Layers of Abstraction","title":"Type Lookup Layers","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"Petri Net Graph Object Types are parameterized by Label Types. What labels are \"allowed\" (syntax vs. semantics vs. schema vs. specification) is parameterized on the PNTD (Petri Net Type Definition).","category":"page"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"See PnmlNets & AbstractPnmlObjects","category":"page"},{"location":"layers/#pnmltype_map","page":"Layers of Abstraction","title":"pnmltype_map","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"pnmltype_map","category":"page"},{"location":"layers/#PNML.PnmlTypeDefs.pnmltype_map-layers","page":"Layers of Abstraction","title":"PNML.PnmlTypeDefs.pnmltype_map","text":"The key Symbols are the supported kinds of Petri Nets. Maps to singletons.\n\n\n\n\n\n","category":"constant"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"using PNML # hide\nPNML.PnmlTypeDefs.pnmltype_map","category":"page"},{"location":"layers/#pnmlnet_type","page":"Layers of Abstraction","title":"pnmlnet_type","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"pnmlnet_type","category":"page"},{"location":"layers/#PNML.pnmlnet_type-layers","page":"Layers of Abstraction","title":"PNML.pnmlnet_type","text":"\n\n\n\n","category":"function"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"list_type(PNML.pnmlnet_type) # hide","category":"page"},{"location":"layers/#page_type","page":"Layers of Abstraction","title":"page_type","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"list_type(PNML.page_type) # hide","category":"page"},{"location":"layers/#place_type","page":"Layers of Abstraction","title":"place_type","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"list_type(PNML.place_type) # hide","category":"page"},{"location":"layers/#transition_type","page":"Layers of Abstraction","title":"transition_type","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"list_type(PNML.transition_type) # hide","category":"page"},{"location":"layers/#arc_type","page":"Layers of Abstraction","title":"arc_type","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"list_type(PNML.arc_type) # hide","category":"page"},{"location":"layers/#Label-Types","page":"Layers of Abstraction","title":"Label Types","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"AbstractLabels are parameterized by Value Types.","category":"page"},{"location":"layers/#marking_type","page":"Layers of Abstraction","title":"marking_type","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"list_type(PNML.marking_type) # hide","category":"page"},{"location":"layers/#condition_type","page":"Layers of Abstraction","title":"condition_type","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"list_type(PNML.condition_type) # hide","category":"page"},{"location":"layers/#inscription_type","page":"Layers of Abstraction","title":"inscription_type","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"list_type(PNML.inscription_type) # hide","category":"page"},{"location":"layers/#refplace_type","page":"Layers of Abstraction","title":"refplace_type","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"list_type(PNML.refplace_type) # hide","category":"page"},{"location":"layers/#reftransition_type","page":"Layers of Abstraction","title":"reftransition_type","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"list_type(PNML.reftransition_type) # hide","category":"page"},{"location":"layers/#Value-Types","page":"Layers of Abstraction","title":"Value Types","text":"","category":"section"},{"location":"layers/","page":"Layers of Abstraction","title":"Layers of Abstraction","text":"TBD","category":"page"},{"location":"mathematics/#Mathematical-Semantics","page":"Math","title":"Mathematical Semantics","text":"","category":"section"},{"location":"mathematics/","page":"Math","title":"Math","text":"ISO High-level Petri nets Specification  parts 1 and 3 describe the sematics using math notation and part 2 provides the syntax using XML, UML2 and RelaxNG Schema.","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"Here we pick out bits for exposition.  Recommend using the specification for completeness.","category":"page"},{"location":"mathematics/#Color-Functions","page":"Math","title":"Color Functions","text":"","category":"section"},{"location":"mathematics/","page":"Math","title":"Math","text":"In symmetric nets, arcs are labelled by color functions which select tokens in adjacent places depending on the instantiation performed for the firing.","category":"page"},{"location":"mathematics/#Basic-Color-Functions","page":"Math","title":"Basic Color Functions","text":"","category":"section"},{"location":"mathematics/","page":"Math","title":"Math","text":"In Part 1 refer to Concept 15 (symmetric finite cartesian net) and Concept 16 (basic color functions)","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"Let C be a non-empty finite set.  A non-empty finite color class C_i defines a type over C. Part 2 calls this a Sort.","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"A color domain is a finite cartesian product of color classes: D = prod_i=1^n C_i.  Part 2 calls this a ProductSort.","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"Let C_i be a color class and D = C_1^e_1 times  times C_k^e_k a color domain.","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"General color function: C(transition) -> Bag(C(place)), where C is a mapping (not a finite set as before).","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"Color functions from D to  Bag(C_i) for multiset c = langle c_1^1   c_1^e_1  c_k^1  c_k^e_k rangle:","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"projections that select one component of a color","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"X_C_i^j(c) = c_i^j forall j  1 leq j leq e_j","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"successor functions that select the successor of a component of a color","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"X_C_i^j(c)++ the successor of c_i^j in C_i forall j  1 leq j leq e_j","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"\"global\" selections that map any color to the \"sum\" of colors","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"C_iall(c) = sum_c in C_ix and C_iqall(c) = sum_c in C_ix","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"sumx in Part 1 is A.5.3.3 Notation 5 (bag notation, equivalence with the supporting set).","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"C_iq seems to refer to what Part 2 calls a Partition. Where C_i = uplus_q=1s_i C_iq is a color class that is partitioned into s_i static subclasses.","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"Concept 17 (class color functions)","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"f_C_i = sum_k=1e_i alpha_ik cdot langle X_C_i^k rangle +\nsum_q=1s_i beta_iq cdot langle C_iqall rangle +\nsum_k=1e_i gamma_ik cdot langle X_i^k++ rangle","category":"page"},{"location":"mathematics/","page":"Math","title":"Math","text":"such that forall d in D forall c in C_i f_C_i(d)(c) geq 0, where constrants on alpha_ik beta_iq gamma_ik are defined to ensure f_C_i(d)(d)  0  forall c in C_i","category":"page"},{"location":"#PNML-has-High-Level","page":"Index","title":"PNML has High Level","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [PNML, PNML.PnmlTypeDefs, PNML.PnmlIDRegistrys, PNML.Sorts, PNML.Declarations, PNML.PnmlGraphics, PNML.Labels, PNML.Parser]","category":"page"},{"location":"subpackages/#Sub-packages-of-PNML","page":"Sub-packages of PNML","title":"Sub-packages of PNML","text":"","category":"section"}]
}

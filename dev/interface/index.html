<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interfaces · PNML.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://strangehurst.github.io/PNML.jl/interface/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../pnml/">PNML.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../pnml/">Petri Net Markup Language</a></li><li><a class="tocitem" href="../IR/">Intermediate Representation</a></li><li class="is-active"><a class="tocitem" href>Interfaces</a><ul class="internal"><li><a class="tocitem" href="#PnmlType-traits"><span>PnmlType traits</span></a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../API/library/">PNML</a></li><li><a class="tocitem" href="../API/pnmltypes/">PnmlTypes</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../">Index</a></li><li><a class="tocitem" href="../acknowledgments/">Acknowledgments</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interfaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interfaces</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/strangehurst/PNML.jl/blob/master/docs/src/interface.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>f```@meta CurrentModule = PNML</p><pre><code class="nohighlight hljs"></code></pre><p>@contents Pages = [&quot;interface.md&quot;] Depth = 5</p><pre><code class="nohighlight hljs"># Interface

The intermediate representation is used to implement networks
expressed in a pnml model. The consumer of the IR is a network,
most naturally a varity of Petri Net.

High-Level Petri Net Graphs (HLPNG) can be expressed in a pnml model.

[`PnmlDict`](@ref) is an alias for `Dict{Symbol,Any}`.
Each XML tag is first parsed into a `PnmlDict`, many are then used
to create higher-level types. Some parts will continue to find
use for `PnmlDict`&#39;s flexibility.

[`AnyElement`](@ref) wraps a `PnmlDict` and `XMLNode`.

We start a description of the net IR here.

## Type Hierarchies

Overview of some type hiearchies.
</code></pre><p>@setup type using AbstractTrees, PNML, InteractiveUtils, Markdown #, GraphRecipes,Plots</p><p>AbstractTrees.children(x::Type) = subtypes(x)</p><p>typet = [ AbstractTrees.repr<em>tree(PNML.PnmlObject) AbstractTrees.repr</em>tree(PNML.AbstractLabel) AbstractTrees.repr<em>tree(PNML.AbstractPnmlTool) AbstractTrees.repr</em>tree(PNML.PnmlException) AbstractTrees.repr<em>tree(PNML.AbstractSort) AbstractTrees.repr</em>tree(PNML.AbstractTerm) ]</p><pre><code class="nohighlight hljs">### PnmlType - Petri Net Type Definition
See [PnmlTypes](@ref) module page.

There are levels:  Core (Place-Transition), Continuous and High-Level PNG.

[`PnmlCore`](@ref) is a concrete subtype of [`PnmlType`](@ref).
`PnmlCore` is used by some `PetriNet` concrete types ([`SimpleNet`](@ref)).

[`ContinuousNet`](@ref) uses floating point marking and inscriptions.
It is an extension to the ISO specification.

[`HLCore`](@ref) is a concrete subtype of [`AbstractHLCore`](@ref).
`HLCore` is used by some `PetriNet` concrete types ([`HLPetriNet`](@ref)).
Think of it as a testable implementation of `AbstractHLCore`.

The IR does not try to impose semantics on the model. Those semantics should
be part of [`PetriNet`](@ref).  The IR tries to represent the model (all models)
at a structural level. It may paramertize types to facilitate specilaization.
</code></pre><p>@example type println(AbstractTrees.repr_tree(PNML.PnmlTypes.PnmlType)) # hide</p><pre><code class="nohighlight hljs">
| PnmlType     | Place | Trans | Arc  | Description                                               |
| :---------   | :---- | :---- | :--- | :-------------------------------------------------------- |
| PnmlCore     |       |       |      | &lt;name&gt; is only defined label                              |
| PTNet        | PTM   | none  | PTI  | &lt;initialMarking&gt;, &lt;inscription&gt; labels only have &lt;text&gt;   |
| HLCore       | HLM   | Cond  | HLI  | support structure used by all HL Petri Net Graphs         |
| PT-HLPNG     | HLM   | Cond  | HLI  | restrict sort to dot, condition always true               |
| SymmetricNet | HLM   | Cond  | HLI  | restrict sorts to finite, annotations have &lt;structure&gt;    |
| HLNet        | HLM   | Cond  | HLI  | extend symmetric with arbitrary sorts                     |
| Stochastic   |       | Rate  |      | continuous or discrete                                    |
| Timed        |       |       |      | continuous or discrete                                    |
| Open         |       |       |      | continuous or discrete                                    |

Todo: Continuous Petri Net

| Abbreviation | Full Name     | Node       | Label Description                                   |
|:-------------|:--------------|:-----------|:----------------------------------------------------|
| PTM          | PTMarking     | Place      |                                                     |
| PTI          | PTInscription | Arc        |                                                     |
| HLM          | HLMarking     | Place      |                                                     |
| HLI          | HLInscription | Arc        |                                                     |
| Cond         | Condition     | Transition |                                                     |
| Rate         | Rate          | Transition | random variable or function of marking, firing rate |
| Pri          | Priority      | Transition | firing order of enabled transitions                 |
| We           | Weight        | Transition | firing tiebreaker                                   |
|              |               |            |                                                     |


### PetriNet
[`PetriNet`](@ref) uses the Intermediate Representation and `PnmlType` to implement a petri Net Graph.
</code></pre><p>@example type println(AbstractTrees.repr_tree(PNML.PetriNet)) # hide</p><pre><code class="nohighlight hljs">
### Intermediate Representation: Nodes, Labels, Terms, &amp; Other</code></pre><p>@example type foreach(typet) do t; println(t); end # hide</p><pre><code class="nohighlight hljs">## Top Level: Model, Net, Page

At the top level a &lt;pnml&gt; model is one or more networks::[`PnmlNet`](@ref),
each described by a &lt;net&gt; tag and one or more &lt;page&gt; tags.

[`Page`](@ref) is mostly present for visual presentation to humans.
It also contains [`PnmlObject`](@ref) types that implement the Petri Net Graph (PNG).

[`ObjectCommon`](@ref) is a field of most types.
This allows `Graphics` and `ToolInfo` to appear almost anywhere in the PNG.

While [`Graphics`](@ref) is implemented as part of `ObjectCommon`
it is not dicussed further (until someone extends/uses it).

`ObjectCommon`  also has [`ToolInfo`](@ref) used to attach well-formed XML.
TODO: Need way to parse &lt;toolspecific&gt; that is flexible/extendable.

Parse pnml for input, worry about writing back out and interchange later (future extensions).
Another future extension may be to use pages for distributed computing.

The pnml specification permits that multiple pages to be flattened
(by [`flatten_pages!`](@ref)) to a single `Page` before use.
Using them unflattened is not supposed to be impossible,
but is not the arena or the initial use cases (in no paticular order):
adapting to use graph tools, agent based modeling, sciml, etc.

[`PetriNet`](@ref) subtypes wrap and extend [`PnmlNet`](@ref).
`PnmlNet` and its contents can be considered an intermediate representation (IR).
A concrete `PetriNet` type uses the IR to produce higher-level behavior.
This is the level at which `flatten_pages!` and `deref!` operate.

`PetriNet` is the level of most Petri Net Graph semantics.
One example is enforcing integer, non-negative, positive.

Remember, the IR trys to be as promiscuous as possible.

XML &lt;net&gt; tags are 1st parsed into `PnmlDict` which is used to construct a [`PnmlNet`](@ref):

| key          | value description                              |
| :----------- | :--------------------------------------------  |
| tag          | XML tag name is standard in the IR             |
| id           | unique ID                                      |
| name         | text name, optional                            |
| tools        | list of tool specific - possibly empty         |
| labels       | list of generic &quot;pnml labels&quot; - possible empty |
| type         | PnmlType defines schema the XML should meet    |
| declarations | defines high-level semantics of a net          |
| pages        | list of pages - not empty                      |

See [`parse_net`](@ref) for more detail.

XML &lt;page&gt; tags are also 1st parsed into `PnmlDict` which is used to construct a [`Page`](@ref):

| key          | value description                              |
| :----------- | :--------------------------------------------  |
| tag          | XML tag name is standard in the IR             |
| id           | unique ID                                      |
| name         | text name, optional                            |
| tools        | list of tool specific - possibly empty         |
| labels       | list of generic &quot;pnml labels&quot; - possible empty |
| places       | list of places                                 |
| trans        | list of transitions                            |
| arcs         | list of arcs                                   |
| refP         | references to place on different page          |
| refT         | references to transition on different page     |
| declarations | only net &amp; page tags have declarations         |

See also: [`parse_page`](@ref).

## Places

Properties that various places may have one or more of:
  * discrete
  * continuous
  * timed

## Transitions

Properties that various transitions may have one or more of:
  * discrete
  * continuous
  * hybrid of discrete &amp; continuous subnets
  * stochastic
  * immediate
  * deterministically time delayed
  * scheduled

The pnml schemas and primer only try to cover the discrete case as High-Level nets.
With a lot of multi-sorted algebra to make it complicated enough to be challanging.

Continous support is present where possible. For instance, when a number appers in the XML
[`number_value`](@ref) is used to parse the string to `Int` or `Float64.
This is currently (2022) &quot;non-standard&quot; so such pnml files will not be generally
interchangable with other tools.

https://www.sciencedirect.com/science/article/pii/S0303264721001714#b8

&#39;Discrete, Continuous, and Hybrid Petri Nets&#39; Rene David and Hassane Alla

See [`rate`](@ref) for a use of non-standard labels by [`SimpleNet`](@ref).
Implements a continuous petri net as part of the first working use-case.
Demonstrates the expressiveness of pnml.

## Petri Net Graphs and Networks

There are 3 top-level forms:
  - [`PetriNet`](@ref) subtypes wraping a single `PnmlNet`.
  - [`PnmlNet`](@ref)  maybe multiple pages.
  - [`Page`](@ref) when the only page of the only net in a petrinet.

The simplest arrangement is a pnml model with a single &lt;net&gt; element having
a single page. Any &lt;net&gt; may be flatten to a single page.

The initial `PetriNet` subtypes are built using the assumption that
multiple pages will be flattened to a single page.
</code></pre><p>@setup methods using AbstractTrees, PNML, InteractiveUtils, Markdown</p><pre><code class="nohighlight hljs">
## Simple Interface Methods

### pid - get PNML ID symbol

Objects within a pnml graph have unique identifiers,
which are used for referring to the object.
This includes:
[`PnmlObject`](@ref) subtypes,
[`PnmlNet`](@ref).

[`PNML.pid`](@ref)</code></pre><p>@example methods methods(PNML.pid) # hide</p><pre><code class="nohighlight hljs">### name - get name

`PnmlObject`s and `PnmlNet`s have a name label. 
[`Declaration`](@ref)s have a name attribute.
[`ToolInfo](@ref)s have a toolname attribute.

[`PNML.name`](@ref)</code></pre><p>@example methods methods(PNML.name) # hide</p><pre><code class="nohighlight hljs">
### tag - access XML tag symbol

[`PNML.tag`](@ref)</code></pre><p>@example methods methods(PNML.tag) # hide</p><pre><code class="nohighlight hljs">
### has\_xml - is xml attached

[`PNML.has_xml`](@ref)</code></pre><p>@example methods methods(PNML.has_xml) # hide</p><pre><code class="nohighlight hljs">
### xmlnode - access xml

[`PNML.xmlnode`](@ref)</code></pre><p>@example methods methods(PNML.xmlnode) # hide</p><pre><code class="nohighlight hljs">
### nettype - return PnmlType identifying PNTD

[`PNML.nettype`](@ref)</code></pre><p>@example methods methods(PNML.nettype) # hide</p><pre><code class="nohighlight hljs">
## Nodes of Petri Net Graph

Return vector of nodes.

### places
[`PNML.places`](@ref)</code></pre><p>@example methods methods(PNML.places) # hide</p><pre><code class="nohighlight hljs">### transitions
[`PNML.transitions`](@ref)</code></pre><p>@example methods methods(PNML.transitions) # hide</p><pre><code class="nohighlight hljs">### arcs
[`PNML.arcs`](@ref)</code></pre><p>@example methods methods(PNML.arcs) # hide</p><pre><code class="nohighlight hljs">### refplaces
[`PNML.refplaces`](@ref)</code></pre><p>@example methods methods(PNML.refplaces)  # hide</p><pre><code class="nohighlight hljs">### reftransitions
[`PNML.reftransitions`](@ref)</code></pre><p>@example methods methods(PNML.reftransitions)  # hide</p><pre><code class="nohighlight hljs">
## Node Predicates - uses PNML ID

### has\_place
[`PNML.has_place`](@ref)</code></pre><p>@example methods methods(PNML.has_place)  # hide</p><pre><code class="nohighlight hljs">### has\_transition
[`PNML.has_place`](@ref)</code></pre><p>@example methods methods(PNML.has_transition)  # hide</p><pre><code class="nohighlight hljs">### has\_arc
[`PNML.has_arc`](@ref)</code></pre><p>@example methods methods(PNML.has_arc) # hide</p><pre><code class="nohighlight hljs">### has\_refP
[`PNML.has_refP`](@ref)</code></pre><p>@example methods methods(PNML.has_refP)  # hide</p><pre><code class="nohighlight hljs">### has\_refT
[`PNML.has_refT`](@ref)</code></pre><p>@example methods methods(PNML.has_refT)  # hide</p><pre><code class="nohighlight hljs">
## Node Access - uses PNML ID

### place
[`PNML.place`](@ref)</code></pre><p>@example methods methods(PNML.place)  # hide</p><pre><code class="nohighlight hljs">### transition
[`PNML.transition`](@ref)</code></pre><p>@example methods methods(PNML.transition) # hide</p><pre><code class="nohighlight hljs">### arc
[`PNML.arc`](@ref)</code></pre><p>@example methods methods(PNML.arc)  # hide</p><pre><code class="nohighlight hljs">### refplace
[`PNML.refplace`](@ref)</code></pre><p>@example methods methods(PNML.refplace)  # hide</p><pre><code class="nohighlight hljs">### reftransition
[`PNML.reftransition`](@ref)</code></pre><p>@example methods methods(PNML.reftransition)  # hide</p><pre><code class="nohighlight hljs">
## Node ID Vector

### place\_ids
[`PNML.place_ids`](@ref)</code></pre><p>@example methods methods(PNML.place_ids)  # hide</p><pre><code class="nohighlight hljs">### transition\_ids
[`PNML.transition_ids`](@ref)</code></pre><p>@example methods methods(PNML.transition_ids)  # hide</p><pre><code class="nohighlight hljs">### arc\_ids
[`PNML.arc_ids`](@ref)</code></pre><p>@example methods methods(PNML.arc_ids)  # hide</p><pre><code class="nohighlight hljs">### refplace\_ids
[`PNML.refplace_ids`](@ref)</code></pre><p>@example methods methods(PNML.refplace_ids)  # hide</p><pre><code class="nohighlight hljs">### reftransition\_ids
[`PNML.reftransition_ids`](@ref)</code></pre><p>@example methods methods(PNML.reftransition_ids)  # hide</p><pre><code class="nohighlight hljs">
## Arc Related

### all\_arcs - source or target is PNML ID
[`PNML.all_arcs`](@ref)</code></pre><p>@example methods methods(PNML.all_arcs)  # hide</p><pre><code class="nohighlight hljs">### src\_arcs - source is PNML ID
[`PNML.src_arcs`](@ref)</code></pre><p>@example methods methods(PNML.src_arcs)  # hide</p><pre><code class="nohighlight hljs">### tgt\_arcs - target is PNML ID
[`tgt_arcs`](@ref)</code></pre><p>@example methods methods(PNML.tgt_arcs)  # hide</p><pre><code class="nohighlight hljs">### inscription - evaluate inscription value (or return default)
[`inscription`](@ref)</code></pre><p>@example methods methods(PNML.inscription)  # hide</p><pre><code class="nohighlight hljs">### deref! - dereference all references of flattened net
[`deref!`](@ref)</code></pre><p>@example methods methods(PNML.deref!)  # hide</p><pre><code class="nohighlight hljs">### deref\_place - derefeence one place
[`deref_place`](@ref)</code></pre><p>@example methods methods(PNML.deref_place)  # hide</p><pre><code class="nohighlight hljs">### deref\_transition - dereference one transition
[`deref_transition`](@ref)</code></pre><p>@example methods methods(PNML.deref_transition)  # hide</p><pre><code class="nohighlight hljs">
## Place Related

### marking - evaluate marking value (or return default)
[`marking`](@ref)</code></pre><p>@example methods methods(PNML.marking)  # hide</p><pre><code class="nohighlight hljs">### initialMarking -
[`initialMarking`](@ref)</code></pre><p>@example methods methods(PNML.initialMarking)  # hide</p><pre><code class="nohighlight hljs">
## Transition Related

### conditions - collect evaluated conditions
[`conditions`](@ref)</code></pre><p>@example methods methods(PNML.conditions)  # hide</p><pre><code class="nohighlight hljs">### condition - evaluate condition of one transition
[`condition`](@ref)</code></pre><p>@example methods methods(PNML.condition)  # hide</p><pre><code class="nohighlight hljs">### transition\_function - return `LVector` of `in_out` for all transitions
[`transition_function`](@ref)</code></pre><p>@example methods methods(PNML.transition_function)  # hide</p><pre><code class="nohighlight hljs">### in\_out - tuple of `ins`, `outs` of one transition
[`in_out`](@ref)</code></pre><p>@example methods methods(PNML.in_out)  # hide</p><pre><code class="nohighlight hljs">
### ins - `LVector` of source arc evaluated inscriptions.
[`ins`](@ref)</code></pre><p>@example methods methods(PNML.ins)  # hide</p><pre><code class="nohighlight hljs">
### outs - `LVector` of target arc evaluated inscriptions.
[`outs`](@ref)</code></pre><p>@example methods methods(PNML.outs)  # hide</p><pre><code class="nohighlight hljs">
## Labels - `Annotation` and `HLAnnotation`

Both have `ObjectCommon`. [`HLAnnotation`](@ref) adds optional &lt;text&gt;, &lt;structure&gt;.

### has\_text
[`has_text`](@ref)</code></pre><p>@example methods methods(PNML.has_text) # hide</p><pre><code class="nohighlight hljs">
### has\_structure
[`has_structure`](@ref)</code></pre><p>@example methods methods(PNML.has_structure) # hide</p><pre><code class="nohighlight hljs">
### text
[`text`](@ref)</code></pre><p>@example methods methods(PNML.text) # hide</p><pre><code class="nohighlight hljs">
### structure
[`structure`](@ref)</code></pre><p>@example methods methods(PNML.structure) # hide</p><pre><code class="nohighlight hljs">
### has_labels - do any exist
[`has_labels`](@ref)</code></pre><p>@example methods methods(PNML.has_labels) # hide</p><pre><code class="nohighlight hljs">
### has_label - does a specific label exist
[`has_label`](@ref)</code></pre><p>@example methods methods(PNML.has_label) # hide</p><pre><code class="nohighlight hljs">
### get_label - get a specific label
[`get_label`](@ref)</code></pre><p>@example methods methods(PNML.get_label) # hide</p><pre><code class="nohighlight hljs">
## ToolInfo

### has_toolinfo - does a specific toolinfo exist
[`has_toolinfo`](@ref)</code></pre><p>@example methods methods(PNML.has_toolinfo) # hide</p><pre><code class="nohighlight hljs">### get_toolinfo - get a specific toolinfo exist
[`get_toolinfo`](@ref)</code></pre><p>@example methods methods(PNML.get_toolinfo) # hide ```</p><h2 id="PnmlType-traits"><a class="docs-heading-anchor" href="#PnmlType-traits">PnmlType traits</a><a id="PnmlType-traits-1"></a><a class="docs-heading-anchor-permalink" href="#PnmlType-traits" title="Permalink"></a></h2><p>See <a href="../API/pnmltypes/#PnmlTypes">PnmlTypes</a> for details of the module.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../IR/">« Intermediate Representation</a><a class="docs-footer-nextpage" href="../API/library/">PNML »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Thursday 26 May 2022 02:13">Thursday 26 May 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

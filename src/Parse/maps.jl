# Ideas from MathML.jl

"""
$(TYPEDEF)
Map XML <tag> names to parser functions named "parse_tag".
Allows associative lookup of parser using ideas from Tim Holy's MathML package.

"""
const tagmap = Dict{String,Function}(
    # Some are not called by parse_node. Called directly, perhaps with varying arguments.
    # So replace any calls through this path with a warning/error. Usually caused by tests.
    # --------------------------
    "pnml" => parse_excluded,
    "net" => parse_excluded,
    "page"  => parse_excluded,
    "place"  => parse_excluded,
    "arc"  => parse_excluded,
    "transition"  => parse_excluded,
    "referencePlace"  => parse_excluded,
    "referenceTransition"  => parse_excluded,

    "and" => parse_and,
    "arbitraryoperator" => parse_arbitraryoperator,
    "arbitrarysort" => parse_arbitrarysort,
    "bool" => parse_bool,
    "booleanconstant" => parse_booleanconstant,
    "condition" => parse_condition,
    "declaration" => parse_declaration,
    #"declarations"  => parse_declarations,
    "equality" => parse_equality,
    "graphics" => parse_graphics,
    "hlinitialMarking" => parse_hlinitialMarking,
    "hlinscription" => parse_hlinscription,
    "imply" => parse_imply,
    "inequality" => parse_inequality,
    "initialMarking" => parse_initialMarking,
    "inscription" => parse_inscription,
    "label" => parse_label,
    "mulitsetsort" => parse_mulitsetsort,
    "name" => parse_name,
    "namedoperator" => parse_namedoperator,
    "not" => parse_not,
    "or" => parse_or,
    "productsort" => parse_productsort,
    "sort" => parse_sort,
    "structure" => parse_structure,
    "subterm" => parse_subterm, # Form expressions in the many-sorted algebra syntax tree.
    #"term" NO SUCH TAG, is a named child of <structure>, fed to parse_term, et al.
    "text" => parse_text,
    "tokengraphics"  => parse_tokengraphics,
    "tokenposition" => parse_tokenposition,
    "toolspecific"  => parse_toolspecific,
    "tuple" => parse_tuple,
    "type" => parse_type,
    "unparsed" => parse_unparsed,
    "useroperator" => parse_useroperator,
    "usersort" => parse_usersort,
    "variable" => parse_variable,
    "variabledecl" => parse_variabledecl,

    # High-Level Petri Net tags are part of a many-sorted algebra.
    # ----------------------------
    # "add" => unparsed_tag,
    # "addition" => unparsed_tag,
    # "all" => unparsed_tag,
    # "anyName" => unparsed_tag,
    # "arctype" => unparsed_tag,
    # "attribute" => unparsed_tag,
    # "bool" => unparsed_tag,
    # "cardinality" => unparsed_tag,
    # "cardinalityof" => unparsed_tag,
    # "choice" => unparsed_tag,
    # "cyclicenumeration" => unparsed_tag,
    # "data" => unparsed_tag,
    # "def" => unparsed_tag,
    # "define" => unparsed_tag,
    # "dimension" => unparsed_tag,
    # "div" => unparsed_tag,
    # "dot" => unparsed_tag,
    # "dotconstant" => unparsed_tag,
    # "element" => unparsed_tag,
    # "empty" => unparsed_tag,
    # "emptylist" => unparsed_tag,
    # "except" => unparsed_tag,
    # "externalRef" => unparsed_tag,
    # "feconstant" => unparsed_tag,
    # "fill" => unparsed_tag,
    # "finiteenumeration" => unparsed_tag,
    # "finiteintrange" => unparsed_tag,
    # "finiteintrangeconstant" => unparsed_tag,
    # "font" => unparsed_tag,
    # "geq" => unparsed_tag,
    # "geqs" => unparsed_tag,
    # "grammar" => unparsed_tag,
    # "greaterthan" => unparsed_tag,
    # "greaterthanorequal" => unparsed_tag,
    # "group" => unparsed_tag,
    # "gt" => unparsed_tag,
    # "gtp" => unparsed_tag,
    # "gts" => unparsed_tag,
    # "include" => unparsed_tag,
    # "input" => unparsed_tag,
    # "integer" => unparsed_tag,
    # "interleave" => unparsed_tag,
    # "leq" => unparsed_tag,
    # "leqs" => unparsed_tag,
    # "lessthan" => unparsed_tag,
    # "lessthanorequal" => unparsed_tag,
    # "line" => unparsed_tag,
    # "list" => unparsed_tag,
    # "listappend" => unparsed_tag,
    # "listconcatenation" => unparsed_tag,
    # "listlength" => unparsed_tag,
    # "lt" => unparsed_tag,
    # "ltp" => unparsed_tag,
    # "lts" => unparsed_tag,
    # "makelist" => unparsed_tag,
    # "memberatindex" => unparsed_tag,
    # "mixed" => unparsed_tag,
    # "mod" => unparsed_tag,
    # "mult" => unparsed_tag,
    # "multisetsort" => unparsed_tag,
    # "namedsort" => unparsed_tag,
    # "natural" => unparsed_tag,
    # "notAllowed" => unparsed_tag,
    # "nsName" => unparsed_tag,
    # "numberconstant" => unparsed_tag,
    # "numberof" => unparsed_tag,
    # "offset" => unparsed_tag,
    # "oneOrMore" => unparsed_tag,
    # "optional" => unparsed_tag,
    # "output" => unparsed_tag,
    # "param" => unparsed_tag,
    # "parameter" => unparsed_tag,
    # "parentRef" => unparsed_tag,
    # "partition" => unparsed_tag,
    # "partitionelement" => unparsed_tag,
    # "partitionelementof" => unparsed_tag,
    # "position" => unparsed_tag,
    # "positive" => unparsed_tag,
    # "predecessor" => unparsed_tag,
    # "ref" => unparsed_tag,
    # "scalarproduct" => unparsed_tag,
    # "start" => unparsed_tag,
    # "string" => unparsed_tag,
    # "stringappend" => unparsed_tag,
    # "stringconcatenation" => unparsed_tag,
    # "stringconstant" => unparsed_tag,
    # "stringlength" => unparsed_tag,
    # "sublist"  => unparsed_tag,
    # "substring" => unparsed_tag,
    # "subtract" => unparsed_tag,
    # "subtraction" => unparsed_tag,
    # "successor" => unparsed_tag,
    # "value" => unparsed_tag,
    # "zeroOrMore" => unparsed_tag,
)

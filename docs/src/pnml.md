```@meta
CurrentModule = PNML
```

# PNML.jl

Documentation for the GitHub [PNML.jl](https://github.com/strangehurst/PNML.jl) repository.
Which defines a Julia module named `PNML`.  
Which handles an XML markup language with the acronym 'PNML' -- Petri Net Markup language.

```@eval
using Markdown
using Pkg
using Dates
using InteractiveUtils

function print_dep_version(depname)
    deps = Pkg.dependencies()
    version = first(d for d in deps if d.second.name == depname).second.version

    "$depname: v$version"
end

Markdown.parse("""
	These docs were autogenerated at $(now()) on $(gethostname()) using:
        - $(print_dep_version("PNML"))
	    - $(print_dep_version("EzXML"))
   """)
```

```@repl
using InteractiveUtils; # hide
versioninfo()
```

## www.pnml.org

In this section 'PNML' refers to the markup language, its specification and schemas.

<http://www.pnml.org> has publications and tutorials covering PNML at
various points in its evolution. Is the cannonical site for the
RELAX-NG XML schemas that define the grammer of several Petri Net Type Defintions (pntd),
including:
  - PT Net 
  - High-level Place/Transition Net
  - Symmetric Net

These are instances of the 3 flavors currently covered by PNML.

There are links to a series of ISO/IEC 15909 standards relating to PNML. They cost money.

It seems the people behind PNML are of the Model Driven Engineering (MDE) camp
and have chosen Java, Eclipse and its EMF. There is GUI focus. 
One can find some PNML implementations in other languages

The high-level marking, inscription, condition and declaration are where the hard work waits.

See [*A primer on the Petri Net Markup Language and ISO/IEC 15909-2*](https://www.pnml.org/papers/pnnl76.pdf)(pdf)
for more details. The rest of this page will make more sense if you are
familiar with the primer's contents.


## Interoperability

Petri Net Type Definition schema files (pntd) are defined using RELAX-NG XML Schema files.
Petri Net Markup Language files (pnml) are intended to be validated against a pntd schema.

For interchange of pnml between tools it should be enough to support the same pntd schema.

Note that ISO is working on part 3 of the PNML standard covering pntd (as of October 2021).

It is possibly to create a non-standard pntd. And more will be standardized, either
formally or informally. Non-standard mostly means that the interchangibility is restricted.

Since validation is not a goal of PNML.jl, non-standard pntds can be used for the
URI of an XML `net` tag's `type` attribute. Notably `pnmlcore` and `nonstandard`
are mapped to PnmlCore.

PnmlCore is the minimum level of meaning that any pnml file can hold.
PNML.jl should be able to create a valid intermediate representation using PnmlCore,
since all the higher-level meaning is expressed as pnml labels, restrictions,
and required XML tag names.

Further parsing of labels are delegated to some subtype of [`PNML.PetriNet`](@ref).

If you want interchangability of pnml models, you will have to stick to
the standard pnml pntds. The High Level Petri Net, even when restricted to
symmetricnet.pntd, is very expressive. Even the base pnmlcore.pntd is useful.

Note that the official pntd schema files are in the grammer directory.

## Why no Schema Verification

Within PNML.jl no schema-level validation is done.

Note that, depending on context, 'PNML' may refer to either 
the markup language or the Julia code.

In is allowed by the PNML specification to omit validation with the presumption that
some specialized, external tool can be applied, thus allowing the file format to be
used for inter-tool communication with lower overhead in each tool.

Also a desire to allow "duck typing" of Petri Nets built upon the
PNML intermediate representration.

Also, non-standard pntd that do not (yet) have a schema written are part of
the PNML implementation. See [`ContinuousNet`](@ref).

## PNTD Maps

Defaut PNTD to Symbol map (URI string to pntd symbol):
```@example
using PNML; foreach(println, sort(collect(pairs(PnmlTypeDefs.default_pntd_map)))) #hide
```

PnmlType map (pntd symbol to singleton):
```@example
using PNML; foreach(println, pairs(PnmlTypeDefs.pnmltype_map)) #hide
```


## Handling Labels

The implementation of Labels supports _annotation_ and _attribute_ format labels.

### Annotation Labels

_annotation_ format labels are expected to have either a <text> element, 
a <structure> element or both. Often the <text> is a human-readable representation
of of the <structure> element. `Graphics` and `ToolInfo` elements may be present.

For `PTNet` (and `pnmlcore`) only the `Name` label with a <text> element
(and no <structure> element) is defined.

Labels defined in High-Level pntds, specifically 'Symmetric Nets',
"require" all meaning to reside in the <structure>.

### Attribute Labels

_attribute_ format labels are present in the UML model of pnml.
They differ from _annotation_ by omitting the `Graphics` element, 
but retain the `ToolInfo` element. Unless an optimization is identified,
both _attribute_ and _annotation_ will share the same implementation.

A standard-conforming pnml model would not have any `Graphics` element 
so that field would be `nothing`.

## High-level Petri Net Concepts

From a draft version of _ISO/IEC 15909-1:2004 High-level Petri nets - Part 1:
Concepts, definitions and graphical notation._

Useful for setting the ontology.

Arc inscriptions are expressions that are evaluated.

Place markings are multisets of tokens of a sort/type.

Transition conditions are boolean expressions that are evaluated. 
Used to determine if transition is enabled. 

Expressions in _pnml_ can be many-sorted algebras.
Declaration, Term, Sort, Multiset, Variable, are among the concepts
used to define expressions.


### Terms

Terms have _sort_s: the sort of the variable or the output sort of the operator.

Terms can be buit from built-in *operator*s and *sort*s, and user-defined *variable*s.
These are defined in *variable declaration*s, a kind of
*annotation* label attached to *page*s and *net*s.

A *transition* can have a *condition*, a term of *sort* boolean,
which imposes restrictions on when the transition may fire.

### Sorts

*named sort*s are constructed from existing *sort*s and given a new name.

*arbitrary sort* is not defined in core, is not allowed in Symmetric Nets.
HLPNG adds arbitrary declarations, sorts of lists, strings, integers to Symmetric Nets.

The sort of a term is the sort of the *variable* or the output sort of the *operator*.

### Operators

An *operator* can be:
built-in constant, built-in operator, multiset operator or tuple operator.

User-defined operators, or *named operator*s are abbreviations, built from
existing *operator*s and parameter variables.

There will be arbitrary operator declarations for High-Level Petri Net Graphs,
but not for Symmetric Nets.

Operators have a sequence of input sorts and a single output sort.

### Variables

__TBD__

## Continuous, Open and Other Petri Nets

Allow marking, inscription, conditions to be floating point even when specification
wants an integer. This allows continuous nets.

See [Petri.jl](https://github.com/mehalter/Petri.jl)
and [AlgebraicPetri.jl](https://github.com/AlgebraicJulia/AlgebraicPetri.jl)
for some continuous use-cases.

TODO: Hybrid nets combining floating point/continuous and integer/discrete
inscription/marking.


## References

See [`PnmlTypeDefs.PnmlType `](@ref),
[`PnmlTypeDefs.default_pntd_map`](@ref),
[`PnmlTypeDefs.pnmltype_map`](@ref)
